{"mappings":"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","sources":["<anon>","node_modules/@splidejs/splide/dist/js/splide.min.js","node_modules/@splidejs/splide/src/js/constants/media.ts","node_modules/@splidejs/splide/src/js/constants/states.ts","node_modules/@splidejs/splide/src/js/utils/array/empty/empty.ts","node_modules/@splidejs/splide/src/js/utils/arrayLike/slice/slice.ts","node_modules/@splidejs/splide/src/js/utils/function/apply/apply.ts","node_modules/@splidejs/splide/src/js/utils/function/noop/noop.ts","node_modules/@splidejs/splide/src/js/utils/function/nextTick/nextTick.ts","node_modules/@splidejs/splide/src/js/utils/function/raf/raf.ts","node_modules/@splidejs/splide/src/js/utils/type/type.ts","node_modules/@splidejs/splide/src/js/utils/array/toArray/toArray.ts","node_modules/@splidejs/splide/src/js/utils/array/forEach/forEach.ts","node_modules/@splidejs/splide/src/js/utils/array/includes/includes.ts","node_modules/@splidejs/splide/src/js/utils/array/push/push.ts","node_modules/@splidejs/splide/src/js/utils/dom/toggleClass/toggleClass.ts","node_modules/@splidejs/splide/src/js/utils/dom/addClass/addClass.ts","node_modules/@splidejs/splide/src/js/utils/dom/append/append.ts","node_modules/@splidejs/splide/src/js/utils/dom/before/before.ts","node_modules/@splidejs/splide/src/js/utils/dom/matches/matches.ts","node_modules/@splidejs/splide/src/js/utils/dom/children/children.ts","node_modules/@splidejs/splide/src/js/utils/dom/child/child.ts","node_modules/@splidejs/splide/src/js/utils/object/ownKeys/ownKeys.ts","node_modules/@splidejs/splide/src/js/utils/object/forOwn/forOwn.ts","node_modules/@splidejs/splide/src/js/utils/object/assign/assign.ts","node_modules/@splidejs/splide/src/js/utils/object/merge/merge.ts","node_modules/@splidejs/splide/src/js/utils/object/omit/omit.ts","node_modules/@splidejs/splide/src/js/utils/dom/removeAttribute/removeAttribute.ts","node_modules/@splidejs/splide/src/js/utils/dom/setAttribute/setAttribute.ts","node_modules/@splidejs/splide/src/js/utils/dom/create/create.ts","node_modules/@splidejs/splide/src/js/utils/dom/style/style.ts","node_modules/@splidejs/splide/src/js/utils/dom/display/display.ts","node_modules/@splidejs/splide/src/js/utils/dom/focus/focus.ts","node_modules/@splidejs/splide/src/js/utils/dom/getAttribute/getAttribute.ts","node_modules/@splidejs/splide/src/js/utils/dom/hasClass/hasClass.ts","node_modules/@splidejs/splide/src/js/utils/dom/rect/rect.ts","node_modules/@splidejs/splide/src/js/utils/dom/remove/remove.ts","node_modules/@splidejs/splide/src/js/utils/dom/parseHtml/parseHtml.ts","node_modules/@splidejs/splide/src/js/utils/dom/prevent/prevent.ts","node_modules/@splidejs/splide/src/js/utils/dom/query/query.ts","node_modules/@splidejs/splide/src/js/utils/dom/queryAll/queryAll.ts","node_modules/@splidejs/splide/src/js/utils/dom/removeClass/removeClass.ts","node_modules/@splidejs/splide/src/js/utils/dom/timeOf/timeOf.ts","node_modules/@splidejs/splide/src/js/utils/dom/unit/unit.ts","node_modules/@splidejs/splide/src/js/constants/project.ts","node_modules/@splidejs/splide/src/js/utils/error/assert/assert.ts","node_modules/@splidejs/splide/src/js/utils/math/math/math.ts","node_modules/@splidejs/splide/src/js/utils/math/approximatelyEqual/approximatelyEqual.ts","node_modules/@splidejs/splide/src/js/utils/math/between/between.ts","node_modules/@splidejs/splide/src/js/utils/math/clamp/clamp.ts","node_modules/@splidejs/splide/src/js/utils/math/sign/sign.ts","node_modules/@splidejs/splide/src/js/utils/string/format/format.ts","node_modules/@splidejs/splide/src/js/utils/string/pad/pad.ts","node_modules/@splidejs/splide/src/js/utils/string/uniqueId/uniqueId.ts","node_modules/@splidejs/splide/src/js/constructors/EventBinder/EventBinder.ts","node_modules/@splidejs/splide/src/js/constants/events.ts","node_modules/@splidejs/splide/src/js/constructors/EventInterface/EventInterface.ts","node_modules/@splidejs/splide/src/js/constructors/RequestInterval/RequestInterval.ts","node_modules/@splidejs/splide/src/js/constructors/State/State.ts","node_modules/@splidejs/splide/src/js/constants/arrows.ts","node_modules/@splidejs/splide/src/js/constants/directions.ts","node_modules/@splidejs/splide/src/js/components/Direction/Direction.ts","node_modules/@splidejs/splide/src/js/constants/attributes.ts","node_modules/@splidejs/splide/src/js/constants/classes.ts","node_modules/@splidejs/splide/src/js/components/Drag/constants.ts","node_modules/@splidejs/splide/src/js/constants/types.ts","node_modules/@splidejs/splide/src/js/components/Slides/Slide.ts","node_modules/@splidejs/splide/src/js/components/Autoplay/constants.ts","node_modules/@splidejs/splide/src/js/constants/listener-options.ts","node_modules/@splidejs/splide/src/js/utils/dom/normalizeKey/normalizeKey.ts","node_modules/@splidejs/splide/src/js/components/Keyboard/Keyboard.ts","node_modules/@splidejs/splide/src/js/components/LazyLoad/constants.ts","node_modules/@splidejs/splide/src/js/components/Sync/Sync.ts","node_modules/@splidejs/splide/src/js/components/Media/Media.ts","node_modules/@splidejs/splide/src/js/components/Elements/Elements.ts","node_modules/@splidejs/splide/src/js/utils/dom/closest/closest.ts","node_modules/@splidejs/splide/src/js/components/Slides/Slides.ts","node_modules/@splidejs/splide/src/js/components/Layout/Layout.ts","node_modules/@splidejs/splide/src/js/constructors/Throttle/Throttle.ts","node_modules/@splidejs/splide/src/js/components/Clones/Clones.ts","node_modules/@splidejs/splide/src/js/components/Move/Move.ts","node_modules/@splidejs/splide/src/js/components/Controller/Controller.ts","node_modules/@splidejs/splide/src/js/components/Arrows/Arrows.ts","node_modules/@splidejs/splide/src/js/components/Arrows/path.ts","node_modules/@splidejs/splide/src/js/components/Autoplay/Autoplay.ts","node_modules/@splidejs/splide/src/js/components/Cover/Cover.ts","node_modules/@splidejs/splide/src/js/components/Scroll/Scroll.ts","node_modules/@splidejs/splide/src/js/components/Scroll/constants.ts","node_modules/@splidejs/splide/src/js/components/Drag/Drag.ts","node_modules/@splidejs/splide/src/js/components/LazyLoad/LazyLoad.ts","node_modules/@splidejs/splide/src/js/components/Pagination/Pagination.ts","node_modules/@splidejs/splide/src/js/components/Wheel/Wheel.ts","node_modules/@splidejs/splide/src/js/components/Live/Live.ts","node_modules/@splidejs/splide/src/js/constants/defaults.ts","node_modules/@splidejs/splide/src/js/constants/i18n.ts","node_modules/@splidejs/splide/src/js/transitions/Fade/Fade.ts","node_modules/@splidejs/splide/src/js/transitions/Slide/Slide.ts","node_modules/@splidejs/splide/src/js/core/Splide/Splide.ts"],"sourcesContent":["function r(n, t) {\n    for(var i = 0; i < t.length; i++){\n        var r = t[i];\n        r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(n, r.key, r);\n    }\n}\nfunction Jt(n, t, i) {\n    t && r(n.prototype, t), i && r(n, i), Object.defineProperty(n, \"prototype\", {\n        writable: !1\n    });\n}\n/*!\n * Splide.js\n * Version  : 4.1.4\n * License  : MIT\n * Copyright: 2022 Naotoshi Fujita\n */ var n, t;\nn = this, t = function() {\n    \"use strict\";\n    var v = \"(prefers-reduced-motion: reduce)\", G = 4, rn = 5, r = {\n        CREATED: 1,\n        MOUNTED: 2,\n        IDLE: 3,\n        MOVING: G,\n        SCROLLING: rn,\n        DRAGGING: 6,\n        DESTROYED: 7\n    };\n    function D(n) {\n        n.length = 0;\n    }\n    function o(n, t, i) {\n        return Array.prototype.slice.call(n, t, i);\n    }\n    function R(n) {\n        return n.bind.apply(n, [\n            null\n        ].concat(o(arguments, 1)));\n    }\n    function on() {}\n    var p = setTimeout;\n    function h(n) {\n        return requestAnimationFrame(n);\n    }\n    function u(n, t) {\n        return typeof t === n;\n    }\n    function un(n) {\n        return !c(n) && u(\"object\", n);\n    }\n    var e = Array.isArray, x = R(u, \"function\"), C = R(u, \"string\"), en = R(u, \"undefined\");\n    function c(n) {\n        return null === n;\n    }\n    function m(n) {\n        try {\n            return n instanceof (n.ownerDocument.defaultView || window).HTMLElement;\n        } catch (n) {\n            return !1;\n        }\n    }\n    function y(n) {\n        return e(n) ? n : [\n            n\n        ];\n    }\n    function g(n, t) {\n        y(n).forEach(t);\n    }\n    function b(n, t) {\n        return -1 < n.indexOf(t);\n    }\n    function k(n, t) {\n        return n.push.apply(n, y(t)), n;\n    }\n    function A(t, n, i) {\n        t && g(n, function(n) {\n            n && t.classList[i ? \"add\" : \"remove\"](n);\n        });\n    }\n    function M(n, t) {\n        A(n, C(t) ? t.split(\" \") : t, !0);\n    }\n    function L(n, t) {\n        g(t, n.appendChild.bind(n));\n    }\n    function O(n, i) {\n        g(n, function(n) {\n            var t = (i || n).parentNode;\n            t && t.insertBefore(n, i);\n        });\n    }\n    function cn(n, t) {\n        return m(n) && (n.msMatchesSelector || n.matches).call(n, t);\n    }\n    function S(n, t) {\n        n = n ? o(n.children) : [];\n        return t ? n.filter(function(n) {\n            return cn(n, t);\n        }) : n;\n    }\n    function fn(n, t) {\n        return t ? S(n, t)[0] : n.firstElementChild;\n    }\n    var E = Object.keys;\n    function w(t, i, n) {\n        t && (n ? E(t).reverse() : E(t)).forEach(function(n) {\n            \"__proto__\" !== n && i(t[n], n);\n        });\n    }\n    function an(r) {\n        return o(arguments, 1).forEach(function(i) {\n            w(i, function(n, t) {\n                r[t] = i[t];\n            });\n        }), r;\n    }\n    function d(i) {\n        return o(arguments, 1).forEach(function(n) {\n            w(n, function(n, t) {\n                e(n) ? i[t] = n.slice() : un(n) ? i[t] = d({}, un(i[t]) ? i[t] : {}, n) : i[t] = n;\n            });\n        }), i;\n    }\n    function sn(t, n) {\n        g(n || E(t), function(n) {\n            delete t[n];\n        });\n    }\n    function P(n, i) {\n        g(n, function(t) {\n            g(i, function(n) {\n                t && t.removeAttribute(n);\n            });\n        });\n    }\n    function I(i, t, r) {\n        un(t) ? w(t, function(n, t) {\n            I(i, t, n);\n        }) : g(i, function(n) {\n            c(r) || \"\" === r ? P(n, t) : n.setAttribute(t, String(r));\n        });\n    }\n    function j(n, t, i) {\n        n = document.createElement(n);\n        return t && (C(t) ? M : I)(n, t), i && L(i, n), n;\n    }\n    function _(n, t, i) {\n        if (en(i)) return getComputedStyle(n)[t];\n        c(i) || (n.style[t] = \"\" + i);\n    }\n    function ln(n, t) {\n        _(n, \"display\", t);\n    }\n    function dn(n) {\n        n.setActive && n.setActive() || n.focus({\n            preventScroll: !0\n        });\n    }\n    function z(n, t) {\n        return n.getAttribute(t);\n    }\n    function vn(n, t) {\n        return n && n.classList.contains(t);\n    }\n    function N(n) {\n        return n.getBoundingClientRect();\n    }\n    function T(n) {\n        g(n, function(n) {\n            n && n.parentNode && n.parentNode.removeChild(n);\n        });\n    }\n    function hn(n) {\n        return fn((new DOMParser).parseFromString(n, \"text/html\").body);\n    }\n    function F(n, t) {\n        n.preventDefault(), t && (n.stopPropagation(), n.stopImmediatePropagation());\n    }\n    function pn(n, t) {\n        return n && n.querySelector(t);\n    }\n    function gn(n, t) {\n        return t ? o(n.querySelectorAll(t)) : [];\n    }\n    function X(n, t) {\n        A(n, t, !1);\n    }\n    function mn(n) {\n        return n.timeStamp;\n    }\n    function W(n) {\n        return C(n) ? n : n ? n + \"px\" : \"\";\n    }\n    var yn = \"splide\", f = \"data-\" + yn;\n    function bn(n, t) {\n        if (!n) throw new Error(\"[\" + yn + \"] \" + (t || \"\"));\n    }\n    var Y = Math.min, wn = Math.max, xn = Math.floor, kn = Math.ceil, U = Math.abs;\n    function Sn(n, t, i) {\n        return U(n - t) < i;\n    }\n    function En(n, t, i, r) {\n        var o = Y(t, i), t = wn(t, i);\n        return r ? o < n && n < t : o <= n && n <= t;\n    }\n    function q(n, t, i) {\n        var r = Y(t, i), t = wn(t, i);\n        return Y(wn(r, n), t);\n    }\n    function Ln(n) {\n        return (0 < n) - (n < 0);\n    }\n    function On(t, n) {\n        return g(n, function(n) {\n            t = t.replace(\"%s\", \"\" + n);\n        }), t;\n    }\n    function An(n) {\n        return n < 10 ? \"0\" + n : \"\" + n;\n    }\n    var _n = {};\n    function zn() {\n        var c = [];\n        function i(n, i, r) {\n            g(n, function(t) {\n                t && g(i, function(n) {\n                    n.split(\" \").forEach(function(n) {\n                        n = n.split(\".\");\n                        r(t, n[0], n[1]);\n                    });\n                });\n            });\n        }\n        return {\n            bind: function(n, t, u, e) {\n                i(n, t, function(n, t, i) {\n                    var r = \"addEventListener\" in n, o = r ? n.removeEventListener.bind(n, t, u, e) : n.removeListener.bind(n, u);\n                    r ? n.addEventListener(t, u, e) : n.addListener(u), c.push([\n                        n,\n                        t,\n                        i,\n                        u,\n                        o\n                    ]);\n                });\n            },\n            unbind: function(n, t, o) {\n                i(n, t, function(t, i, r) {\n                    c = c.filter(function(n) {\n                        return !!(n[0] !== t || n[1] !== i || n[2] !== r || o && n[3] !== o) || (n[4](), !1);\n                    });\n                });\n            },\n            dispatch: function(n, t, i) {\n                var r;\n                return \"function\" == typeof CustomEvent ? r = new CustomEvent(t, {\n                    bubbles: !0,\n                    detail: i\n                }) : (r = document.createEvent(\"CustomEvent\")).initCustomEvent(t, !0, !1, i), n.dispatchEvent(r), r;\n            },\n            destroy: function() {\n                c.forEach(function(n) {\n                    n[4]();\n                }), D(c);\n            }\n        };\n    }\n    var B = \"mounted\", H = \"move\", Dn = \"moved\", Mn = \"click\", Pn = \"active\", In = \"inactive\", Rn = \"visible\", Cn = \"hidden\", J = \"refresh\", K = \"updated\", jn = \"resize\", Nn = \"resized\", Tn = \"scroll\", V = \"scrolled\", a = \"destroy\", Gn = \"navigation:mounted\", Fn = \"autoplay:play\", Xn = \"autoplay:pause\", Wn = \"lazyload:loaded\", Yn = \"sk\", Un = \"sh\";\n    function Q(n) {\n        var i = n ? n.event.bus : document.createDocumentFragment(), r = zn();\n        return n && n.event.on(a, r.destroy), an(r, {\n            bus: i,\n            on: function(n, t) {\n                r.bind(i, y(n).join(\" \"), function(n) {\n                    t.apply(t, e(n.detail) ? n.detail : []);\n                });\n            },\n            off: R(r.unbind, i),\n            emit: function(n) {\n                r.dispatch(i, n, o(arguments, 1));\n            }\n        });\n    }\n    function qn(t, n, i, r) {\n        var o, u, e = Date.now, c = 0, f = !0, a = 0;\n        function s() {\n            if (!f) {\n                if (c = t ? Y((e() - o) / t, 1) : 1, i && i(c), 1 <= c && (n(), o = e(), r && ++a >= r)) return l();\n                u = h(s);\n            }\n        }\n        function l() {\n            f = !0;\n        }\n        function d() {\n            u && cancelAnimationFrame(u), f = (u = c = 0, true);\n        }\n        return {\n            start: function(n) {\n                n || d(), o = e() - (n ? c * t : 0), f = !1, u = h(s);\n            },\n            rewind: function() {\n                o = e(), c = 0, i && i(c);\n            },\n            pause: l,\n            cancel: d,\n            set: function(n) {\n                t = n;\n            },\n            isPaused: function() {\n                return f;\n            }\n        };\n    }\n    function s(n) {\n        var t = n;\n        return {\n            set: function(n) {\n                t = n;\n            },\n            is: function(n) {\n                return b(y(n), t);\n            }\n        };\n    }\n    var n = \"Arrow\", Bn = n + \"Left\", Hn = n + \"Right\", t = n + \"Up\", n = n + \"Down\", Jn = \"ttb\", l = {\n        width: [\n            \"height\"\n        ],\n        left: [\n            \"top\",\n            \"right\"\n        ],\n        right: [\n            \"bottom\",\n            \"left\"\n        ],\n        x: [\n            \"y\"\n        ],\n        X: [\n            \"Y\"\n        ],\n        Y: [\n            \"X\"\n        ],\n        ArrowLeft: [\n            t,\n            Hn\n        ],\n        ArrowRight: [\n            n,\n            Bn\n        ]\n    };\n    var Z = \"role\", $ = \"tabindex\", i = \"aria-\", Kn = i + \"controls\", Vn = i + \"current\", Qn = i + \"selected\", nn = i + \"label\", Zn = i + \"labelledby\", $n = i + \"hidden\", nt = i + \"orientation\", tt = i + \"roledescription\", it = i + \"live\", rt = i + \"busy\", ot = i + \"atomic\", ut = [\n        Z,\n        $,\n        \"disabled\",\n        Kn,\n        Vn,\n        nn,\n        Zn,\n        $n,\n        nt,\n        tt\n    ], i = yn + \"__\", et = yn, ct = i + \"track\", ft = i + \"list\", at = i + \"slide\", st = at + \"--clone\", lt = at + \"__container\", dt = i + \"arrows\", vt = i + \"arrow\", ht = vt + \"--prev\", pt = vt + \"--next\", gt = i + \"pagination\", mt = gt + \"__page\", yt = i + \"progress\" + \"__bar\", bt = i + \"toggle\", wt = i + \"sr\", tn = \"is-active\", xt = \"is-prev\", kt = \"is-next\", St = \"is-visible\", Et = \"is-loading\", Lt = \"is-focus-in\", Ot = \"is-overflow\", At = [\n        tn,\n        St,\n        xt,\n        kt,\n        Et,\n        Lt,\n        Ot\n    ];\n    var _t = \"touchstart mousedown\", zt = \"touchmove mousemove\", Dt = \"touchend touchcancel mouseup click\";\n    var Mt = \"slide\", Pt = \"loop\", It = \"fade\";\n    function Rt(o, r, t, u) {\n        var e, n = Q(o), i = n.on, c = n.emit, f = n.bind, a = o.Components, s = o.root, l = o.options, d = l.isNavigation, v = l.updateOnMove, h = l.i18n, p = l.pagination, g = l.slideFocus, m = a.Direction.resolve, y = z(u, \"style\"), b = z(u, nn), w = -1 < t, x = fn(u, \".\" + lt);\n        function k() {\n            var n = o.splides.map(function(n) {\n                n = n.splide.Components.Slides.getAt(r);\n                return n ? n.slide.id : \"\";\n            }).join(\" \");\n            I(u, nn, On(h.slideX, (w ? t : r) + 1)), I(u, Kn, n), I(u, Z, g ? \"button\" : \"\"), g && P(u, tt);\n        }\n        function S() {\n            e || E();\n        }\n        function E() {\n            var n, t, i;\n            e || (n = o.index, (i = L()) !== vn(u, tn) && (A(u, tn, i), I(u, Vn, d && i || \"\"), c(i ? Pn : In, O)), i = function() {\n                if (o.is(It)) return L();\n                var n = N(a.Elements.track), t = N(u), i = m(\"left\", !0), r = m(\"right\", !0);\n                return xn(n[i]) <= kn(t[i]) && xn(t[r]) <= kn(n[r]);\n            }(), t = !i && (!L() || w), o.state.is([\n                G,\n                rn\n            ]) || I(u, $n, t || \"\"), I(gn(u, l.focusableNodes || \"\"), $, t ? -1 : \"\"), g && I(u, $, t ? -1 : 0), i !== vn(u, St) && (A(u, St, i), c(i ? Rn : Cn, O)), i || document.activeElement !== u || (t = a.Slides.getAt(o.index)) && dn(t.slide), A(u, xt, r === n - 1), A(u, kt, r === n + 1));\n        }\n        function L() {\n            var n = o.index;\n            return n === r || l.cloneStatus && n === t;\n        }\n        var O = {\n            index: r,\n            slideIndex: t,\n            slide: u,\n            container: x,\n            isClone: w,\n            mount: function() {\n                w || (u.id = s.id + \"-slide\" + An(r + 1), I(u, Z, p ? \"tabpanel\" : \"group\"), I(u, tt, h.slide), I(u, nn, b || On(h.slideLabel, [\n                    r + 1,\n                    o.length\n                ]))), f(u, \"click\", R(c, Mn, O)), f(u, \"keydown\", R(c, Yn, O)), i([\n                    Dn,\n                    Un,\n                    V\n                ], E), i(Gn, k), v && i(H, S);\n            },\n            destroy: function() {\n                e = !0, n.destroy(), X(u, At), P(u, ut), I(u, \"style\", y), I(u, nn, b || \"\");\n            },\n            update: E,\n            style: function(n, t, i) {\n                _(i && x || u, n, t);\n            },\n            isWithin: function(n, t) {\n                return n = U(n - r), (n = w || !l.rewind && !o.is(Pt) ? n : Y(n, o.length - n)) <= t;\n            }\n        };\n        return O;\n    }\n    var Ct = f + \"-interval\";\n    var jt = {\n        passive: !1,\n        capture: !0\n    };\n    var Nt = {\n        Spacebar: \" \",\n        Right: Hn,\n        Left: Bn,\n        Up: t,\n        Down: n\n    };\n    function Tt(n) {\n        return n = C(n) ? n : n.key, Nt[n] || n;\n    }\n    var Gt = \"keydown\";\n    var Ft = f + \"-lazy\", Xt = Ft + \"-srcset\", Wt = \"[\" + Ft + \"], [\" + Xt + \"]\";\n    var Yt = [\n        \" \",\n        \"Enter\"\n    ];\n    var Ut = Object.freeze({\n        __proto__: null,\n        Media: function(r, n, o) {\n            var u = r.state, t = o.breakpoints || {}, e = o.reducedMotion || {}, i = zn(), c = [];\n            function f(n) {\n                n && i.destroy();\n            }\n            function a(n, t) {\n                t = matchMedia(t);\n                i.bind(t, \"change\", s), c.push([\n                    n,\n                    t\n                ]);\n            }\n            function s() {\n                var n = u.is(7), t = o.direction, i = c.reduce(function(n, t) {\n                    return d(n, t[1].matches ? t[0] : {});\n                }, {});\n                sn(o), l(i), o.destroy ? r.destroy(\"completely\" === o.destroy) : n ? (f(!0), r.mount()) : t !== o.direction && r.refresh();\n            }\n            function l(n, t, i) {\n                d(o, n), t && d(Object.getPrototypeOf(o), n), !i && u.is(1) || r.emit(K, o);\n            }\n            return {\n                setup: function() {\n                    var i = \"min\" === o.mediaQuery;\n                    E(t).sort(function(n, t) {\n                        return i ? +n - +t : +t - +n;\n                    }).forEach(function(n) {\n                        a(t[n], \"(\" + (i ? \"min\" : \"max\") + \"-width:\" + n + \"px)\");\n                    }), a(e, v), s();\n                },\n                destroy: f,\n                reduce: function(n) {\n                    matchMedia(v).matches && (n ? d(o, e) : sn(o, E(e)));\n                },\n                set: l\n            };\n        },\n        Direction: function(n, t, o) {\n            return {\n                resolve: function(n, t, i) {\n                    var r = \"rtl\" !== (i = i || o.direction) || t ? i === Jn ? 0 : -1 : 1;\n                    return l[n] && l[n][r] || n.replace(/width|left|right/i, function(n, t) {\n                        n = l[n.toLowerCase()][r] || n;\n                        return 0 < t ? n.charAt(0).toUpperCase() + n.slice(1) : n;\n                    });\n                },\n                orient: function(n) {\n                    return n * (\"rtl\" === o.direction ? 1 : -1);\n                }\n            };\n        },\n        Elements: function(n, t, i) {\n            var r, o, u, e = Q(n), c = e.on, f = e.bind, a = n.root, s = i.i18n, l = {}, d = [], v = [], h = [];\n            function p() {\n                r = y(\".\" + ct), o = fn(r, \".\" + ft), bn(r && o, \"A track/list element is missing.\"), k(d, S(o, \".\" + at + \":not(.\" + st + \")\")), w({\n                    arrows: dt,\n                    pagination: gt,\n                    prev: ht,\n                    next: pt,\n                    bar: yt,\n                    toggle: bt\n                }, function(n, t) {\n                    l[t] = y(\".\" + n);\n                }), an(l, {\n                    root: a,\n                    track: r,\n                    list: o,\n                    slides: d\n                });\n                var n = a.id || function(n) {\n                    return \"\" + n + An(_n[n] = (_n[n] || 0) + 1);\n                }(yn), t = i.role;\n                a.id = n, r.id = r.id || n + \"-track\", o.id = o.id || n + \"-list\", !z(a, Z) && \"SECTION\" !== a.tagName && t && I(a, Z, t), I(a, tt, s.carousel), I(o, Z, \"presentation\"), m();\n            }\n            function g(n) {\n                var t = ut.concat(\"style\");\n                D(d), X(a, v), X(r, h), P([\n                    r,\n                    o\n                ], t), P(a, n ? t : [\n                    \"style\",\n                    tt\n                ]);\n            }\n            function m() {\n                X(a, v), X(r, h), v = b(et), h = b(ct), M(a, v), M(r, h), I(a, nn, i.label), I(a, Zn, i.labelledby);\n            }\n            function y(n) {\n                n = pn(a, n);\n                return n && function(n, t) {\n                    if (x(n.closest)) return n.closest(t);\n                    for(var i = n; i && 1 === i.nodeType && !cn(i, t);)i = i.parentElement;\n                    return i;\n                }(n, \".\" + et) === a ? n : void 0;\n            }\n            function b(n) {\n                return [\n                    n + \"--\" + i.type,\n                    n + \"--\" + i.direction,\n                    i.drag && n + \"--draggable\",\n                    i.isNavigation && n + \"--nav\",\n                    n === et && tn\n                ];\n            }\n            return an(l, {\n                setup: p,\n                mount: function() {\n                    c(J, g), c(J, p), c(K, m), f(document, _t + \" keydown\", function(n) {\n                        u = \"keydown\" === n.type;\n                    }, {\n                        capture: !0\n                    }), f(a, \"focusin\", function() {\n                        A(a, Lt, !!u);\n                    });\n                },\n                destroy: g\n            });\n        },\n        Slides: function(r, o, u) {\n            var n = Q(r), t = n.on, e = n.emit, c = n.bind, f = (n = o.Elements).slides, a = n.list, s = [];\n            function i() {\n                f.forEach(function(n, t) {\n                    d(n, t, -1);\n                });\n            }\n            function l() {\n                h(function(n) {\n                    n.destroy();\n                }), D(s);\n            }\n            function d(n, t, i) {\n                t = Rt(r, t, i, n);\n                t.mount(), s.push(t), s.sort(function(n, t) {\n                    return n.index - t.index;\n                });\n            }\n            function v(n) {\n                return n ? p(function(n) {\n                    return !n.isClone;\n                }) : s;\n            }\n            function h(n, t) {\n                v(t).forEach(n);\n            }\n            function p(t) {\n                return s.filter(x(t) ? t : function(n) {\n                    return C(t) ? cn(n.slide, t) : b(y(t), n.index);\n                });\n            }\n            return {\n                mount: function() {\n                    i(), t(J, l), t(J, i);\n                },\n                destroy: l,\n                update: function() {\n                    h(function(n) {\n                        n.update();\n                    });\n                },\n                register: d,\n                get: v,\n                getIn: function(n) {\n                    var t = o.Controller, i = t.toIndex(n), r = t.hasFocus() ? 1 : u.perPage;\n                    return p(function(n) {\n                        return En(n.index, i, i + r - 1);\n                    });\n                },\n                getAt: function(n) {\n                    return p(n)[0];\n                },\n                add: function(n, o) {\n                    g(n, function(n) {\n                        var t, i, r;\n                        m(n = C(n) ? hn(n) : n) && ((t = f[o]) ? O(n, t) : L(a, n), M(n, u.classes.slide), t = n, i = R(e, jn), t = gn(t, \"img\"), (r = t.length) ? t.forEach(function(n) {\n                            c(n, \"load error\", function() {\n                                --r || i();\n                            });\n                        }) : i());\n                    }), e(J);\n                },\n                remove: function(n) {\n                    T(p(n).map(function(n) {\n                        return n.slide;\n                    })), e(J);\n                },\n                forEach: h,\n                filter: p,\n                style: function(t, i, r) {\n                    h(function(n) {\n                        n.style(t, i, r);\n                    });\n                },\n                getLength: function(n) {\n                    return (n ? f : s).length;\n                },\n                isEnough: function() {\n                    return s.length > u.perPage;\n                }\n            };\n        },\n        Layout: function(t, n, i) {\n            var r, o, u, e = (a = Q(t)).on, c = a.bind, f = a.emit, a = n.Slides, s = n.Direction.resolve, l = (n = n.Elements).root, d = n.track, v = n.list, h = a.getAt, p = a.style;\n            function g() {\n                r = i.direction === Jn, _(l, \"maxWidth\", W(i.width)), _(d, s(\"paddingLeft\"), y(!1)), _(d, s(\"paddingRight\"), y(!0)), m(!0);\n            }\n            function m(n) {\n                var t = N(l);\n                !n && o.width === t.width && o.height === t.height || (_(d, \"height\", function() {\n                    var n = \"\";\n                    r && (bn(n = b(), \"height or heightRatio is missing.\"), n = \"calc(\" + n + \" - \" + y(!1) + \" - \" + y(!0) + \")\");\n                    return n;\n                }()), p(s(\"marginRight\"), W(i.gap)), p(\"width\", i.autoWidth ? null : W(i.fixedWidth) || (r ? \"\" : w())), p(\"height\", W(i.fixedHeight) || (r ? i.autoHeight ? null : w() : b()), !0), o = t, f(Nn), u !== (u = O()) && (A(l, Ot, u), f(\"overflow\", u)));\n            }\n            function y(n) {\n                var t = i.padding, n = s(n ? \"right\" : \"left\");\n                return t && W(t[n] || (un(t) ? 0 : t)) || \"0px\";\n            }\n            function b() {\n                return W(i.height || N(v).width * i.heightRatio);\n            }\n            function w() {\n                var n = W(i.gap);\n                return \"calc((100%\" + (n && \" + \" + n) + \")/\" + (i.perPage || 1) + (n && \" - \" + n) + \")\";\n            }\n            function x() {\n                return N(v)[s(\"width\")];\n            }\n            function k(n, t) {\n                n = h(n || 0);\n                return n ? N(n.slide)[s(\"width\")] + (t ? 0 : L()) : 0;\n            }\n            function S(n, t) {\n                var i, n = h(n);\n                return n ? (n = N(n.slide)[s(\"right\")], i = N(v)[s(\"left\")], U(n - i) + (t ? 0 : L())) : 0;\n            }\n            function E(n) {\n                return S(t.length - 1) - S(0) + k(0, n);\n            }\n            function L() {\n                var n = h(0);\n                return n && parseFloat(_(n.slide, s(\"marginRight\"))) || 0;\n            }\n            function O() {\n                return t.is(It) || E(!0) > x();\n            }\n            return {\n                mount: function() {\n                    var n, t, i;\n                    g(), c(window, \"resize load\", (n = R(f, jn), i = qn(t || 0, n, null, 1), function() {\n                        i.isPaused() && i.start();\n                    })), e([\n                        K,\n                        J\n                    ], g), e(jn, m);\n                },\n                resize: m,\n                listSize: x,\n                slideSize: k,\n                sliderSize: E,\n                totalSize: S,\n                getPadding: function(n) {\n                    return parseFloat(_(d, s(\"padding\" + (n ? \"Right\" : \"Left\")))) || 0;\n                },\n                isOverflow: O\n            };\n        },\n        Clones: function(c, i, f) {\n            var t, r = Q(c), n = r.on, a = i.Elements, s = i.Slides, o = i.Direction.resolve, l = [];\n            function u() {\n                if (n(J, d), n([\n                    K,\n                    jn\n                ], v), t = h()) {\n                    var o = t, u = s.get().slice(), e = u.length;\n                    if (e) {\n                        for(; u.length < o;)k(u, u);\n                        k(u.slice(-o), u.slice(0, o)).forEach(function(n, t) {\n                            var i = t < o, r = function(n, t) {\n                                n = n.cloneNode(!0);\n                                return M(n, f.classes.clone), n.id = c.root.id + \"-clone\" + An(t + 1), n;\n                            }(n.slide, t);\n                            i ? O(r, u[0].slide) : L(a.list, r), k(l, r), s.register(r, t - o + (i ? 0 : e), n.index);\n                        });\n                    }\n                    i.Layout.resize(!0);\n                }\n            }\n            function d() {\n                e(), u();\n            }\n            function e() {\n                T(l), D(l), r.destroy();\n            }\n            function v() {\n                var n = h();\n                t !== n && (t < n || !n) && r.emit(J);\n            }\n            function h() {\n                var n, t = f.clones;\n                return c.is(Pt) ? en(t) && (t = (n = f[o(\"fixedWidth\")] && i.Layout.slideSize(0)) && kn(N(a.track)[o(\"width\")] / n) || f[o(\"autoWidth\")] && c.length || 2 * f.perPage) : t = 0, t;\n            }\n            return {\n                mount: u,\n                destroy: e\n            };\n        },\n        Move: function(r, c, o) {\n            var e, n = Q(r), t = n.on, f = n.emit, a = r.state.set, u = (n = c.Layout).slideSize, i = n.getPadding, s = n.totalSize, l = n.listSize, d = n.sliderSize, v = (n = c.Direction).resolve, h = n.orient, p = (n = c.Elements).list, g = n.track;\n            function m() {\n                c.Controller.isBusy() || (c.Scroll.cancel(), y(r.index), c.Slides.update());\n            }\n            function y(n) {\n                b(S(n, !0));\n            }\n            function b(n, t) {\n                r.is(It) || (t = t ? n : function(n) {\n                    var t, i;\n                    r.is(Pt) && (t = k(n), i = t > c.Controller.getEnd(), (t < 0 || i) && (n = w(n, i)));\n                    return n;\n                }(n), _(p, \"transform\", \"translate\" + v(\"X\") + \"(\" + t + \"px)\"), n !== t && f(Un));\n            }\n            function w(n, t) {\n                var i = n - L(t), r = d();\n                return n -= h(r * (kn(U(i) / r) || 1)) * (t ? 1 : -1);\n            }\n            function x() {\n                b(E(), !0), e.cancel();\n            }\n            function k(n) {\n                for(var t = c.Slides.get(), i = 0, r = 1 / 0, o = 0; o < t.length; o++){\n                    var u = t[o].index, e = U(S(u, !0) - n);\n                    if (!(e <= r)) break;\n                    r = e, i = u;\n                }\n                return i;\n            }\n            function S(n, t) {\n                var i = h(s(n - 1) - (n, \"center\" === (i = o.focus) ? (l() - u(n, !0)) / 2 : +i * u(n) || 0));\n                return t ? (n = i, n = o.trimSpace && r.is(Mt) ? q(n, 0, h(d(!0) - l())) : n) : i;\n            }\n            function E() {\n                var n = v(\"left\");\n                return N(p)[n] - N(g)[n] + h(i(!1));\n            }\n            function L(n) {\n                return S(n ? c.Controller.getEnd() : 0, !!o.trimSpace);\n            }\n            return {\n                mount: function() {\n                    e = c.Transition, t([\n                        B,\n                        Nn,\n                        K,\n                        J\n                    ], m);\n                },\n                move: function(n, t, i, r) {\n                    var o, u;\n                    n !== t && (o = i < n, u = h(w(E(), o)), o ? 0 <= u : u <= p[v(\"scrollWidth\")] - N(g)[v(\"width\")]) && (x(), b(w(E(), i < n), !0)), a(G), f(H, t, i, n), e.start(t, function() {\n                        a(3), f(Dn, t, i, n), r && r();\n                    });\n                },\n                jump: y,\n                translate: b,\n                shift: w,\n                cancel: x,\n                toIndex: k,\n                toPosition: S,\n                getPosition: E,\n                getLimit: L,\n                exceededLimit: function(n, t) {\n                    t = en(t) ? E() : t;\n                    var i = !0 !== n && h(t) < h(L(!1)), n = !1 !== n && h(t) > h(L(!0));\n                    return i || n;\n                },\n                reposition: m\n            };\n        },\n        Controller: function(o, u, e) {\n            var c, f, a, s, n = Q(o), t = n.on, i = n.emit, l = u.Move, d = l.getPosition, r = l.getLimit, v = l.toPosition, h = (n = u.Slides).isEnough, p = n.getLength, g = e.omitEnd, m = o.is(Pt), y = o.is(Mt), b = R(L, !1), w = R(L, !0), x = e.start || 0, k = x;\n            function S() {\n                f = p(!0), a = e.perMove, s = e.perPage, c = _();\n                var n = q(x, 0, g ? c : f - 1);\n                n !== x && (x = n, l.reposition());\n            }\n            function E() {\n                c !== _() && i(\"ei\");\n            }\n            function L(n, t) {\n                var i = a || (P() ? 1 : s), i = O(x + i * (n ? -1 : 1), x, !(a || P()));\n                return -1 === i && y && !Sn(d(), r(!n), 1) ? n ? 0 : c : t ? i : A(i);\n            }\n            function O(n, t, i) {\n                var r;\n                return h() || P() ? ((r = function(n) {\n                    if (y && \"move\" === e.trimSpace && n !== x) for(var t = d(); t === v(n, !0) && En(n, 0, o.length - 1, !e.rewind);)n < x ? --n : ++n;\n                    return n;\n                }(n)) !== n && (t = n, n = r, i = !1), n < 0 || c < n ? n = a || !En(0, n, t, !0) && !En(c, t, n, !0) ? m ? i ? n < 0 ? -(f % s || s) : f : n : e.rewind ? n < 0 ? c : 0 : -1 : z(D(n)) : i && n !== t && (n = z(D(t) + (n < t ? -1 : 1)))) : n = -1, n;\n            }\n            function A(n) {\n                return m ? (n + f) % f || 0 : n;\n            }\n            function _() {\n                for(var n = f - (P() || m && a ? 1 : s); g && 0 < n--;)if (v(f - 1, !0) !== v(n, !0)) {\n                    n++;\n                    break;\n                }\n                return q(n, 0, f - 1);\n            }\n            function z(n) {\n                return q(P() ? n : s * n, 0, c);\n            }\n            function D(n) {\n                return P() ? Y(n, c) : xn((c <= n ? f - 1 : n) / s);\n            }\n            function M(n) {\n                n !== x && (k = x, x = n);\n            }\n            function P() {\n                return !en(e.focus) || e.isNavigation;\n            }\n            function I() {\n                return o.state.is([\n                    G,\n                    rn\n                ]) && !!e.waitForTransition;\n            }\n            return {\n                mount: function() {\n                    S(), t([\n                        K,\n                        J,\n                        \"ei\"\n                    ], S), t(Nn, E);\n                },\n                go: function(n, t, i) {\n                    var r;\n                    I() || -1 < (r = A(n = function(n) {\n                        var t = x;\n                        var i, r;\n                        C(n) ? (r = n.match(/([+\\-<>])(\\d+)?/) || [], i = r[1], r = r[2], \"+\" === i || \"-\" === i ? t = O(x + +(\"\" + i + (+r || 1)), x) : \">\" === i ? t = r ? z(+r) : b(!0) : \"<\" === i && (t = w(!0))) : t = m ? n : q(n, 0, c);\n                        return t;\n                    }(n))) && (t || r !== x) && (M(r), l.move(n, r, k, i));\n                },\n                scroll: function(n, t, i, r) {\n                    u.Scroll.scroll(n, t, i, function() {\n                        var n = A(l.toIndex(d()));\n                        M(g ? Y(n, c) : n), r && r();\n                    });\n                },\n                getNext: b,\n                getPrev: w,\n                getAdjacent: L,\n                getEnd: _,\n                setIndex: M,\n                getIndex: function(n) {\n                    return n ? k : x;\n                },\n                toIndex: z,\n                toPage: D,\n                toDest: function(n) {\n                    return n = l.toIndex(n), y ? q(n, 0, c) : n;\n                },\n                hasFocus: P,\n                isBusy: I\n            };\n        },\n        Arrows: function(o, n, t) {\n            var i, r, u = Q(o), e = u.on, c = u.bind, f = u.emit, a = t.classes, s = t.i18n, l = n.Elements, d = n.Controller, v = l.arrows, h = l.track, p = v, g = l.prev, m = l.next, y = {};\n            function b() {\n                var n = t.arrows;\n                !n || g && m || (p = v || j(\"div\", a.arrows), g = S(!0), m = S(!1), i = !0, L(p, [\n                    g,\n                    m\n                ]), v || O(p, h)), g && m && (an(y, {\n                    prev: g,\n                    next: m\n                }), ln(p, n ? \"\" : \"none\"), M(p, r = dt + \"--\" + t.direction), n && (e([\n                    B,\n                    Dn,\n                    J,\n                    V,\n                    \"ei\"\n                ], E), c(m, \"click\", R(k, \">\")), c(g, \"click\", R(k, \"<\")), E(), I([\n                    g,\n                    m\n                ], Kn, h.id), f(\"arrows:mounted\", g, m))), e(K, w);\n            }\n            function w() {\n                x(), b();\n            }\n            function x() {\n                u.destroy(), X(p, r), i ? (T(v ? [\n                    g,\n                    m\n                ] : p), g = m = null) : P([\n                    g,\n                    m\n                ], ut);\n            }\n            function k(n) {\n                d.go(n, !0);\n            }\n            function S(n) {\n                return hn('<button class=\"' + a.arrow + \" \" + (n ? a.prev : a.next) + '\" type=\"button\"><svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 40 40\" width=\"40\" height=\"40\" focusable=\"false\"><path d=\"' + (t.arrowPath || \"m15.5 0.932-4.3 4.38 14.5 14.6-14.5 14.5 4.3 4.4 14.6-14.6 4.4-4.3-4.4-4.4-14.6-14.6z\") + '\" />');\n            }\n            function E() {\n                var n, t, i, r;\n                g && m && (r = o.index, n = d.getPrev(), t = d.getNext(), i = -1 < n && r < n ? s.last : s.prev, r = -1 < t && t < r ? s.first : s.next, g.disabled = n < 0, m.disabled = t < 0, I(g, nn, i), I(m, nn, r), f(\"arrows:updated\", g, m, n, t));\n            }\n            return {\n                arrows: y,\n                mount: b,\n                destroy: x,\n                update: E\n            };\n        },\n        Autoplay: function(n, t, i) {\n            var r, o, u = Q(n), e = u.on, c = u.bind, f = u.emit, a = qn(i.interval, n.go.bind(n, \">\"), function(n) {\n                var t = l.bar;\n                t && _(t, \"width\", 100 * n + \"%\"), f(\"autoplay:playing\", n);\n            }), s = a.isPaused, l = t.Elements, d = (u = t.Elements).root, v = u.toggle, h = i.autoplay, p = \"pause\" === h;\n            function g() {\n                s() && t.Slides.isEnough() && (a.start(!i.resetProgress), o = r = p = !1, b(), f(Fn));\n            }\n            function m(n) {\n                p = !!(n = void 0 === n ? !0 : n), b(), s() || (a.pause(), f(Xn));\n            }\n            function y() {\n                p || (r || o ? m(!1) : g());\n            }\n            function b() {\n                v && (A(v, tn, !p), I(v, nn, i.i18n[p ? \"play\" : \"pause\"]));\n            }\n            function w(n) {\n                n = t.Slides.getAt(n);\n                a.set(n && +z(n.slide, Ct) || i.interval);\n            }\n            return {\n                mount: function() {\n                    h && (i.pauseOnHover && c(d, \"mouseenter mouseleave\", function(n) {\n                        r = \"mouseenter\" === n.type, y();\n                    }), i.pauseOnFocus && c(d, \"focusin focusout\", function(n) {\n                        o = \"focusin\" === n.type, y();\n                    }), v && c(v, \"click\", function() {\n                        p ? g() : m(!0);\n                    }), e([\n                        H,\n                        Tn,\n                        J\n                    ], a.rewind), e(H, w), v && I(v, Kn, l.track.id), p || g(), b());\n                },\n                destroy: a.cancel,\n                play: g,\n                pause: m,\n                isPaused: s\n            };\n        },\n        Cover: function(n, t, i) {\n            var r = Q(n).on;\n            function o(i) {\n                t.Slides.forEach(function(n) {\n                    var t = fn(n.container || n.slide, \"img\");\n                    t && t.src && u(i, t, n);\n                });\n            }\n            function u(n, t, i) {\n                i.style(\"background\", n ? 'center/cover no-repeat url(\"' + t.src + '\")' : \"\", !0), ln(t, n ? \"none\" : \"\");\n            }\n            return {\n                mount: function() {\n                    i.cover && (r(Wn, R(u, !0)), r([\n                        B,\n                        K,\n                        J\n                    ], R(o, !0)));\n                },\n                destroy: R(o, !1)\n            };\n        },\n        Scroll: function(n, c, u) {\n            var f, a, t = Q(n), i = t.on, s = t.emit, l = n.state.set, d = c.Move, v = d.getPosition, e = d.getLimit, h = d.exceededLimit, p = d.translate, g = n.is(Mt), m = 1;\n            function y(n, t, i, r, o) {\n                var u, e = v(), i = (x(), !i || g && h() || (i = c.Layout.sliderSize(), u = Ln(n) * i * xn(U(n) / i) || 0, n = d.toPosition(c.Controller.toDest(n % i)) + u), Sn(e, n, 1));\n                m = 1, t = i ? 0 : t || wn(U(n - e) / 1.5, 800), a = r, f = qn(t, b, R(w, e, n, o), 1), l(rn), s(Tn), f.start();\n            }\n            function b() {\n                l(3), a && a(), s(V);\n            }\n            function w(n, t, i, r) {\n                var o = v(), r = (n + (t - n) * (t = r, (n = u.easingFunc) ? n(t) : 1 - Math.pow(1 - t, 4)) - o) * m;\n                p(o + r), g && !i && h() && (m *= .6, U(r) < 10 && y(e(h(!0)), 600, !1, a, !0));\n            }\n            function x() {\n                f && f.cancel();\n            }\n            function r() {\n                f && !f.isPaused() && (x(), b());\n            }\n            return {\n                mount: function() {\n                    i(H, x), i([\n                        K,\n                        J\n                    ], r);\n                },\n                destroy: x,\n                scroll: y,\n                cancel: r\n            };\n        },\n        Drag: function(e, o, c) {\n            var f, t, u, a, s, l, d, v, n = Q(e), i = n.on, h = n.emit, p = n.bind, g = n.unbind, m = e.state, y = o.Move, b = o.Scroll, w = o.Controller, x = o.Elements.track, k = o.Media.reduce, r = (n = o.Direction).resolve, S = n.orient, E = y.getPosition, L = y.exceededLimit, O = !1;\n            function j() {\n                var n = c.drag;\n                C(!n), a = \"free\" === n;\n            }\n            function N(n) {\n                var t, i, r;\n                l = !1, d || (t = R(n), i = n.target, r = c.noDrag, cn(i, \".\" + mt + \", .\" + vt) || r && cn(i, r) || !t && n.button || (w.isBusy() ? F(n, !0) : (v = t ? x : window, s = m.is([\n                    G,\n                    rn\n                ]), u = null, p(v, zt, A, jt), p(v, Dt, _, jt), y.cancel(), b.cancel(), z(n))));\n            }\n            function A(n) {\n                var t, i, r, o, u;\n                m.is(6) || (m.set(6), h(\"drag\")), n.cancelable && (s ? (y.translate(f + D(n) / (O && e.is(Mt) ? 5 : 1)), u = 200 < M(n), t = O !== (O = L()), (u || t) && z(n), l = !0, h(\"dragging\"), F(n)) : U(D(u = n)) > U(D(u, !0)) && (t = n, i = c.dragMinThreshold, r = un(i), o = r && i.mouse || 0, r = (r ? i.touch : +i) || 10, s = U(D(t)) > (R(t) ? r : o), F(n)));\n            }\n            function _(n) {\n                var t, i, r;\n                m.is(6) && (m.set(3), h(\"dragged\")), s && (i = function(n) {\n                    return E() + Ln(n) * Y(U(n) * (c.flickPower || 600), a ? 1 / 0 : o.Layout.listSize() * (c.flickMaxPages || 1));\n                }(t = function(n) {\n                    if (e.is(Pt) || !O) {\n                        var t = M(n);\n                        if (t && t < 200) return D(n) / t;\n                    }\n                    return 0;\n                }(t = n)), r = c.rewind && c.rewindByDrag, k(!1), a ? w.scroll(i, 0, c.snap) : e.is(It) ? w.go(S(Ln(t)) < 0 ? r ? \"<\" : \"-\" : r ? \">\" : \"+\") : e.is(Mt) && O && r ? w.go(L(!0) ? \">\" : \"<\") : w.go(w.toDest(i), !0), k(!0), F(n)), g(v, zt, A), g(v, Dt, _), s = !1;\n            }\n            function T(n) {\n                !d && l && F(n, !0);\n            }\n            function z(n) {\n                u = t, t = n, f = E();\n            }\n            function D(n, t) {\n                return I(n, t) - I(P(n), t);\n            }\n            function M(n) {\n                return mn(n) - mn(P(n));\n            }\n            function P(n) {\n                return t === n && u || t;\n            }\n            function I(n, t) {\n                return (R(n) ? n.changedTouches[0] : n)[\"page\" + r(t ? \"Y\" : \"X\")];\n            }\n            function R(n) {\n                return \"undefined\" != typeof TouchEvent && n instanceof TouchEvent;\n            }\n            function C(n) {\n                d = n;\n            }\n            return {\n                mount: function() {\n                    p(x, zt, on, jt), p(x, Dt, on, jt), p(x, _t, N, jt), p(x, \"click\", T, {\n                        capture: !0\n                    }), p(x, \"dragstart\", F), i([\n                        B,\n                        K\n                    ], j);\n                },\n                disable: C,\n                isDragging: function() {\n                    return s;\n                }\n            };\n        },\n        Keyboard: function(t, n, i) {\n            var r, o, u = Q(t), e = u.on, c = u.bind, f = u.unbind, a = t.root, s = n.Direction.resolve;\n            function l() {\n                var n = i.keyboard;\n                n && (r = \"global\" === n ? window : a, c(r, Gt, h));\n            }\n            function d() {\n                f(r, Gt);\n            }\n            function v() {\n                var n = o;\n                o = !0, p(function() {\n                    o = n;\n                });\n            }\n            function h(n) {\n                o || ((n = Tt(n)) === s(Bn) ? t.go(\"<\") : n === s(Hn) && t.go(\">\"));\n            }\n            return {\n                mount: function() {\n                    l(), e(K, d), e(K, l), e(H, v);\n                },\n                destroy: d,\n                disable: function(n) {\n                    o = n;\n                }\n            };\n        },\n        LazyLoad: function(i, n, o) {\n            var t = Q(i), r = t.on, u = t.off, e = t.bind, c = t.emit, f = \"sequential\" === o.lazyLoad, a = [\n                Dn,\n                V\n            ], s = [];\n            function l() {\n                D(s), n.Slides.forEach(function(r) {\n                    gn(r.slide, Wt).forEach(function(n) {\n                        var t = z(n, Ft), i = z(n, Xt);\n                        t === n.src && i === n.srcset || (t = o.classes.spinner, t = fn(i = n.parentElement, \".\" + t) || j(\"span\", t, i), s.push([\n                            n,\n                            r,\n                            t\n                        ]), n.src || ln(n, \"none\"));\n                    });\n                }), (f ? p : (u(a), r(a, d), d))();\n            }\n            function d() {\n                (s = s.filter(function(n) {\n                    var t = o.perPage * ((o.preloadPages || 1) + 1) - 1;\n                    return !n[1].isWithin(i.index, t) || v(n);\n                })).length || u(a);\n            }\n            function v(n) {\n                var t = n[0];\n                M(n[1].slide, Et), e(t, \"load error\", R(h, n)), I(t, \"src\", z(t, Ft)), I(t, \"srcset\", z(t, Xt)), P(t, Ft), P(t, Xt);\n            }\n            function h(n, t) {\n                var i = n[0], r = n[1];\n                X(r.slide, Et), \"error\" !== t.type && (T(n[2]), ln(i, \"\"), c(Wn, i, r), c(jn)), f && p();\n            }\n            function p() {\n                s.length && v(s.shift());\n            }\n            return {\n                mount: function() {\n                    o.lazyLoad && (l(), r(J, l));\n                },\n                destroy: R(D, s),\n                check: d\n            };\n        },\n        Pagination: function(l, n, d) {\n            var v, h, t = Q(l), p = t.on, g = t.emit, m = t.bind, y = n.Slides, b = n.Elements, w = n.Controller, x = w.hasFocus, r = w.getIndex, e = w.go, c = n.Direction.resolve, k = b.pagination, S = [];\n            function E() {\n                v && (T(k ? o(v.children) : v), X(v, h), D(S), v = null), t.destroy();\n            }\n            function L(n) {\n                e(\">\" + n, !0);\n            }\n            function O(n, t) {\n                var i = S.length, r = Tt(t), o = A(), u = -1, o = (r === c(Hn, !1, o) ? u = ++n % i : r === c(Bn, !1, o) ? u = (--n + i) % i : \"Home\" === r ? u = 0 : \"End\" === r && (u = i - 1), S[u]);\n                o && (dn(o.button), e(\">\" + u), F(t, !0));\n            }\n            function A() {\n                return d.paginationDirection || d.direction;\n            }\n            function _(n) {\n                return S[w.toPage(n)];\n            }\n            function z() {\n                var n, t = _(r(!0)), i = _(r());\n                t && (X(n = t.button, tn), P(n, Qn), I(n, $, -1)), i && (M(n = i.button, tn), I(n, Qn, !0), I(n, $, \"\")), g(\"pagination:updated\", {\n                    list: v,\n                    items: S\n                }, t, i);\n            }\n            return {\n                items: S,\n                mount: function n() {\n                    E(), p([\n                        K,\n                        J,\n                        \"ei\"\n                    ], n);\n                    var t = d.pagination;\n                    if (k && ln(k, t ? \"\" : \"none\"), t) {\n                        p([\n                            H,\n                            Tn,\n                            V\n                        ], z);\n                        var t = l.length, i = d.classes, r = d.i18n, o = d.perPage, u = x() ? w.getEnd() + 1 : kn(t / o);\n                        M(v = k || j(\"ul\", i.pagination, b.track.parentElement), h = gt + \"--\" + A()), I(v, Z, \"tablist\"), I(v, nn, r.select), I(v, nt, A() === Jn ? \"vertical\" : \"\");\n                        for(var e = 0; e < u; e++){\n                            var c = j(\"li\", null, v), f = j(\"button\", {\n                                class: i.page,\n                                type: \"button\"\n                            }, c), a = y.getIn(e).map(function(n) {\n                                return n.slide.id;\n                            }), s = !x() && 1 < o ? r.pageX : r.slideX;\n                            m(f, \"click\", R(L, e)), d.paginationKeyboard && m(f, \"keydown\", R(O, e)), I(c, Z, \"presentation\"), I(f, Z, \"tab\"), I(f, Kn, a.join(\" \")), I(f, nn, On(s, e + 1)), I(f, $, -1), S.push({\n                                li: c,\n                                button: f,\n                                page: e\n                            });\n                        }\n                        z(), g(\"pagination:mounted\", {\n                            list: v,\n                            items: S\n                        }, _(l.index));\n                    }\n                },\n                destroy: E,\n                getAt: _,\n                update: z\n            };\n        },\n        Sync: function(i, n, t) {\n            var r = t.isNavigation, o = t.slideFocus, u = [];\n            function e() {\n                var n, t;\n                i.splides.forEach(function(n) {\n                    n.isParent || (f(i, n.splide), f(n.splide, i));\n                }), r && (n = Q(i), (t = n.on)(Mn, s), t(Yn, l), t([\n                    B,\n                    K\n                ], a), u.push(n), n.emit(Gn, i.splides));\n            }\n            function c() {\n                u.forEach(function(n) {\n                    n.destroy();\n                }), D(u);\n            }\n            function f(n, r) {\n                n = Q(n);\n                n.on(H, function(n, t, i) {\n                    r.go(r.is(Pt) ? i : n);\n                }), u.push(n);\n            }\n            function a() {\n                I(n.Elements.list, nt, t.direction === Jn ? \"vertical\" : \"\");\n            }\n            function s(n) {\n                i.go(n.index);\n            }\n            function l(n, t) {\n                b(Yt, Tt(t)) && (s(n), F(t));\n            }\n            return {\n                setup: R(n.Media.set, {\n                    slideFocus: en(o) ? r : o\n                }, !0),\n                mount: e,\n                destroy: c,\n                remount: function() {\n                    c(), e();\n                }\n            };\n        },\n        Wheel: function(e, c, f) {\n            var n = Q(e).bind, a = 0;\n            function t(n) {\n                var t, i, r, o, u;\n                n.cancelable && (t = (u = n.deltaY) < 0, i = mn(n), r = f.wheelMinThreshold || 0, o = f.wheelSleep || 0, U(u) > r && o < i - a && (e.go(t ? \"<\" : \">\"), a = i), u = t, f.releaseWheel && !e.state.is(G) && -1 === c.Controller.getAdjacent(u) || F(n));\n            }\n            return {\n                mount: function() {\n                    f.wheel && n(c.Elements.track, \"wheel\", t, jt);\n                }\n            };\n        },\n        Live: function(n, t, i) {\n            var r = Q(n).on, o = t.Elements.track, u = i.live && !i.isNavigation, e = j(\"span\", wt), c = qn(90, R(f, !1));\n            function f(n) {\n                I(o, rt, n), n ? (L(o, e), c.start()) : (T(e), c.cancel());\n            }\n            function a(n) {\n                u && I(o, it, n ? \"off\" : \"polite\");\n            }\n            return {\n                mount: function() {\n                    u && (a(!t.Autoplay.isPaused()), I(o, ot, !0), e.textContent = \"\\u2026\", r(Fn, R(a, !0)), r(Xn, R(a, !1)), r([\n                        Dn,\n                        V\n                    ], R(f, !0)));\n                },\n                disable: a,\n                destroy: function() {\n                    P(o, [\n                        it,\n                        ot,\n                        rt\n                    ]), T(e);\n                }\n            };\n        }\n    }), qt = {\n        type: \"slide\",\n        role: \"region\",\n        speed: 400,\n        perPage: 1,\n        cloneStatus: !0,\n        arrows: !0,\n        pagination: !0,\n        paginationKeyboard: !0,\n        interval: 5e3,\n        pauseOnHover: !0,\n        pauseOnFocus: !0,\n        resetProgress: !0,\n        easing: \"cubic-bezier(0.25, 1, 0.5, 1)\",\n        drag: !0,\n        direction: \"ltr\",\n        trimSpace: !0,\n        focusableNodes: \"a, button, textarea, input, select, iframe\",\n        live: !0,\n        classes: {\n            slide: at,\n            clone: st,\n            arrows: dt,\n            arrow: vt,\n            prev: ht,\n            next: pt,\n            pagination: gt,\n            page: mt,\n            spinner: i + \"spinner\"\n        },\n        i18n: {\n            prev: \"Previous slide\",\n            next: \"Next slide\",\n            first: \"Go to first slide\",\n            last: \"Go to last slide\",\n            slideX: \"Go to slide %s\",\n            pageX: \"Go to page %s\",\n            play: \"Start autoplay\",\n            pause: \"Pause autoplay\",\n            carousel: \"carousel\",\n            slide: \"slide\",\n            select: \"Select a slide to show\",\n            slideLabel: \"%s of %s\"\n        },\n        reducedMotion: {\n            speed: 0,\n            rewindSpeed: 0,\n            autoplay: \"pause\"\n        }\n    };\n    function Bt(n, t, i) {\n        var r = t.Slides;\n        function o() {\n            r.forEach(function(n) {\n                n.style(\"transform\", \"translateX(-\" + 100 * n.index + \"%)\");\n            });\n        }\n        return {\n            mount: function() {\n                Q(n).on([\n                    B,\n                    J\n                ], o);\n            },\n            start: function(n, t) {\n                r.style(\"transition\", \"opacity \" + i.speed + \"ms \" + i.easing), p(t);\n            },\n            cancel: on\n        };\n    }\n    function Ht(u, n, e) {\n        var c, f = n.Move, a = n.Controller, s = n.Scroll, t = n.Elements.list, l = R(_, t, \"transition\");\n        function i() {\n            l(\"\"), s.cancel();\n        }\n        return {\n            mount: function() {\n                Q(u).bind(t, \"transitionend\", function(n) {\n                    n.target === t && c && (i(), c());\n                });\n            },\n            start: function(n, t) {\n                var i = f.toPosition(n, !0), r = f.getPosition(), o = function(n) {\n                    var t = e.rewindSpeed;\n                    if (u.is(Mt) && t) {\n                        var i = a.getIndex(!0), r = a.getEnd();\n                        if (0 === i && r <= n || r <= i && 0 === n) return t;\n                    }\n                    return e.speed;\n                }(n);\n                1 <= U(i - r) && 1 <= o ? e.useScroll ? s.scroll(i, o, !1, t) : (l(\"transform \" + o + \"ms \" + e.easing), f.translate(i, !0), c = t) : (f.jump(n), t());\n            },\n            cancel: i\n        };\n    }\n    t = function() {\n        function i(n, t) {\n            this.event = Q(), this.Components = {}, this.state = s(1), this.splides = [], this.n = {}, this.t = {};\n            n = C(n) ? pn(document, n) : n;\n            bn(n, n + \" is invalid.\"), t = d({\n                label: z(this.root = n, nn) || \"\",\n                labelledby: z(n, Zn) || \"\"\n            }, qt, i.defaults, t || {});\n            try {\n                d(t, JSON.parse(z(n, f)));\n            } catch (n) {\n                bn(!1, \"Invalid JSON\");\n            }\n            this.n = Object.create(d({}, t));\n        }\n        var n = i.prototype;\n        return n.mount = function(n, t) {\n            var i = this, r = this.state, o = this.Components;\n            return bn(r.is([\n                1,\n                7\n            ]), \"Already mounted!\"), r.set(1), this.i = o, this.r = t || this.r || (this.is(It) ? Bt : Ht), this.t = n || this.t, w(an({}, Ut, this.t, {\n                Transition: this.r\n            }), function(n, t) {\n                n = n(i, o, i.n);\n                (o[t] = n).setup && n.setup();\n            }), w(o, function(n) {\n                n.mount && n.mount();\n            }), this.emit(B), M(this.root, \"is-initialized\"), r.set(3), this.emit(\"ready\"), this;\n        }, n.sync = function(n) {\n            return this.splides.push({\n                splide: n\n            }), n.splides.push({\n                splide: this,\n                isParent: !0\n            }), this.state.is(3) && (this.i.Sync.remount(), n.Components.Sync.remount()), this;\n        }, n.go = function(n) {\n            return this.i.Controller.go(n), this;\n        }, n.on = function(n, t) {\n            return this.event.on(n, t), this;\n        }, n.off = function(n) {\n            return this.event.off(n), this;\n        }, n.emit = function(n) {\n            var t;\n            return (t = this.event).emit.apply(t, [\n                n\n            ].concat(o(arguments, 1))), this;\n        }, n.add = function(n, t) {\n            return this.i.Slides.add(n, t), this;\n        }, n.remove = function(n) {\n            return this.i.Slides.remove(n), this;\n        }, n.is = function(n) {\n            return this.n.type === n;\n        }, n.refresh = function() {\n            return this.emit(J), this;\n        }, n.destroy = function(t) {\n            void 0 === t && (t = !0);\n            var n = this.event, i = this.state;\n            return i.is(1) ? Q(this).on(\"ready\", this.destroy.bind(this, t)) : (w(this.i, function(n) {\n                n.destroy && n.destroy(t);\n            }, !0), n.emit(a), n.destroy(), t && D(this.splides), i.set(7)), this;\n        }, Jt(i, [\n            {\n                key: \"options\",\n                get: function() {\n                    return this.n;\n                },\n                set: function(n) {\n                    this.i.Media.set(n, !0, !0);\n                }\n            },\n            {\n                key: \"length\",\n                get: function() {\n                    return this.i.Slides.getLength(!0);\n                }\n            },\n            {\n                key: \"index\",\n                get: function() {\n                    return this.i.Controller.getIndex();\n                }\n            }\n        ]), i;\n    }();\n    return t.defaults = {}, t.STATES = r, t;\n}, \"object\" == typeof exports && \"undefined\" != typeof module ? module.exports = t() : \"function\" == typeof define && define.amd ? define(t) : (n = \"undefined\" != typeof globalThis ? globalThis : n || self).Splide = t();\n\n//# sourceMappingURL=medisapp.github.io.d5fc1d12.js.map\n","function r(n,t){for(var i=0;i<t.length;i++){var r=t[i];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}function Jt(n,t,i){t&&r(n.prototype,t),i&&r(n,i),Object.defineProperty(n,\"prototype\",{writable:!1})}\n/*!\n * Splide.js\n * Version  : 4.1.4\n * License  : MIT\n * Copyright: 2022 Naotoshi Fujita\n */\nvar n,t;n=this,t=function(){\"use strict\";var v=\"(prefers-reduced-motion: reduce)\",G=4,rn=5,r={CREATED:1,MOUNTED:2,IDLE:3,MOVING:G,SCROLLING:rn,DRAGGING:6,DESTROYED:7};function D(n){n.length=0}function o(n,t,i){return Array.prototype.slice.call(n,t,i)}function R(n){return n.bind.apply(n,[null].concat(o(arguments,1)))}function on(){}var p=setTimeout;function h(n){return requestAnimationFrame(n)}function u(n,t){return typeof t===n}function un(n){return!c(n)&&u(\"object\",n)}var e=Array.isArray,x=R(u,\"function\"),C=R(u,\"string\"),en=R(u,\"undefined\");function c(n){return null===n}function m(n){try{return n instanceof(n.ownerDocument.defaultView||window).HTMLElement}catch(n){return!1}}function y(n){return e(n)?n:[n]}function g(n,t){y(n).forEach(t)}function b(n,t){return-1<n.indexOf(t)}function k(n,t){return n.push.apply(n,y(t)),n}function A(t,n,i){t&&g(n,function(n){n&&t.classList[i?\"add\":\"remove\"](n)})}function M(n,t){A(n,C(t)?t.split(\" \"):t,!0)}function L(n,t){g(t,n.appendChild.bind(n))}function O(n,i){g(n,function(n){var t=(i||n).parentNode;t&&t.insertBefore(n,i)})}function cn(n,t){return m(n)&&(n.msMatchesSelector||n.matches).call(n,t)}function S(n,t){n=n?o(n.children):[];return t?n.filter(function(n){return cn(n,t)}):n}function fn(n,t){return t?S(n,t)[0]:n.firstElementChild}var E=Object.keys;function w(t,i,n){t&&(n?E(t).reverse():E(t)).forEach(function(n){\"__proto__\"!==n&&i(t[n],n)})}function an(r){return o(arguments,1).forEach(function(i){w(i,function(n,t){r[t]=i[t]})}),r}function d(i){return o(arguments,1).forEach(function(n){w(n,function(n,t){e(n)?i[t]=n.slice():un(n)?i[t]=d({},un(i[t])?i[t]:{},n):i[t]=n})}),i}function sn(t,n){g(n||E(t),function(n){delete t[n]})}function P(n,i){g(n,function(t){g(i,function(n){t&&t.removeAttribute(n)})})}function I(i,t,r){un(t)?w(t,function(n,t){I(i,t,n)}):g(i,function(n){c(r)||\"\"===r?P(n,t):n.setAttribute(t,String(r))})}function j(n,t,i){n=document.createElement(n);return t&&(C(t)?M:I)(n,t),i&&L(i,n),n}function _(n,t,i){if(en(i))return getComputedStyle(n)[t];c(i)||(n.style[t]=\"\"+i)}function ln(n,t){_(n,\"display\",t)}function dn(n){n.setActive&&n.setActive()||n.focus({preventScroll:!0})}function z(n,t){return n.getAttribute(t)}function vn(n,t){return n&&n.classList.contains(t)}function N(n){return n.getBoundingClientRect()}function T(n){g(n,function(n){n&&n.parentNode&&n.parentNode.removeChild(n)})}function hn(n){return fn((new DOMParser).parseFromString(n,\"text/html\").body)}function F(n,t){n.preventDefault(),t&&(n.stopPropagation(),n.stopImmediatePropagation())}function pn(n,t){return n&&n.querySelector(t)}function gn(n,t){return t?o(n.querySelectorAll(t)):[]}function X(n,t){A(n,t,!1)}function mn(n){return n.timeStamp}function W(n){return C(n)?n:n?n+\"px\":\"\"}var yn=\"splide\",f=\"data-\"+yn;function bn(n,t){if(!n)throw new Error(\"[\"+yn+\"] \"+(t||\"\"))}var Y=Math.min,wn=Math.max,xn=Math.floor,kn=Math.ceil,U=Math.abs;function Sn(n,t,i){return U(n-t)<i}function En(n,t,i,r){var o=Y(t,i),t=wn(t,i);return r?o<n&&n<t:o<=n&&n<=t}function q(n,t,i){var r=Y(t,i),t=wn(t,i);return Y(wn(r,n),t)}function Ln(n){return(0<n)-(n<0)}function On(t,n){return g(n,function(n){t=t.replace(\"%s\",\"\"+n)}),t}function An(n){return n<10?\"0\"+n:\"\"+n}var _n={};function zn(){var c=[];function i(n,i,r){g(n,function(t){t&&g(i,function(n){n.split(\" \").forEach(function(n){n=n.split(\".\");r(t,n[0],n[1])})})})}return{bind:function(n,t,u,e){i(n,t,function(n,t,i){var r=\"addEventListener\"in n,o=r?n.removeEventListener.bind(n,t,u,e):n.removeListener.bind(n,u);r?n.addEventListener(t,u,e):n.addListener(u),c.push([n,t,i,u,o])})},unbind:function(n,t,o){i(n,t,function(t,i,r){c=c.filter(function(n){return!!(n[0]!==t||n[1]!==i||n[2]!==r||o&&n[3]!==o)||(n[4](),!1)})})},dispatch:function(n,t,i){var r;return\"function\"==typeof CustomEvent?r=new CustomEvent(t,{bubbles:!0,detail:i}):(r=document.createEvent(\"CustomEvent\")).initCustomEvent(t,!0,!1,i),n.dispatchEvent(r),r},destroy:function(){c.forEach(function(n){n[4]()}),D(c)}}}var B=\"mounted\",H=\"move\",Dn=\"moved\",Mn=\"click\",Pn=\"active\",In=\"inactive\",Rn=\"visible\",Cn=\"hidden\",J=\"refresh\",K=\"updated\",jn=\"resize\",Nn=\"resized\",Tn=\"scroll\",V=\"scrolled\",a=\"destroy\",Gn=\"navigation:mounted\",Fn=\"autoplay:play\",Xn=\"autoplay:pause\",Wn=\"lazyload:loaded\",Yn=\"sk\",Un=\"sh\";function Q(n){var i=n?n.event.bus:document.createDocumentFragment(),r=zn();return n&&n.event.on(a,r.destroy),an(r,{bus:i,on:function(n,t){r.bind(i,y(n).join(\" \"),function(n){t.apply(t,e(n.detail)?n.detail:[])})},off:R(r.unbind,i),emit:function(n){r.dispatch(i,n,o(arguments,1))}})}function qn(t,n,i,r){var o,u,e=Date.now,c=0,f=!0,a=0;function s(){if(!f){if(c=t?Y((e()-o)/t,1):1,i&&i(c),1<=c&&(n(),o=e(),r&&++a>=r))return l();u=h(s)}}function l(){f=!0}function d(){u&&cancelAnimationFrame(u),f=!(u=c=0)}return{start:function(n){n||d(),o=e()-(n?c*t:0),f=!1,u=h(s)},rewind:function(){o=e(),c=0,i&&i(c)},pause:l,cancel:d,set:function(n){t=n},isPaused:function(){return f}}}function s(n){var t=n;return{set:function(n){t=n},is:function(n){return b(y(n),t)}}}var n=\"Arrow\",Bn=n+\"Left\",Hn=n+\"Right\",t=n+\"Up\",n=n+\"Down\",Jn=\"ttb\",l={width:[\"height\"],left:[\"top\",\"right\"],right:[\"bottom\",\"left\"],x:[\"y\"],X:[\"Y\"],Y:[\"X\"],ArrowLeft:[t,Hn],ArrowRight:[n,Bn]};var Z=\"role\",$=\"tabindex\",i=\"aria-\",Kn=i+\"controls\",Vn=i+\"current\",Qn=i+\"selected\",nn=i+\"label\",Zn=i+\"labelledby\",$n=i+\"hidden\",nt=i+\"orientation\",tt=i+\"roledescription\",it=i+\"live\",rt=i+\"busy\",ot=i+\"atomic\",ut=[Z,$,\"disabled\",Kn,Vn,nn,Zn,$n,nt,tt],i=yn+\"__\",et=yn,ct=i+\"track\",ft=i+\"list\",at=i+\"slide\",st=at+\"--clone\",lt=at+\"__container\",dt=i+\"arrows\",vt=i+\"arrow\",ht=vt+\"--prev\",pt=vt+\"--next\",gt=i+\"pagination\",mt=gt+\"__page\",yt=i+\"progress\"+\"__bar\",bt=i+\"toggle\",wt=i+\"sr\",tn=\"is-active\",xt=\"is-prev\",kt=\"is-next\",St=\"is-visible\",Et=\"is-loading\",Lt=\"is-focus-in\",Ot=\"is-overflow\",At=[tn,St,xt,kt,Et,Lt,Ot];var _t=\"touchstart mousedown\",zt=\"touchmove mousemove\",Dt=\"touchend touchcancel mouseup click\";var Mt=\"slide\",Pt=\"loop\",It=\"fade\";function Rt(o,r,t,u){var e,n=Q(o),i=n.on,c=n.emit,f=n.bind,a=o.Components,s=o.root,l=o.options,d=l.isNavigation,v=l.updateOnMove,h=l.i18n,p=l.pagination,g=l.slideFocus,m=a.Direction.resolve,y=z(u,\"style\"),b=z(u,nn),w=-1<t,x=fn(u,\".\"+lt);function k(){var n=o.splides.map(function(n){n=n.splide.Components.Slides.getAt(r);return n?n.slide.id:\"\"}).join(\" \");I(u,nn,On(h.slideX,(w?t:r)+1)),I(u,Kn,n),I(u,Z,g?\"button\":\"\"),g&&P(u,tt)}function S(){e||E()}function E(){var n,t,i;e||(n=o.index,(i=L())!==vn(u,tn)&&(A(u,tn,i),I(u,Vn,d&&i||\"\"),c(i?Pn:In,O)),i=function(){if(o.is(It))return L();var n=N(a.Elements.track),t=N(u),i=m(\"left\",!0),r=m(\"right\",!0);return xn(n[i])<=kn(t[i])&&xn(t[r])<=kn(n[r])}(),t=!i&&(!L()||w),o.state.is([G,rn])||I(u,$n,t||\"\"),I(gn(u,l.focusableNodes||\"\"),$,t?-1:\"\"),g&&I(u,$,t?-1:0),i!==vn(u,St)&&(A(u,St,i),c(i?Rn:Cn,O)),i||document.activeElement!==u||(t=a.Slides.getAt(o.index))&&dn(t.slide),A(u,xt,r===n-1),A(u,kt,r===n+1))}function L(){var n=o.index;return n===r||l.cloneStatus&&n===t}var O={index:r,slideIndex:t,slide:u,container:x,isClone:w,mount:function(){w||(u.id=s.id+\"-slide\"+An(r+1),I(u,Z,p?\"tabpanel\":\"group\"),I(u,tt,h.slide),I(u,nn,b||On(h.slideLabel,[r+1,o.length]))),f(u,\"click\",R(c,Mn,O)),f(u,\"keydown\",R(c,Yn,O)),i([Dn,Un,V],E),i(Gn,k),v&&i(H,S)},destroy:function(){e=!0,n.destroy(),X(u,At),P(u,ut),I(u,\"style\",y),I(u,nn,b||\"\")},update:E,style:function(n,t,i){_(i&&x||u,n,t)},isWithin:function(n,t){return n=U(n-r),(n=w||!l.rewind&&!o.is(Pt)?n:Y(n,o.length-n))<=t}};return O}var Ct=f+\"-interval\";var jt={passive:!1,capture:!0};var Nt={Spacebar:\" \",Right:Hn,Left:Bn,Up:t,Down:n};function Tt(n){return n=C(n)?n:n.key,Nt[n]||n}var Gt=\"keydown\";var Ft=f+\"-lazy\",Xt=Ft+\"-srcset\",Wt=\"[\"+Ft+\"], [\"+Xt+\"]\";var Yt=[\" \",\"Enter\"];var Ut=Object.freeze({__proto__:null,Media:function(r,n,o){var u=r.state,t=o.breakpoints||{},e=o.reducedMotion||{},i=zn(),c=[];function f(n){n&&i.destroy()}function a(n,t){t=matchMedia(t);i.bind(t,\"change\",s),c.push([n,t])}function s(){var n=u.is(7),t=o.direction,i=c.reduce(function(n,t){return d(n,t[1].matches?t[0]:{})},{});sn(o),l(i),o.destroy?r.destroy(\"completely\"===o.destroy):n?(f(!0),r.mount()):t!==o.direction&&r.refresh()}function l(n,t,i){d(o,n),t&&d(Object.getPrototypeOf(o),n),!i&&u.is(1)||r.emit(K,o)}return{setup:function(){var i=\"min\"===o.mediaQuery;E(t).sort(function(n,t){return i?+n-+t:+t-+n}).forEach(function(n){a(t[n],\"(\"+(i?\"min\":\"max\")+\"-width:\"+n+\"px)\")}),a(e,v),s()},destroy:f,reduce:function(n){matchMedia(v).matches&&(n?d(o,e):sn(o,E(e)))},set:l}},Direction:function(n,t,o){return{resolve:function(n,t,i){var r=\"rtl\"!==(i=i||o.direction)||t?i===Jn?0:-1:1;return l[n]&&l[n][r]||n.replace(/width|left|right/i,function(n,t){n=l[n.toLowerCase()][r]||n;return 0<t?n.charAt(0).toUpperCase()+n.slice(1):n})},orient:function(n){return n*(\"rtl\"===o.direction?1:-1)}}},Elements:function(n,t,i){var r,o,u,e=Q(n),c=e.on,f=e.bind,a=n.root,s=i.i18n,l={},d=[],v=[],h=[];function p(){r=y(\".\"+ct),o=fn(r,\".\"+ft),bn(r&&o,\"A track/list element is missing.\"),k(d,S(o,\".\"+at+\":not(.\"+st+\")\")),w({arrows:dt,pagination:gt,prev:ht,next:pt,bar:yt,toggle:bt},function(n,t){l[t]=y(\".\"+n)}),an(l,{root:a,track:r,list:o,slides:d});var n=a.id||function(n){return\"\"+n+An(_n[n]=(_n[n]||0)+1)}(yn),t=i.role;a.id=n,r.id=r.id||n+\"-track\",o.id=o.id||n+\"-list\",!z(a,Z)&&\"SECTION\"!==a.tagName&&t&&I(a,Z,t),I(a,tt,s.carousel),I(o,Z,\"presentation\"),m()}function g(n){var t=ut.concat(\"style\");D(d),X(a,v),X(r,h),P([r,o],t),P(a,n?t:[\"style\",tt])}function m(){X(a,v),X(r,h),v=b(et),h=b(ct),M(a,v),M(r,h),I(a,nn,i.label),I(a,Zn,i.labelledby)}function y(n){n=pn(a,n);return n&&function(n,t){if(x(n.closest))return n.closest(t);for(var i=n;i&&1===i.nodeType&&!cn(i,t);)i=i.parentElement;return i}(n,\".\"+et)===a?n:void 0}function b(n){return[n+\"--\"+i.type,n+\"--\"+i.direction,i.drag&&n+\"--draggable\",i.isNavigation&&n+\"--nav\",n===et&&tn]}return an(l,{setup:p,mount:function(){c(J,g),c(J,p),c(K,m),f(document,_t+\" keydown\",function(n){u=\"keydown\"===n.type},{capture:!0}),f(a,\"focusin\",function(){A(a,Lt,!!u)})},destroy:g})},Slides:function(r,o,u){var n=Q(r),t=n.on,e=n.emit,c=n.bind,f=(n=o.Elements).slides,a=n.list,s=[];function i(){f.forEach(function(n,t){d(n,t,-1)})}function l(){h(function(n){n.destroy()}),D(s)}function d(n,t,i){t=Rt(r,t,i,n);t.mount(),s.push(t),s.sort(function(n,t){return n.index-t.index})}function v(n){return n?p(function(n){return!n.isClone}):s}function h(n,t){v(t).forEach(n)}function p(t){return s.filter(x(t)?t:function(n){return C(t)?cn(n.slide,t):b(y(t),n.index)})}return{mount:function(){i(),t(J,l),t(J,i)},destroy:l,update:function(){h(function(n){n.update()})},register:d,get:v,getIn:function(n){var t=o.Controller,i=t.toIndex(n),r=t.hasFocus()?1:u.perPage;return p(function(n){return En(n.index,i,i+r-1)})},getAt:function(n){return p(n)[0]},add:function(n,o){g(n,function(n){var t,i,r;m(n=C(n)?hn(n):n)&&((t=f[o])?O(n,t):L(a,n),M(n,u.classes.slide),t=n,i=R(e,jn),t=gn(t,\"img\"),(r=t.length)?t.forEach(function(n){c(n,\"load error\",function(){--r||i()})}):i())}),e(J)},remove:function(n){T(p(n).map(function(n){return n.slide})),e(J)},forEach:h,filter:p,style:function(t,i,r){h(function(n){n.style(t,i,r)})},getLength:function(n){return(n?f:s).length},isEnough:function(){return s.length>u.perPage}}},Layout:function(t,n,i){var r,o,u,e=(a=Q(t)).on,c=a.bind,f=a.emit,a=n.Slides,s=n.Direction.resolve,l=(n=n.Elements).root,d=n.track,v=n.list,h=a.getAt,p=a.style;function g(){r=i.direction===Jn,_(l,\"maxWidth\",W(i.width)),_(d,s(\"paddingLeft\"),y(!1)),_(d,s(\"paddingRight\"),y(!0)),m(!0)}function m(n){var t=N(l);!n&&o.width===t.width&&o.height===t.height||(_(d,\"height\",function(){var n=\"\";r&&(bn(n=b(),\"height or heightRatio is missing.\"),n=\"calc(\"+n+\" - \"+y(!1)+\" - \"+y(!0)+\")\");return n}()),p(s(\"marginRight\"),W(i.gap)),p(\"width\",i.autoWidth?null:W(i.fixedWidth)||(r?\"\":w())),p(\"height\",W(i.fixedHeight)||(r?i.autoHeight?null:w():b()),!0),o=t,f(Nn),u!==(u=O())&&(A(l,Ot,u),f(\"overflow\",u)))}function y(n){var t=i.padding,n=s(n?\"right\":\"left\");return t&&W(t[n]||(un(t)?0:t))||\"0px\"}function b(){return W(i.height||N(v).width*i.heightRatio)}function w(){var n=W(i.gap);return\"calc((100%\"+(n&&\" + \"+n)+\")/\"+(i.perPage||1)+(n&&\" - \"+n)+\")\"}function x(){return N(v)[s(\"width\")]}function k(n,t){n=h(n||0);return n?N(n.slide)[s(\"width\")]+(t?0:L()):0}function S(n,t){var i,n=h(n);return n?(n=N(n.slide)[s(\"right\")],i=N(v)[s(\"left\")],U(n-i)+(t?0:L())):0}function E(n){return S(t.length-1)-S(0)+k(0,n)}function L(){var n=h(0);return n&&parseFloat(_(n.slide,s(\"marginRight\")))||0}function O(){return t.is(It)||E(!0)>x()}return{mount:function(){var n,t,i;g(),c(window,\"resize load\",(n=R(f,jn),i=qn(t||0,n,null,1),function(){i.isPaused()&&i.start()})),e([K,J],g),e(jn,m)},resize:m,listSize:x,slideSize:k,sliderSize:E,totalSize:S,getPadding:function(n){return parseFloat(_(d,s(\"padding\"+(n?\"Right\":\"Left\"))))||0},isOverflow:O}},Clones:function(c,i,f){var t,r=Q(c),n=r.on,a=i.Elements,s=i.Slides,o=i.Direction.resolve,l=[];function u(){if(n(J,d),n([K,jn],v),t=h()){var o=t,u=s.get().slice(),e=u.length;if(e){for(;u.length<o;)k(u,u);k(u.slice(-o),u.slice(0,o)).forEach(function(n,t){var i=t<o,r=function(n,t){n=n.cloneNode(!0);return M(n,f.classes.clone),n.id=c.root.id+\"-clone\"+An(t+1),n}(n.slide,t);i?O(r,u[0].slide):L(a.list,r),k(l,r),s.register(r,t-o+(i?0:e),n.index)})}i.Layout.resize(!0)}}function d(){e(),u()}function e(){T(l),D(l),r.destroy()}function v(){var n=h();t!==n&&(t<n||!n)&&r.emit(J)}function h(){var n,t=f.clones;return c.is(Pt)?en(t)&&(t=(n=f[o(\"fixedWidth\")]&&i.Layout.slideSize(0))&&kn(N(a.track)[o(\"width\")]/n)||f[o(\"autoWidth\")]&&c.length||2*f.perPage):t=0,t}return{mount:u,destroy:e}},Move:function(r,c,o){var e,n=Q(r),t=n.on,f=n.emit,a=r.state.set,u=(n=c.Layout).slideSize,i=n.getPadding,s=n.totalSize,l=n.listSize,d=n.sliderSize,v=(n=c.Direction).resolve,h=n.orient,p=(n=c.Elements).list,g=n.track;function m(){c.Controller.isBusy()||(c.Scroll.cancel(),y(r.index),c.Slides.update())}function y(n){b(S(n,!0))}function b(n,t){r.is(It)||(t=t?n:function(n){{var t,i;r.is(Pt)&&(t=k(n),i=t>c.Controller.getEnd(),(t<0||i)&&(n=w(n,i)))}return n}(n),_(p,\"transform\",\"translate\"+v(\"X\")+\"(\"+t+\"px)\"),n!==t&&f(Un))}function w(n,t){var i=n-L(t),r=d();return n-=h(r*(kn(U(i)/r)||1))*(t?1:-1)}function x(){b(E(),!0),e.cancel()}function k(n){for(var t=c.Slides.get(),i=0,r=1/0,o=0;o<t.length;o++){var u=t[o].index,e=U(S(u,!0)-n);if(!(e<=r))break;r=e,i=u}return i}function S(n,t){var i=h(s(n-1)-(n=n,\"center\"===(i=o.focus)?(l()-u(n,!0))/2:+i*u(n)||0));return t?(n=i,n=o.trimSpace&&r.is(Mt)?q(n,0,h(d(!0)-l())):n):i}function E(){var n=v(\"left\");return N(p)[n]-N(g)[n]+h(i(!1))}function L(n){return S(n?c.Controller.getEnd():0,!!o.trimSpace)}return{mount:function(){e=c.Transition,t([B,Nn,K,J],m)},move:function(n,t,i,r){var o,u;n!==t&&(o=i<n,u=h(w(E(),o)),o?0<=u:u<=p[v(\"scrollWidth\")]-N(g)[v(\"width\")])&&(x(),b(w(E(),i<n),!0)),a(G),f(H,t,i,n),e.start(t,function(){a(3),f(Dn,t,i,n),r&&r()})},jump:y,translate:b,shift:w,cancel:x,toIndex:k,toPosition:S,getPosition:E,getLimit:L,exceededLimit:function(n,t){t=en(t)?E():t;var i=!0!==n&&h(t)<h(L(!1)),n=!1!==n&&h(t)>h(L(!0));return i||n},reposition:m}},Controller:function(o,u,e){var c,f,a,s,n=Q(o),t=n.on,i=n.emit,l=u.Move,d=l.getPosition,r=l.getLimit,v=l.toPosition,h=(n=u.Slides).isEnough,p=n.getLength,g=e.omitEnd,m=o.is(Pt),y=o.is(Mt),b=R(L,!1),w=R(L,!0),x=e.start||0,k=x;function S(){f=p(!0),a=e.perMove,s=e.perPage,c=_();var n=q(x,0,g?c:f-1);n!==x&&(x=n,l.reposition())}function E(){c!==_()&&i(\"ei\")}function L(n,t){var i=a||(P()?1:s),i=O(x+i*(n?-1:1),x,!(a||P()));return-1===i&&y&&!Sn(d(),r(!n),1)?n?0:c:t?i:A(i)}function O(n,t,i){var r;return h()||P()?((r=function(n){if(y&&\"move\"===e.trimSpace&&n!==x)for(var t=d();t===v(n,!0)&&En(n,0,o.length-1,!e.rewind);)n<x?--n:++n;return n}(n))!==n&&(t=n,n=r,i=!1),n<0||c<n?n=a||!En(0,n,t,!0)&&!En(c,t,n,!0)?m?i?n<0?-(f%s||s):f:n:e.rewind?n<0?c:0:-1:z(D(n)):i&&n!==t&&(n=z(D(t)+(n<t?-1:1)))):n=-1,n}function A(n){return m?(n+f)%f||0:n}function _(){for(var n=f-(P()||m&&a?1:s);g&&0<n--;)if(v(f-1,!0)!==v(n,!0)){n++;break}return q(n,0,f-1)}function z(n){return q(P()?n:s*n,0,c)}function D(n){return P()?Y(n,c):xn((c<=n?f-1:n)/s)}function M(n){n!==x&&(k=x,x=n)}function P(){return!en(e.focus)||e.isNavigation}function I(){return o.state.is([G,rn])&&!!e.waitForTransition}return{mount:function(){S(),t([K,J,\"ei\"],S),t(Nn,E)},go:function(n,t,i){var r;I()||-1<(r=A(n=function(n){var t=x;{var i,r;C(n)?(r=n.match(/([+\\-<>])(\\d+)?/)||[],i=r[1],r=r[2],\"+\"===i||\"-\"===i?t=O(x+ +(\"\"+i+(+r||1)),x):\">\"===i?t=r?z(+r):b(!0):\"<\"===i&&(t=w(!0))):t=m?n:q(n,0,c)}return t}(n)))&&(t||r!==x)&&(M(r),l.move(n,r,k,i))},scroll:function(n,t,i,r){u.Scroll.scroll(n,t,i,function(){var n=A(l.toIndex(d()));M(g?Y(n,c):n),r&&r()})},getNext:b,getPrev:w,getAdjacent:L,getEnd:_,setIndex:M,getIndex:function(n){return n?k:x},toIndex:z,toPage:D,toDest:function(n){return n=l.toIndex(n),y?q(n,0,c):n},hasFocus:P,isBusy:I}},Arrows:function(o,n,t){var i,r,u=Q(o),e=u.on,c=u.bind,f=u.emit,a=t.classes,s=t.i18n,l=n.Elements,d=n.Controller,v=l.arrows,h=l.track,p=v,g=l.prev,m=l.next,y={};function b(){var n=t.arrows;!n||g&&m||(p=v||j(\"div\",a.arrows),g=S(!0),m=S(!1),i=!0,L(p,[g,m]),v||O(p,h)),g&&m&&(an(y,{prev:g,next:m}),ln(p,n?\"\":\"none\"),M(p,r=dt+\"--\"+t.direction),n&&(e([B,Dn,J,V,\"ei\"],E),c(m,\"click\",R(k,\">\")),c(g,\"click\",R(k,\"<\")),E(),I([g,m],Kn,h.id),f(\"arrows:mounted\",g,m))),e(K,w)}function w(){x(),b()}function x(){u.destroy(),X(p,r),i?(T(v?[g,m]:p),g=m=null):P([g,m],ut)}function k(n){d.go(n,!0)}function S(n){return hn('<button class=\"'+a.arrow+\" \"+(n?a.prev:a.next)+'\" type=\"button\"><svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 40 40\" width=\"40\" height=\"40\" focusable=\"false\"><path d=\"'+(t.arrowPath||\"m15.5 0.932-4.3 4.38 14.5 14.6-14.5 14.5 4.3 4.4 14.6-14.6 4.4-4.3-4.4-4.4-14.6-14.6z\")+'\" />')}function E(){var n,t,i,r;g&&m&&(r=o.index,n=d.getPrev(),t=d.getNext(),i=-1<n&&r<n?s.last:s.prev,r=-1<t&&t<r?s.first:s.next,g.disabled=n<0,m.disabled=t<0,I(g,nn,i),I(m,nn,r),f(\"arrows:updated\",g,m,n,t))}return{arrows:y,mount:b,destroy:x,update:E}},Autoplay:function(n,t,i){var r,o,u=Q(n),e=u.on,c=u.bind,f=u.emit,a=qn(i.interval,n.go.bind(n,\">\"),function(n){var t=l.bar;t&&_(t,\"width\",100*n+\"%\"),f(\"autoplay:playing\",n)}),s=a.isPaused,l=t.Elements,d=(u=t.Elements).root,v=u.toggle,h=i.autoplay,p=\"pause\"===h;function g(){s()&&t.Slides.isEnough()&&(a.start(!i.resetProgress),o=r=p=!1,b(),f(Fn))}function m(n){p=!!(n=void 0===n?!0:n),b(),s()||(a.pause(),f(Xn))}function y(){p||(r||o?m(!1):g())}function b(){v&&(A(v,tn,!p),I(v,nn,i.i18n[p?\"play\":\"pause\"]))}function w(n){n=t.Slides.getAt(n);a.set(n&&+z(n.slide,Ct)||i.interval)}return{mount:function(){h&&(i.pauseOnHover&&c(d,\"mouseenter mouseleave\",function(n){r=\"mouseenter\"===n.type,y()}),i.pauseOnFocus&&c(d,\"focusin focusout\",function(n){o=\"focusin\"===n.type,y()}),v&&c(v,\"click\",function(){p?g():m(!0)}),e([H,Tn,J],a.rewind),e(H,w),v&&I(v,Kn,l.track.id),p||g(),b())},destroy:a.cancel,play:g,pause:m,isPaused:s}},Cover:function(n,t,i){var r=Q(n).on;function o(i){t.Slides.forEach(function(n){var t=fn(n.container||n.slide,\"img\");t&&t.src&&u(i,t,n)})}function u(n,t,i){i.style(\"background\",n?'center/cover no-repeat url(\"'+t.src+'\")':\"\",!0),ln(t,n?\"none\":\"\")}return{mount:function(){i.cover&&(r(Wn,R(u,!0)),r([B,K,J],R(o,!0)))},destroy:R(o,!1)}},Scroll:function(n,c,u){var f,a,t=Q(n),i=t.on,s=t.emit,l=n.state.set,d=c.Move,v=d.getPosition,e=d.getLimit,h=d.exceededLimit,p=d.translate,g=n.is(Mt),m=1;function y(n,t,i,r,o){var u,e=v(),i=(x(),!i||g&&h()||(i=c.Layout.sliderSize(),u=Ln(n)*i*xn(U(n)/i)||0,n=d.toPosition(c.Controller.toDest(n%i))+u),Sn(e,n,1));m=1,t=i?0:t||wn(U(n-e)/1.5,800),a=r,f=qn(t,b,R(w,e,n,o),1),l(rn),s(Tn),f.start()}function b(){l(3),a&&a(),s(V)}function w(n,t,i,r){var o=v(),r=(n+(t-n)*(t=r,(n=u.easingFunc)?n(t):1-Math.pow(1-t,4))-o)*m;p(o+r),g&&!i&&h()&&(m*=.6,U(r)<10&&y(e(h(!0)),600,!1,a,!0))}function x(){f&&f.cancel()}function r(){f&&!f.isPaused()&&(x(),b())}return{mount:function(){i(H,x),i([K,J],r)},destroy:x,scroll:y,cancel:r}},Drag:function(e,o,c){var f,t,u,a,s,l,d,v,n=Q(e),i=n.on,h=n.emit,p=n.bind,g=n.unbind,m=e.state,y=o.Move,b=o.Scroll,w=o.Controller,x=o.Elements.track,k=o.Media.reduce,r=(n=o.Direction).resolve,S=n.orient,E=y.getPosition,L=y.exceededLimit,O=!1;function j(){var n=c.drag;C(!n),a=\"free\"===n}function N(n){var t,i,r;l=!1,d||(t=R(n),i=n.target,r=c.noDrag,cn(i,\".\"+mt+\", .\"+vt)||r&&cn(i,r)||!t&&n.button||(w.isBusy()?F(n,!0):(v=t?x:window,s=m.is([G,rn]),u=null,p(v,zt,A,jt),p(v,Dt,_,jt),y.cancel(),b.cancel(),z(n))))}function A(n){var t,i,r,o,u;m.is(6)||(m.set(6),h(\"drag\")),n.cancelable&&(s?(y.translate(f+D(n)/(O&&e.is(Mt)?5:1)),u=200<M(n),t=O!==(O=L()),(u||t)&&z(n),l=!0,h(\"dragging\"),F(n)):U(D(u=n))>U(D(u,!0))&&(t=n,i=c.dragMinThreshold,r=un(i),o=r&&i.mouse||0,r=(r?i.touch:+i)||10,s=U(D(t))>(R(t)?r:o),F(n)))}function _(n){var t,i,r;m.is(6)&&(m.set(3),h(\"dragged\")),s&&(i=function(n){return E()+Ln(n)*Y(U(n)*(c.flickPower||600),a?1/0:o.Layout.listSize()*(c.flickMaxPages||1))}(t=function(n){if(e.is(Pt)||!O){var t=M(n);if(t&&t<200)return D(n)/t}return 0}(t=n)),r=c.rewind&&c.rewindByDrag,k(!1),a?w.scroll(i,0,c.snap):e.is(It)?w.go(S(Ln(t))<0?r?\"<\":\"-\":r?\">\":\"+\"):e.is(Mt)&&O&&r?w.go(L(!0)?\">\":\"<\"):w.go(w.toDest(i),!0),k(!0),F(n)),g(v,zt,A),g(v,Dt,_),s=!1}function T(n){!d&&l&&F(n,!0)}function z(n){u=t,t=n,f=E()}function D(n,t){return I(n,t)-I(P(n),t)}function M(n){return mn(n)-mn(P(n))}function P(n){return t===n&&u||t}function I(n,t){return(R(n)?n.changedTouches[0]:n)[\"page\"+r(t?\"Y\":\"X\")]}function R(n){return\"undefined\"!=typeof TouchEvent&&n instanceof TouchEvent}function C(n){d=n}return{mount:function(){p(x,zt,on,jt),p(x,Dt,on,jt),p(x,_t,N,jt),p(x,\"click\",T,{capture:!0}),p(x,\"dragstart\",F),i([B,K],j)},disable:C,isDragging:function(){return s}}},Keyboard:function(t,n,i){var r,o,u=Q(t),e=u.on,c=u.bind,f=u.unbind,a=t.root,s=n.Direction.resolve;function l(){var n=i.keyboard;n&&(r=\"global\"===n?window:a,c(r,Gt,h))}function d(){f(r,Gt)}function v(){var n=o;o=!0,p(function(){o=n})}function h(n){o||((n=Tt(n))===s(Bn)?t.go(\"<\"):n===s(Hn)&&t.go(\">\"))}return{mount:function(){l(),e(K,d),e(K,l),e(H,v)},destroy:d,disable:function(n){o=n}}},LazyLoad:function(i,n,o){var t=Q(i),r=t.on,u=t.off,e=t.bind,c=t.emit,f=\"sequential\"===o.lazyLoad,a=[Dn,V],s=[];function l(){D(s),n.Slides.forEach(function(r){gn(r.slide,Wt).forEach(function(n){var t=z(n,Ft),i=z(n,Xt);t===n.src&&i===n.srcset||(t=o.classes.spinner,t=fn(i=n.parentElement,\".\"+t)||j(\"span\",t,i),s.push([n,r,t]),n.src||ln(n,\"none\"))})}),(f?p:(u(a),r(a,d),d))()}function d(){(s=s.filter(function(n){var t=o.perPage*((o.preloadPages||1)+1)-1;return!n[1].isWithin(i.index,t)||v(n)})).length||u(a)}function v(n){var t=n[0];M(n[1].slide,Et),e(t,\"load error\",R(h,n)),I(t,\"src\",z(t,Ft)),I(t,\"srcset\",z(t,Xt)),P(t,Ft),P(t,Xt)}function h(n,t){var i=n[0],r=n[1];X(r.slide,Et),\"error\"!==t.type&&(T(n[2]),ln(i,\"\"),c(Wn,i,r),c(jn)),f&&p()}function p(){s.length&&v(s.shift())}return{mount:function(){o.lazyLoad&&(l(),r(J,l))},destroy:R(D,s),check:d}},Pagination:function(l,n,d){var v,h,t=Q(l),p=t.on,g=t.emit,m=t.bind,y=n.Slides,b=n.Elements,w=n.Controller,x=w.hasFocus,r=w.getIndex,e=w.go,c=n.Direction.resolve,k=b.pagination,S=[];function E(){v&&(T(k?o(v.children):v),X(v,h),D(S),v=null),t.destroy()}function L(n){e(\">\"+n,!0)}function O(n,t){var i=S.length,r=Tt(t),o=A(),u=-1,o=(r===c(Hn,!1,o)?u=++n%i:r===c(Bn,!1,o)?u=(--n+i)%i:\"Home\"===r?u=0:\"End\"===r&&(u=i-1),S[u]);o&&(dn(o.button),e(\">\"+u),F(t,!0))}function A(){return d.paginationDirection||d.direction}function _(n){return S[w.toPage(n)]}function z(){var n,t=_(r(!0)),i=_(r());t&&(X(n=t.button,tn),P(n,Qn),I(n,$,-1)),i&&(M(n=i.button,tn),I(n,Qn,!0),I(n,$,\"\")),g(\"pagination:updated\",{list:v,items:S},t,i)}return{items:S,mount:function n(){E(),p([K,J,\"ei\"],n);var t=d.pagination;if(k&&ln(k,t?\"\":\"none\"),t){p([H,Tn,V],z);var t=l.length,i=d.classes,r=d.i18n,o=d.perPage,u=x()?w.getEnd()+1:kn(t/o);M(v=k||j(\"ul\",i.pagination,b.track.parentElement),h=gt+\"--\"+A()),I(v,Z,\"tablist\"),I(v,nn,r.select),I(v,nt,A()===Jn?\"vertical\":\"\");for(var e=0;e<u;e++){var c=j(\"li\",null,v),f=j(\"button\",{class:i.page,type:\"button\"},c),a=y.getIn(e).map(function(n){return n.slide.id}),s=!x()&&1<o?r.pageX:r.slideX;m(f,\"click\",R(L,e)),d.paginationKeyboard&&m(f,\"keydown\",R(O,e)),I(c,Z,\"presentation\"),I(f,Z,\"tab\"),I(f,Kn,a.join(\" \")),I(f,nn,On(s,e+1)),I(f,$,-1),S.push({li:c,button:f,page:e})}z(),g(\"pagination:mounted\",{list:v,items:S},_(l.index))}},destroy:E,getAt:_,update:z}},Sync:function(i,n,t){var r=t.isNavigation,o=t.slideFocus,u=[];function e(){var n,t;i.splides.forEach(function(n){n.isParent||(f(i,n.splide),f(n.splide,i))}),r&&(n=Q(i),(t=n.on)(Mn,s),t(Yn,l),t([B,K],a),u.push(n),n.emit(Gn,i.splides))}function c(){u.forEach(function(n){n.destroy()}),D(u)}function f(n,r){n=Q(n);n.on(H,function(n,t,i){r.go(r.is(Pt)?i:n)}),u.push(n)}function a(){I(n.Elements.list,nt,t.direction===Jn?\"vertical\":\"\")}function s(n){i.go(n.index)}function l(n,t){b(Yt,Tt(t))&&(s(n),F(t))}return{setup:R(n.Media.set,{slideFocus:en(o)?r:o},!0),mount:e,destroy:c,remount:function(){c(),e()}}},Wheel:function(e,c,f){var n=Q(e).bind,a=0;function t(n){var t,i,r,o,u;n.cancelable&&(t=(u=n.deltaY)<0,i=mn(n),r=f.wheelMinThreshold||0,o=f.wheelSleep||0,U(u)>r&&o<i-a&&(e.go(t?\"<\":\">\"),a=i),u=t,f.releaseWheel&&!e.state.is(G)&&-1===c.Controller.getAdjacent(u)||F(n))}return{mount:function(){f.wheel&&n(c.Elements.track,\"wheel\",t,jt)}}},Live:function(n,t,i){var r=Q(n).on,o=t.Elements.track,u=i.live&&!i.isNavigation,e=j(\"span\",wt),c=qn(90,R(f,!1));function f(n){I(o,rt,n),n?(L(o,e),c.start()):(T(e),c.cancel())}function a(n){u&&I(o,it,n?\"off\":\"polite\")}return{mount:function(){u&&(a(!t.Autoplay.isPaused()),I(o,ot,!0),e.textContent=\"\",r(Fn,R(a,!0)),r(Xn,R(a,!1)),r([Dn,V],R(f,!0)))},disable:a,destroy:function(){P(o,[it,ot,rt]),T(e)}}}}),qt={type:\"slide\",role:\"region\",speed:400,perPage:1,cloneStatus:!0,arrows:!0,pagination:!0,paginationKeyboard:!0,interval:5e3,pauseOnHover:!0,pauseOnFocus:!0,resetProgress:!0,easing:\"cubic-bezier(0.25, 1, 0.5, 1)\",drag:!0,direction:\"ltr\",trimSpace:!0,focusableNodes:\"a, button, textarea, input, select, iframe\",live:!0,classes:{slide:at,clone:st,arrows:dt,arrow:vt,prev:ht,next:pt,pagination:gt,page:mt,spinner:i+\"spinner\"},i18n:{prev:\"Previous slide\",next:\"Next slide\",first:\"Go to first slide\",last:\"Go to last slide\",slideX:\"Go to slide %s\",pageX:\"Go to page %s\",play:\"Start autoplay\",pause:\"Pause autoplay\",carousel:\"carousel\",slide:\"slide\",select:\"Select a slide to show\",slideLabel:\"%s of %s\"},reducedMotion:{speed:0,rewindSpeed:0,autoplay:\"pause\"}};function Bt(n,t,i){var r=t.Slides;function o(){r.forEach(function(n){n.style(\"transform\",\"translateX(-\"+100*n.index+\"%)\")})}return{mount:function(){Q(n).on([B,J],o)},start:function(n,t){r.style(\"transition\",\"opacity \"+i.speed+\"ms \"+i.easing),p(t)},cancel:on}}function Ht(u,n,e){var c,f=n.Move,a=n.Controller,s=n.Scroll,t=n.Elements.list,l=R(_,t,\"transition\");function i(){l(\"\"),s.cancel()}return{mount:function(){Q(u).bind(t,\"transitionend\",function(n){n.target===t&&c&&(i(),c())})},start:function(n,t){var i=f.toPosition(n,!0),r=f.getPosition(),o=function(n){var t=e.rewindSpeed;if(u.is(Mt)&&t){var i=a.getIndex(!0),r=a.getEnd();if(0===i&&r<=n||r<=i&&0===n)return t}return e.speed}(n);1<=U(i-r)&&1<=o?e.useScroll?s.scroll(i,o,!1,t):(l(\"transform \"+o+\"ms \"+e.easing),f.translate(i,!0),c=t):(f.jump(n),t())},cancel:i}}t=function(){function i(n,t){this.event=Q(),this.Components={},this.state=s(1),this.splides=[],this.n={},this.t={};n=C(n)?pn(document,n):n;bn(n,n+\" is invalid.\"),t=d({label:z(this.root=n,nn)||\"\",labelledby:z(n,Zn)||\"\"},qt,i.defaults,t||{});try{d(t,JSON.parse(z(n,f)))}catch(n){bn(!1,\"Invalid JSON\")}this.n=Object.create(d({},t))}var n=i.prototype;return n.mount=function(n,t){var i=this,r=this.state,o=this.Components;return bn(r.is([1,7]),\"Already mounted!\"),r.set(1),this.i=o,this.r=t||this.r||(this.is(It)?Bt:Ht),this.t=n||this.t,w(an({},Ut,this.t,{Transition:this.r}),function(n,t){n=n(i,o,i.n);(o[t]=n).setup&&n.setup()}),w(o,function(n){n.mount&&n.mount()}),this.emit(B),M(this.root,\"is-initialized\"),r.set(3),this.emit(\"ready\"),this},n.sync=function(n){return this.splides.push({splide:n}),n.splides.push({splide:this,isParent:!0}),this.state.is(3)&&(this.i.Sync.remount(),n.Components.Sync.remount()),this},n.go=function(n){return this.i.Controller.go(n),this},n.on=function(n,t){return this.event.on(n,t),this},n.off=function(n){return this.event.off(n),this},n.emit=function(n){var t;return(t=this.event).emit.apply(t,[n].concat(o(arguments,1))),this},n.add=function(n,t){return this.i.Slides.add(n,t),this},n.remove=function(n){return this.i.Slides.remove(n),this},n.is=function(n){return this.n.type===n},n.refresh=function(){return this.emit(J),this},n.destroy=function(t){void 0===t&&(t=!0);var n=this.event,i=this.state;return i.is(1)?Q(this).on(\"ready\",this.destroy.bind(this,t)):(w(this.i,function(n){n.destroy&&n.destroy(t)},!0),n.emit(a),n.destroy(),t&&D(this.splides),i.set(7)),this},Jt(i,[{key:\"options\",get:function(){return this.n},set:function(n){this.i.Media.set(n,!0,!0)}},{key:\"length\",get:function(){return this.i.Slides.getLength(!0)}},{key:\"index\",get:function(){return this.i.Controller.getIndex()}}]),i}();return t.defaults={},t.STATES=r,t},\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=t():\"function\"==typeof define&&define.amd?define(t):(n=\"undefined\"!=typeof globalThis?globalThis:n||self).Splide=t();\n//# sourceMappingURL=splide.min.js.map\n","/**\r\n * Matches when users request reducing non-essential animations.\r\n *\r\n * @link https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-reduced-motion\r\n */\r\nexport const MEDIA_PREFERS_REDUCED_MOTION = '(prefers-reduced-motion: reduce)';","/**\r\n * Splide has been just created.\r\n */\r\nexport const CREATED = 1;\r\n\r\n/**\r\n * Splide has mounted components.\r\n */\r\nexport const MOUNTED = 2;\r\n\r\n/**\r\n * Splide is ready.\r\n */\r\nexport const IDLE = 3;\r\n\r\n/**\r\n * Splide is moving.\r\n */\r\nexport const MOVING = 4;\r\n\r\n/**\r\n * Splide is moving.\r\n */\r\nexport const SCROLLING = 5;\r\n\r\n/**\r\n * The user is dragging the slider.\r\n */\r\nexport const DRAGGING = 6;\r\n\r\n/**\r\n * Splide has been destroyed.\r\n */\r\nexport const DESTROYED = 7;\r\n\r\n/**\r\n * The collection of all states.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport const STATES = {\r\n  CREATED,\r\n  MOUNTED,\r\n  IDLE,\r\n  MOVING,\r\n  SCROLLING,\r\n  DRAGGING,\r\n  DESTROYED,\r\n};\r\n","/**\r\n * Empties the array.\r\n *\r\n * @param array - A array to empty.\r\n */\r\nexport function empty( array: any[] ): void {\r\n  array.length = 0;\r\n}\r\n","/**\r\n * The slice method for an array-like object.\r\n *\r\n * @param arrayLike - An array-like object.\r\n * @param start     - Optional. A start index.\r\n * @param end       - Optional. A end index.\r\n *\r\n * @return An array with sliced elements.\r\n */\r\nexport function slice<T>( arrayLike: ArrayLike<T>, start?: number, end?: number ): T[] {\r\n  return Array.prototype.slice.call( arrayLike, start, end );\r\n}\r\n","import { AnyFunction, ShiftN } from '../../../types';\r\nimport { slice } from '../../arrayLike';\r\n\r\n\r\n/**\r\n * Create a function where provided arguments are bound.\r\n * `this` parameter will be always null.\r\n *\r\n * @param func - A function.\r\n * @param args - Arguments to bind to the function.\r\n *\r\n * @return A function where arguments are bound.\r\n */\r\nexport function apply<F extends AnyFunction, A extends any[] = any[]>(\r\n  func: F,\r\n  ...args: A\r\n): ( ...args: ShiftN<Parameters<F>, A[\"length\"]> ) => ReturnType<F>;\r\n\r\n/**\r\n * Create a function where provided arguments are bound.\r\n * `this` parameter will be always null.\r\n *\r\n * @param func - A function.\r\n */\r\nexport function apply( func: AnyFunction ): any {\r\n  // eslint-disable-next-line prefer-rest-params, prefer-spread\r\n  return func.bind( null, ...slice( arguments, 1 ) );\r\n}\r\n","/**\r\n * No operation.\r\n */\r\nexport const noop = (): void => {}; // eslint-disable-line no-empty-function, @typescript-eslint/no-empty-function\r\n","import { AnyFunction } from '../../../types';\r\n\r\n\r\n/**\r\n * Invokes the callback on the next tick.\r\n *\r\n * @param callback - A callback function.\r\n */\r\nexport const nextTick: ( callback: AnyFunction ) => ReturnType<typeof setTimeout> = setTimeout;\r\n","/**\r\n * The alias of `window.requestAnimationFrame()`.\r\n */\r\nexport function raf( func: FrameRequestCallback ): number {\r\n  return requestAnimationFrame( func );\r\n}\r\n","import { AnyFunction } from '../../types';\r\nimport { apply } from '../function';\r\n\r\n\r\n/**\r\n * The alias of the type check function.\r\n *\r\n * @param type    - A type.\r\n * @param subject - A subject to check.\r\n *\r\n * @return `true` if the subject is the specified type.\r\n */\r\nfunction typeOf( type: string, subject: unknown ): boolean {\r\n  return typeof subject === type;\r\n}\r\n\r\n/**\r\n * Checks if the given subject is an object or not.\r\n *\r\n * @param subject - A subject to check.\r\n *\r\n * @return `true` if the subject is an object, or otherwise `false`.\r\n */\r\nexport function isObject( subject: unknown ): subject is object {\r\n  return ! isNull( subject ) && typeOf( 'object', subject );\r\n}\r\n\r\n/**\r\n * Checks if the given subject is an array or not.\r\n *\r\n * @param subject - A subject to check.\r\n *\r\n * @return `true` if the subject is an array, or otherwise `false`.\r\n */\r\nexport const isArray: <T>( subject: unknown ) => subject is T[] = Array.isArray;\r\n\r\n/**\r\n * Checks if the given subject is a function or not.\r\n *\r\n * @param subject - A subject to check.\r\n *\r\n * @return `true` if the subject is a function, or otherwise `false`.\r\n */\r\nexport const isFunction = <( subject: unknown ) => subject is AnyFunction>apply( typeOf, 'function' );\r\n\r\n/**\r\n * Checks if the given subject is a string or not.\r\n *\r\n * @param subject - A subject to check.\r\n *\r\n * @return `true` if the subject is a string, or otherwise `false`.\r\n */\r\nexport const isString = <( subject: unknown ) => subject is string>apply( typeOf, 'string' );\r\n\r\n/**\r\n * Checks if the given subject is `undefined` or not.\r\n *\r\n * @param subject - A subject to check.\r\n *\r\n * @return `true` if the subject is `undefined`, or otherwise `false`.\r\n */\r\nexport const isUndefined = <( subject: unknown ) => subject is undefined>apply( typeOf, 'undefined' );\r\n\r\n/**\r\n * Checks if the given subject is `null` or not.\r\n *\r\n * @param subject - A subject to check.\r\n *\r\n * @return `true` if the subject is `null`, or otherwise `false`.\r\n */\r\nexport function isNull( subject: unknown ): subject is null {\r\n  return subject === null;\r\n}\r\n\r\n/**\r\n * Checks if the given subject is an HTMLElement instance or not.\r\n * This method takes into account which `window` the node belongs to.\r\n *\r\n * @param subject - A subject to check.\r\n *\r\n * @return `true` if the subject is an HTMLElement instance, or otherwise `false`.\r\n */\r\nexport function isHTMLElement( subject: unknown ): subject is HTMLElement {\r\n  try {\r\n    return subject instanceof ( ( subject as Node ).ownerDocument.defaultView || window ).HTMLElement;\r\n  } catch ( e ) {\r\n    return false;\r\n  }\r\n}","import { isArray } from '../../type/type';\r\n\r\n\r\n/**\r\n * Push the provided value to an array if the value is not an array.\r\n *\r\n * @param value - A value to push.\r\n *\r\n * @return An array containing the value, or the value itself if it is already an array.\r\n */\r\nexport function toArray<T>( value: T | T[] ): T[] {\r\n  return isArray( value ) ? value : [ value ];\r\n}\r\n","import { toArray } from '../toArray/toArray';\r\n\r\n\r\n/**\r\n * The extended `Array#forEach` method that accepts a single value as an argument.\r\n *\r\n * @param values   - A value or values to iterate over.\r\n * @param iteratee - An iteratee function.\r\n */\r\nexport function forEach<T>( values: T | T[], iteratee: ( value: T, index: number, array: T[] ) => void ): void {\r\n  toArray( values ).forEach( iteratee );\r\n}\r\n","/**\r\n * Checks if the array includes the value or not.\r\n * `Array#includes` is not supported by IE.\r\n *\r\n * @param array - An array.\r\n * @param value - A value to search for.\r\n *\r\n * @return `true` if the array includes the value, or otherwise `false`.\r\n */\r\nexport function includes<T>( array: T[], value: T ): boolean {\r\n  return array.indexOf( value ) > -1;\r\n}\r\n","import { toArray } from '../toArray/toArray';\r\n\r\n\r\n/**\r\n * Extended `Array#push()` that accepts an item or an array with items.\r\n *\r\n * @param array - An array to push items.\r\n * @param items - An item or items to push.\r\n *\r\n * @return A provided array itself.\r\n */\r\nexport function push<T>( array: T[], items: T | T[] ): T[] {\r\n  array.push( ...toArray( items ) );\r\n  return array;\r\n}\r\n","import { forEach } from '../../array';\r\n\r\n\r\n/**\r\n * Toggles the provided class or classes by following the `add` boolean.\r\n *\r\n * @param elm     - An element whose classes are toggled.\r\n * @param classes - A class or class names.\r\n * @param add     - Whether to add or remove a class.\r\n */\r\nexport function toggleClass( elm: Element, classes: string | string[], add: boolean ): void {\r\n  if ( elm ) {\r\n    forEach( classes, name => {\r\n      if ( name ) {\r\n        elm.classList[ add ? 'add' : 'remove' ]( name );\r\n      }\r\n    } );\r\n  }\r\n}\r\n","import { isString } from '../../type/type';\r\nimport { toggleClass } from '../toggleClass/toggleClass';\r\n\r\n\r\n/**\r\n * Adds classes to the element.\r\n *\r\n * @param elm     - An element to add classes to.\r\n * @param classes - Classes to add.\r\n */\r\nexport function addClass( elm: Element, classes: string | string[] ): void {\r\n  toggleClass( elm, isString( classes ) ? classes.split( ' ' ) : classes, true );\r\n}\r\n","import { forEach } from '../../array';\r\n\r\n\r\n/**\r\n * Appends children to the parent element.\r\n *\r\n * @param parent   - A parent element.\r\n * @param children - A child or children to append to the parent.\r\n */\r\nexport function append( parent: Element, children: Node | Node[] ): void {\r\n  forEach( children, parent.appendChild.bind( parent ) );\r\n}\r\n","import { forEach } from '../../array';\r\n\r\n\r\n/**\r\n * Inserts a node or nodes before the specified reference node.\r\n *\r\n * @param nodes - A node or nodes to insert.\r\n * @param ref   - A reference node.\r\n */\r\nexport function before( nodes: Node | Node[], ref: Node | null ): void {\r\n  forEach( nodes, node => {\r\n    const parent = ( ref || node ).parentNode;\r\n\r\n    if ( parent ) {\r\n      parent.insertBefore( node, ref );\r\n    }\r\n  } );\r\n}\r\n","import { isHTMLElement } from '../../type/type';\r\n\r\n\r\n/**\r\n * Checks if the element can be selected by the provided selector or not.\r\n *\r\n * @param elm      - An element to check.\r\n * @param selector - A selector to test.\r\n *\r\n * @return `true` if the selector matches the element, or otherwise `false`.\r\n */\r\nexport function matches( elm: Element | EventTarget, selector: string ): boolean {\r\n  return isHTMLElement( elm ) && ( elm[ 'msMatchesSelector' ] || elm.matches ).call( elm, selector );\r\n}\r\n","import { slice } from '../../arrayLike';\r\nimport { matches } from '../matches/matches';\r\n\r\n\r\n/**\r\n * Finds children that has the specified tag or class name.\r\n *\r\n * @param parent   - A parent element.\r\n * @param selector - Optional. A selector to filter children.\r\n *\r\n * @return An array with filtered children.\r\n */\r\nexport function children<E extends HTMLElement>( parent: HTMLElement, selector?: string ): E[] {\r\n  const children = parent ? slice( parent.children ) as E[] : [];\r\n  return selector ? children.filter( child => matches( child, selector ) ) : children;\r\n}\r\n","import { children } from '../children/children';\r\n\r\n\r\n/**\r\n * Returns a child element that matches the specified tag or class name.\r\n *\r\n * @param parent   - A parent element.\r\n * @param selector - A selector to filter children.\r\n *\r\n * @return A matched child element if available, or otherwise `undefined`.\r\n */\r\nexport function child<E extends HTMLElement>( parent: HTMLElement, selector?: string ): E | undefined {\r\n  return selector ? children<E>( parent, selector )[ 0 ] : parent.firstElementChild as E;\r\n}\r\n","/**\r\n * An alias of `Object.keys()`\r\n */\r\nexport const ownKeys = Object.keys;","import { ownKeys } from '../ownKeys/ownKeys';\r\n\r\n\r\n/**\r\n * Iterates over the provided object by own enumerable keys with calling the iteratee function.\r\n *\r\n * @param object   - An object to iterate over.\r\n * @param iteratee - An iteratee function that takes `value` and `key` as arguments.\r\n * @param right    - If `true`, the method iterates over the object from the end like `forEachRight()`.\r\n *\r\n * @return A provided object itself.\r\n */\r\nexport function forOwn<T extends object>(\r\n  object: T,\r\n  iteratee: ( value: T[ keyof T ], key: string ) => boolean | void,\r\n  right?: boolean\r\n): T {\r\n  if ( object ) {\r\n    ( right ? ownKeys( object ).reverse() : ownKeys( object ) ).forEach( key => {\r\n      key !== '__proto__' && iteratee( object[ key ], key );\r\n    } );\r\n  }\r\n\r\n  return object;\r\n}\r\n","import { Cast, Head, Push, Resolve, Shift } from '../../../types';\r\nimport { slice } from '../../arrayLike';\r\nimport { forOwn } from '../forOwn/forOwn';\r\n\r\n\r\n/**\r\n * Assigns U to T.\r\n *\r\n * @typeParam T - An object to assign to.\r\n * @typeParam U - An object to assign.\r\n *\r\n * @return An assigned object type.\r\n */\r\nexport type Assign<T, U> = Omit<T, keyof U> & U;\r\n\r\n/**\r\n * Recursively assigns U[] to T.\r\n *\r\n * @typeParam T - An object to assign to.\r\n * @typeParam U - A tuple contains objects.\r\n *\r\n * @return An assigned object type.\r\n */\r\nexport type Assigned<T extends object, U extends object[], N extends number, C extends any[] = []> = {\r\n  0: T,\r\n  1: Assigned<Assign<T, Head<U>>, Shift<U>, N, Push<C>>,\r\n}[ C['length'] extends N ? 0 : 1 ] extends infer A ? Cast<A, any> : never;\r\n\r\nexport function assign<T extends object>( object: T ): T;\r\n\r\nexport function assign<T extends object, U extends object[]>(\r\n  object: T,\r\n  ...sources: U\r\n): Resolve<Assigned<T, U, U['length']>>\r\n\r\n/**\r\n * Assigns all own enumerable properties of all source objects to the provided object.\r\n *\r\n * @param object - An object to assign properties to.\r\n *\r\n * @return An object assigned properties of the sources to.\r\n */\r\nexport function assign<T extends object>( object: T ): any {\r\n  // eslint-disable-next-line prefer-rest-params, prefer-spread\r\n  slice( arguments, 1 ).forEach( source => {\r\n    forOwn( source, ( value, key ) => {\r\n      object[ key ] = source[ key ];\r\n    } );\r\n  } );\r\n\r\n  return object;\r\n}\r\n","import { Cast, Head, Push, Resolve, Shift } from '../../../types';\r\nimport { slice } from '../../arrayLike';\r\nimport { isArray, isObject } from '../../type/type';\r\nimport { forOwn } from '../forOwn/forOwn';\r\n\r\n\r\n/**\r\n * Merges U to T.\r\n *\r\n * @typeParam T - An object to merge U into.\r\n * @typeParam U - An object to merge properties from.\r\n *\r\n * @return A merged object type.\r\n */\r\nexport type Merge<T extends object, U extends object> = Omit<T, keyof U> & {\r\n  [ K in ( keyof T & keyof U ) ]: U[ K ] extends object\r\n    ? U[ K ] extends any[]\r\n      ? U[ K ]\r\n      : T[ K ] extends object\r\n        ? Merge<T[ K ], U[ K ]> extends infer A ? Resolve<Cast<A, object>> : never\r\n        : U[ K ]\r\n    : U[ K ];\r\n} & Omit<U, keyof T>;\r\n\r\n/**\r\n * Recursively merges U[] to T.\r\n *\r\n * @typeParam T - An object to assign to.\r\n * @typeParam U - A tuple contains objects.\r\n *\r\n * @return An assigned object type.\r\n */\r\nexport type Merged<T extends object, U extends object[], N extends number, C extends any[] = []> = {\r\n  0: T,\r\n  1: Merged<Merge<T, Head<U>>, Shift<U>, N, Push<C>>,\r\n}[ C['length'] extends N ? 0 : 1 ] extends infer A ? Cast<A, any> : never;\r\n\r\nexport function merge<T extends object>( object: T ): T;\r\n\r\nexport function merge<T extends object, U extends object[]>(\r\n  object: T,\r\n  ...sources: U\r\n): Resolve<Merged<T, U, U['length']>>\r\n\r\n/**\r\n * Recursively merges source properties to the object.\r\n * Be aware that this method does not merge arrays. They are just duplicated by `slice()`.\r\n *\r\n * @param object - An object to merge properties to.\r\n *\r\n * @return A new object with merged properties.\r\n */\r\nexport function merge<T extends object>( object: T ): any {\r\n  // eslint-disable-next-line prefer-rest-params\r\n  slice( arguments, 1 ).forEach( source => {\r\n    forOwn( source, ( value, key ) => {\r\n      if ( isArray( value ) ) {\r\n        object[ key ] = value.slice();\r\n      } else if ( isObject( value ) ) {\r\n        object[ key ] = merge( {}, isObject( object[ key ] ) ? object[ key ] : {}, value );\r\n      } else {\r\n        object[ key ] = value;\r\n      }\r\n    } );\r\n  } );\r\n\r\n  return object;\r\n}\r\n","import { forEach } from '../../array';\r\nimport { ownKeys } from '../ownKeys/ownKeys';\r\n\r\n\r\n/**\r\n * Deletes specified own keys from the object.\r\n *\r\n * @param object - An object.\r\n * @param keys   - A key or keys to delete. If not specified, all own enumerable keys will be deleted.\r\n */\r\nexport function omit( object: object, keys?: string | string[] ): void {\r\n  forEach( keys || ownKeys( object ), key => {\r\n    delete object[ key ];\r\n  } );\r\n}","import { forEach } from '../../array';\r\n\r\n\r\n/**\r\n * Removes attributes from the element.\r\n *\r\n * @param elms  - An element or elements.\r\n * @param attrs - An attribute or attributes to remove.\r\n */\r\nexport function removeAttribute( elms: Element | Element[], attrs: string | string[] ): void {\r\n  forEach( elms, elm => {\r\n    forEach( attrs, attr => {\r\n      elm && elm.removeAttribute( attr );\r\n    } );\r\n  } );\r\n}\r\n","import { forEach } from '../../array';\r\nimport { forOwn } from '../../object';\r\nimport { isNull, isObject } from '../../type/type';\r\nimport { removeAttribute } from '../removeAttribute/removeAttribute';\r\n\r\n\r\nexport function setAttribute( elms: Element | Element[], attr: string, value: string | number | boolean ): void;\r\nexport function setAttribute( elms: Element | Element[], attrs: Record<string, string | number | boolean> ): void;\r\n\r\n/**\r\n * Sets attribute/attributes to the element or elements.\r\n * If the value is `null` or an empty string, the attribute will be removed.\r\n *\r\n * @param elms  - An element or an array with elements.\r\n * @param attrs - An attribute name of an object with pairs of a name and a value.\r\n * @param value - A value to set.\r\n */\r\nexport function setAttribute(\r\n  elms: Element | Element[],\r\n  attrs: string | Record<string, string | number | boolean>,\r\n  value?: string | number | boolean\r\n): void {\r\n  if ( isObject( attrs ) ) {\r\n    forOwn( attrs, ( value, name ) => {\r\n      setAttribute( elms, name, value );\r\n    } );\r\n  } else {\r\n    forEach( elms, elm => {\r\n      isNull( value ) || value === '' ? removeAttribute( elm, attrs ) : elm.setAttribute( attrs, String( value ) );\r\n    } );\r\n  }\r\n}\r\n","import { isString } from '../../type/type';\r\nimport { addClass } from '../addClass/addClass';\r\nimport { append } from '../append/append';\r\nimport { setAttribute } from '../setAttribute/setAttribute';\r\n\r\n\r\nexport function create<K extends keyof HTMLElementTagNameMap>(\r\n  tag: K,\r\n  attrs?: Record<string, string | number | boolean> | string,\r\n  parent?: HTMLElement\r\n): HTMLElementTagNameMap[ K ];\r\n\r\nexport function create(\r\n  tag: string,\r\n  attrs?: Record<string, string | number | boolean> | string,\r\n  parent?: HTMLElement\r\n): HTMLElement;\r\n\r\n/**\r\n * Creates a HTML element.\r\n *\r\n * @param tag    - A tag name.\r\n * @param attrs  - Optional. An object with attributes to apply the created element to, or a string with classes.\r\n * @param parent - Optional. A parent element where the created element is appended.\r\n */\r\nexport function create<K extends keyof HTMLElementTagNameMap>(\r\n  tag: K,\r\n  attrs?: Record<string, string | number | boolean> | string,\r\n  parent?: HTMLElement\r\n): HTMLElementTagNameMap[ K ] {\r\n  const elm = document.createElement( tag );\r\n\r\n  if ( attrs ) {\r\n    isString( attrs ) ? addClass( elm, attrs ) : setAttribute( elm, attrs );\r\n  }\r\n\r\n  parent && append( parent, elm );\r\n\r\n  return elm;\r\n}\r\n","import { isNull, isUndefined } from '../../type/type';\r\n\r\n\r\nexport function style<K extends keyof CSSStyleDeclaration>(\r\n  elm: HTMLElement,\r\n  prop: K,\r\n): CSSStyleDeclaration[ K ];\r\n\r\nexport function style(\r\n  elm: HTMLElement,\r\n  prop: string,\r\n): string;\r\n\r\nexport function style(\r\n  elm: HTMLElement,\r\n  prop: string,\r\n  value: string | number\r\n): void;\r\n\r\n\r\n/**\r\n * Applies inline styles to the provided element by an object literal.\r\n *\r\n * @param elm   - An element to apply styles to.\r\n * @param prop  - An object literal with styles or a property name.\r\n * @param value - A value to set.\r\n */\r\nexport function style(\r\n  elm: HTMLElement,\r\n  prop: string,\r\n  value?: string | number\r\n): string | void {\r\n  if ( isUndefined( value ) ) {\r\n    return getComputedStyle( elm )[ prop ];\r\n  }\r\n\r\n  if ( ! isNull( value ) ) {\r\n    elm.style[ prop ] = `${ value }`;\r\n  }\r\n}\r\n","import { style } from '../style/style';\r\n\r\n\r\n/**\r\n * Sets the `display` CSS value to the element.\r\n *\r\n * @param elm     - An element to set a new value to.\r\n * @param display - A new `display` value.\r\n */\r\nexport function display( elm: HTMLElement, display: string ): void {\r\n  style( elm, 'display', display );\r\n}\r\n","/**\r\n * Focuses the provided element without scrolling the ascendant element.\r\n *\r\n * @param elm - An element to focus.\r\n */\r\nexport function focus( elm: HTMLElement ): void {\r\n  elm[ 'setActive' ] && elm[ 'setActive' ]() || elm.focus( { preventScroll: true } );\r\n}\r\n","/**\r\n * Returns the specified attribute value.\r\n *\r\n * @param elm  - An element.\r\n * @param attr - An attribute to get.\r\n */\r\nexport function getAttribute( elm: Element, attr: string ): string | null {\r\n  return elm.getAttribute( attr );\r\n}\r\n","/**\r\n * Checks if the element contains the specified class or not.\r\n *\r\n * @param elm       - An element to check.\r\n * @param className - A class name that may be contained by the element.\r\n *\r\n * @return `true` if the element contains the class, or otherwise `false`.\r\n */\r\nexport function hasClass( elm: Element, className: string ): boolean {\r\n  return elm && elm.classList.contains( className );\r\n}\r\n","/**\r\n * Returns a DOMRect object of the provided element.\r\n *\r\n * @param target - An element.\r\n */\r\nexport function rect( target: Element ): DOMRect {\r\n  return target.getBoundingClientRect();\r\n}\r\n","import { forEach } from '../../array';\r\n\r\n\r\n/**\r\n * Removes the provided node from its parent.\r\n *\r\n * @param nodes - A node or nodes to remove.\r\n */\r\nexport function remove( nodes: Node | Node[] ): void {\r\n  forEach( nodes, node => {\r\n    if ( node && node.parentNode ) {\r\n      node.parentNode.removeChild( node );\r\n    }\r\n  } );\r\n}\r\n","import { child } from '../child/child';\r\n\r\n\r\n/**\r\n * Parses the provided HTML string and returns the first element.\r\n *\r\n * @param html - An HTML string to parse.\r\n *\r\n * @return An Element on success, or otherwise `undefined`.\r\n */\r\nexport function parseHtml<E extends HTMLElement>( html: string ): E | undefined {\r\n  return child<E>( new DOMParser().parseFromString( html, 'text/html' ).body );\r\n}\r\n","/**\r\n * Call the `preventDefault()` of the provided event.\r\n *\r\n * @param e               - An Event object.\r\n * @param stopPropagation - Optional. Whether to stop the event propagation or not.\r\n */\r\nexport function prevent( e: Event, stopPropagation?: boolean ): void {\r\n  e.preventDefault();\r\n\r\n  if ( stopPropagation ) {\r\n    e.stopPropagation();\r\n    e.stopImmediatePropagation();\r\n  }\r\n}\r\n","/**\r\n * Returns an element that matches the provided selector.\r\n *\r\n * @param parent   - A parent element to start searching from.\r\n * @param selector - A selector to query.\r\n *\r\n * @return A found element or `null`.\r\n */\r\nexport function query<E extends Element = Element>( parent: Element | Document, selector: string ): E | null {\r\n  return parent && parent.querySelector( selector );\r\n}\r\n","import { slice } from '../../arrayLike';\r\n\r\n\r\n/**\r\n * Returns elements that match the provided selector.\r\n *\r\n * @param parent   - A parent element to start searching from.\r\n * @param selector - A selector to query.\r\n *\r\n * @return An array with matched elements.\r\n */\r\nexport function queryAll<E extends Element = Element>( parent: Element | Document, selector?: string ): E[] {\r\n  return selector ? slice<E>( parent.querySelectorAll( selector ) ) : [];\r\n}\r\n","import { toggleClass } from '../toggleClass/toggleClass';\r\n\r\n\r\n/**\r\n * Removes classes from the element.\r\n *\r\n * @param elm     - An element to remove classes from.\r\n * @param classes - Classes to remove.\r\n */\r\nexport function removeClass( elm: Element, classes: string | string[] ): void {\r\n  toggleClass( elm, classes, false );\r\n}\r\n","/**\r\n * Extracts the timestamp from the event object.\r\n *\r\n * @param e - An Event object.\r\n */\r\nexport function timeOf( e: Event ): number {\r\n  return e.timeStamp;\r\n}","import { isString } from '../../type/type';\r\n\r\n\r\n/**\r\n * Appends `px` to the provided number.\r\n * If the value is already string, just returns it.\r\n *\r\n * @param value - A value to append `px` to.\r\n *\r\n * @return A string with the CSS unit.\r\n */\r\nexport function unit( value: number | string ): string {\r\n  return isString( value ) ? value : value ? `${ value }px` : '';\r\n}\r\n","/**\r\n * The project code.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport const PROJECT_CODE = 'splide';\r\n\r\n/**\r\n * The data attribute prefix.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport const DATA_ATTRIBUTE = `data-${ PROJECT_CODE }`;\r\n","import { PROJECT_CODE } from '../../../constants/project';\r\n\r\n\r\n/**\r\n * Throws an error if the provided condition is falsy.\r\n *\r\n * @param condition - If falsy, an error is thrown.\r\n * @param message   - Optional. A message to display.\r\n */\r\nexport function assert( condition: any, message?: string ): void {\r\n  if ( ! condition ) {\r\n    throw new Error( `[${ PROJECT_CODE }] ${ message || '' }` );\r\n  }\r\n}\r\n","export const { min, max, floor, ceil, abs } = Math;\r\n","import { abs } from '../math/math';\r\n\r\n\r\n/**\r\n * Checks if the provided 2 numbers are approximately equal or not.\r\n *\r\n * @param x       - A number.\r\n * @param y       - Another number to compare.\r\n * @param epsilon - An accuracy that defines the approximation.\r\n *\r\n * @return `true` if 2 numbers are considered to be equal, or otherwise `false`.\r\n */\r\nexport function approximatelyEqual( x: number, y: number, epsilon: number ): boolean {\r\n  return abs( x - y ) < epsilon;\r\n}\r\n","import { max, min } from '../math/math';\r\n\r\n\r\n/**\r\n * Checks if the subject number is between `x` and `y`.\r\n *\r\n * @param number    - A subject number to check.\r\n * @param x         - A min or max number.\r\n * @param y         - A max or min number.\r\n * @param exclusive - Optional. Whether to exclude `x` or `y`.\r\n */\r\nexport function between( number: number, x: number, y: number, exclusive?: boolean ): boolean {\r\n  const minimum = min( x, y );\r\n  const maximum = max( x, y );\r\n  return exclusive\r\n    ? minimum < number && number < maximum\r\n    : minimum <= number && number <= maximum;\r\n}\r\n","import { max, min } from '../math/math';\r\n\r\n\r\n/**\r\n * Clamps a number.\r\n *\r\n * @param number - A subject number to check.\r\n * @param x      - A min or max number.\r\n * @param y      - A min or max number.\r\n *\r\n * @return A clamped number.\r\n */\r\nexport function clamp( number: number, x: number, y: number ): number {\r\n  const minimum = min( x, y );\r\n  const maximum = max( x, y );\r\n  return min( max( minimum, number ), maximum );\r\n}\r\n","/**\r\n * Returns the sign of the provided number.\r\n *\r\n * @param x - A number.\r\n *\r\n * @return `1` for positive numbers, `-1` for negative numbers, or `0` for `0`.\r\n */\r\nexport function sign( x: number ): number {\r\n  return +( x > 0 ) - +( x < 0 );\r\n}\r\n","import { forEach } from '../../array';\r\n\r\n\r\n/**\r\n * Formats a string.\r\n *\r\n * @param string       - A string to format.\r\n * @param replacements - A replacement or replacements.\r\n *\r\n * @return A formatted string.\r\n */\r\nexport function format( string: string, replacements: string | number | Array<string | number> ): string {\r\n  forEach( replacements, replacement => {\r\n    string = string.replace( '%s', `${ replacement }` );\r\n  } );\r\n\r\n  return string;\r\n}\r\n","/**\r\n * Pads the number with 0.\r\n *\r\n * @param number - A number to pad.\r\n *\r\n * @return string - Padded number.\r\n */\r\nexport function pad( number: number ): string {\r\n  return number < 10 ? `0${ number }` : `${ number }`;\r\n}\r\n","import { pad } from '../pad/pad';\r\n\r\n\r\n/**\r\n * Stores unique IDs.\r\n *\r\n * @since 3.0.0\r\n */\r\nconst ids: Record<string, number> = {};\r\n\r\n/**\r\n * Returns a sequential unique ID as \"{ prefix }-{ number }\".\r\n *\r\n * @param prefix - A prefix for the ID.\r\n */\r\nexport function uniqueId( prefix: string ): string {\r\n  return `${ prefix }${ pad( ( ids[ prefix ] = ( ids[ prefix ] || 0 ) + 1 ) ) }`;\r\n}\r\n","import { AnyFunction } from '../../types';\r\nimport { empty, forEach } from '../../utils';\r\n\r\n\r\n/**\r\n * The type for an EventTarget or an array with EventTarget objects.\r\n *\r\n * @since 4.0.0\r\n */\r\ntype EventTargets = EventTarget | EventTarget[];\r\n\r\n/**\r\n * The interface for the EventBinder object.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport interface EventBinderObject {\r\n  bind( target: EventTargets, events: string | string[], callback: AnyFunction, options?: AddEventListenerOptions ): void\r\n  unbind( target: EventTarget | EventTarget[], events: string | string[], callback?: AnyFunction ): void;\r\n  dispatch<T>( target: EventTarget, event: string, detail?: T ): void;\r\n  destroy(): void;\r\n}\r\n\r\n/**\r\n * The constructor function to provide methods to subscribe native events.\r\n *\r\n * @since 4.0.0\r\n * @constructor\r\n *\r\n * @return An EventBinder object.\r\n */\r\nexport function EventBinder(): EventBinderObject {\r\n  /**\r\n   * Stores all handlers that listen to native events.\r\n   * `[ target, event, namespace, callback, remover ]`\r\n   */\r\n  let listeners: [ EventTarget, string, string | undefined, AnyFunction, () => void ][] = [];\r\n\r\n  /**\r\n   * Listens to native events.\r\n   * - `destroy()` can unsubscribe all events.\r\n   * - In IE, mediaQueryList does not inherit EventTarget,\r\n   *   and only supports deprecated `addListener` and `removeListener`.\r\n   *\r\n   * @link https://developer.mozilla.org/en-US/docs/Web/API/MediaQueryList/addListener\r\n   *\r\n   * @param targets  - A target element, the window object or the document object.\r\n   * @param events   - An event or events to listen to.\r\n   * @param callback - A callback function.\r\n   * @param options  - Optional. The options to pass to the `addEventListener` function.\r\n   */\r\n  function bind(\r\n    targets: EventTargets,\r\n    events: string | string[],\r\n    callback: AnyFunction,\r\n    options?: AddEventListenerOptions\r\n  ): void {\r\n    forEachEvent( targets, events, ( target, event, namespace ) => {\r\n      const isEventTarget = 'addEventListener' in target;\r\n      const remover = isEventTarget\r\n        ? target.removeEventListener.bind( target, event, callback, options )\r\n        : target[ 'removeListener' ].bind( target, callback );\r\n\r\n      isEventTarget ? target.addEventListener( event, callback, options ) : target[ 'addListener' ]( callback );\r\n      listeners.push( [ target, event, namespace, callback, remover ] );\r\n    } );\r\n  }\r\n\r\n  /**\r\n   * Removes the event handler.\r\n   *\r\n   * @param targets  - A target element, the window object or the document object.\r\n   * @param events   - An event name or names to remove.\r\n   * @param callback - Optional. Specify the callback to remove.\r\n   */\r\n  function unbind( targets: EventTargets, events: string | string[], callback?: AnyFunction ): void {\r\n    forEachEvent( targets, events, ( target, event, namespace ) => {\r\n      listeners = listeners.filter( listener => {\r\n        if ( listener[ 0 ] === target\r\n          && listener[ 1 ] === event\r\n          && listener[ 2 ] === namespace\r\n          && ( ! callback || listener[ 3 ] === callback )\r\n        ) {\r\n          listener[ 4 ]();\r\n          return false;\r\n        }\r\n\r\n        return true;\r\n      } );\r\n    } );\r\n  }\r\n\r\n  /**\r\n   * Dispatches a custom event of the target.\r\n   *\r\n   * @param target - An event target.\r\n   * @param type   - An event type.\r\n   * @param detail - Optional. The `detail` object of the event.\r\n   *\r\n   * @return An event object.\r\n   */\r\n  function dispatch<T>( target: EventTarget, type: string, detail?: T ): CustomEvent {\r\n    let e: CustomEvent;\r\n    const bubbles = true;\r\n\r\n    if ( typeof CustomEvent === 'function' ) {\r\n      e = new CustomEvent( type, { bubbles, detail } );\r\n    } else {\r\n      e = document.createEvent( 'CustomEvent' );\r\n      e.initCustomEvent( type, bubbles, false, detail );\r\n    }\r\n\r\n    target.dispatchEvent( e );\r\n    return e;\r\n  }\r\n\r\n  /**\r\n   * Iterates over each target and event.\r\n   *\r\n   * @param targets  - A target element, the window object or the document object.\r\n   * @param events   - An event name or names.\r\n   * @param iteratee - An iteratee function.\r\n   */\r\n  function forEachEvent(\r\n    targets: EventTargets,\r\n    events: string | string[],\r\n    iteratee: ( target: EventTarget, event: string, namespace: string | undefined ) => void\r\n  ): void {\r\n    forEach( targets, target => {\r\n      target && forEach( events, events => {\r\n        events.split( ' ' ).forEach( eventNS => {\r\n          const fragment = eventNS.split( '.' );\r\n          iteratee( target, fragment[ 0 ], fragment[ 1 ] );\r\n        } );\r\n      } );\r\n    } );\r\n  }\r\n\r\n  /**\r\n   * Removes all listeners.\r\n   */\r\n  function destroy(): void {\r\n    listeners.forEach( data => { data[ 4 ]() } );\r\n    empty( listeners );\r\n  }\r\n\r\n  return {\r\n    bind,\r\n    unbind,\r\n    dispatch,\r\n    destroy,\r\n  };\r\n}\r\n","export const EVENT_MOUNTED            = 'mounted';\r\nexport const EVENT_READY              = 'ready';\r\nexport const EVENT_MOVE               = 'move';\r\nexport const EVENT_MOVED              = 'moved';\r\nexport const EVENT_CLICK              = 'click';\r\nexport const EVENT_ACTIVE             = 'active';\r\nexport const EVENT_INACTIVE           = 'inactive';\r\nexport const EVENT_VISIBLE            = 'visible';\r\nexport const EVENT_HIDDEN             = 'hidden';\r\nexport const EVENT_REFRESH            = 'refresh';\r\nexport const EVENT_UPDATED            = 'updated';\r\nexport const EVENT_RESIZE             = 'resize';\r\nexport const EVENT_RESIZED            = 'resized';\r\nexport const EVENT_DRAG               = 'drag';\r\nexport const EVENT_DRAGGING           = 'dragging';\r\nexport const EVENT_DRAGGED            = 'dragged';\r\nexport const EVENT_SCROLL             = 'scroll';\r\nexport const EVENT_SCROLLED           = 'scrolled';\r\nexport const EVENT_OVERFLOW           = 'overflow';\r\nexport const EVENT_DESTROY            = 'destroy';\r\nexport const EVENT_ARROWS_MOUNTED     = 'arrows:mounted';\r\nexport const EVENT_ARROWS_UPDATED     = 'arrows:updated';\r\nexport const EVENT_PAGINATION_MOUNTED = 'pagination:mounted';\r\nexport const EVENT_PAGINATION_UPDATED = 'pagination:updated';\r\nexport const EVENT_NAVIGATION_MOUNTED = 'navigation:mounted';\r\nexport const EVENT_AUTOPLAY_PLAY      = 'autoplay:play';\r\nexport const EVENT_AUTOPLAY_PLAYING   = 'autoplay:playing';\r\nexport const EVENT_AUTOPLAY_PAUSE     = 'autoplay:pause';\r\nexport const EVENT_LAZYLOAD_LOADED    = 'lazyload:loaded';\r\n\r\n/** @internal */\r\nexport const EVENT_SLIDE_KEYDOWN     = 'sk';\r\nexport const EVENT_SHIFTED           = 'sh';\r\nexport const EVENT_END_INDEX_CHANGED = 'ei';\r\n","import { EVENT_DESTROY } from '../../constants/events';\r\nimport { Splide } from '../../core/Splide/Splide';\r\nimport { AnyFunction, EventMap } from '../../types';\r\nimport { apply, assign, isArray, slice, toArray } from '../../utils';\r\nimport { EventBinder, EventBinderObject } from '../EventBinder/EventBinder';\r\n\r\n\r\n/**\r\n * The interface for the EventInterface object.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport interface EventInterfaceObject extends EventBinderObject {\r\n  on<K extends keyof EventMap>( event: K, callback: EventMap[ K ] ): void;\r\n  on( events: string | string[], callback: AnyFunction ): void;\r\n  off<K extends keyof EventMap>( events: K | K[] | string | string[] ): void;\r\n  emit<K extends keyof EventMap>( event: K, ...args: Parameters<EventMap[ K ]> ): void\r\n  emit( event: string, ...args: any[] ): void;\r\n\r\n  /** @internal */\r\n  bus: DocumentFragment;\r\n}\r\n\r\n/**\r\n * The constructor function that provides interface for internal and native events.\r\n *\r\n * @since 3.0.0\r\n * @constructor\r\n *\r\n * @param Splide - A Splide instance.\r\n *\r\n * @return A collection of interface functions.\r\n */\r\nexport function EventInterface( Splide?: Splide ): EventInterfaceObject {\r\n  /**\r\n   * The document fragment for internal events.\r\n   * Provide the Splide instance to share the bus.\r\n   */\r\n  const bus = Splide ? Splide.event.bus : document.createDocumentFragment();\r\n\r\n  /**\r\n   * An event binder object.\r\n   */\r\n  const binder = EventBinder();\r\n\r\n  /**\r\n   * Listens to an internal event or events.\r\n   *\r\n   * @param events   - An event name or names separated by spaces. Use a dot(.) to add a namespace.\r\n   * @param callback - A callback function to register.\r\n   */\r\n  function on( events: string | string[], callback: AnyFunction ): void {\r\n    binder.bind( bus, toArray( events ).join( ' ' ), e => {\r\n      callback.apply( callback, isArray( e.detail ) ? e.detail : [] );\r\n    } );\r\n  }\r\n\r\n  /**\r\n   * Triggers callback functions.\r\n   * This accepts additional arguments and passes them to callbacks.\r\n   *\r\n   * @param event - An event name.\r\n   */\r\n  function emit( event: string ): void {\r\n    // eslint-disable-next-line prefer-rest-params, prefer-spread\r\n    binder.dispatch( bus, event, slice( arguments, 1 ) );\r\n  }\r\n\r\n  if ( Splide ) {\r\n    Splide.event.on( EVENT_DESTROY, binder.destroy );\r\n  }\r\n\r\n  return assign( binder, {\r\n    bus,\r\n    on,\r\n    off: apply( binder.unbind, bus ),\r\n    emit,\r\n  } );\r\n}","import { min, raf } from '../../utils';\r\n\r\n\r\n/**\r\n * The interface for the returning value of the RequestInterval.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport interface RequestIntervalInterface {\r\n  start( resume?: boolean ): void;\r\n  pause(): void;\r\n  rewind(): void;\r\n  cancel(): void;\r\n  set( interval: number ): void;\r\n  isPaused(): boolean;\r\n}\r\n\r\n/**\r\n * Requests interval like the native `setInterval()` with using `requestAnimationFrame`.\r\n *\r\n * @since 3.0.0\r\n *\r\n * @param interval   - The interval duration in milliseconds.\r\n * @param onInterval - The callback fired on every interval.\r\n * @param onUpdate   - Optional. Called on every animation frame, taking the progress rate.\r\n * @param limit      - Optional. Limits the number of interval.\r\n */\r\nexport function RequestInterval(\r\n  interval: number,\r\n  onInterval: () => void,\r\n  onUpdate?: ( rate: number ) => void,\r\n  limit?: number\r\n): RequestIntervalInterface {\r\n  const { now } = Date;\r\n\r\n  /**\r\n   * The time when the interval starts.\r\n   */\r\n  let startTime: number;\r\n\r\n  /**\r\n   * The current progress rate.\r\n   */\r\n  let rate = 0;\r\n\r\n  /**\r\n   * The animation frame ID.\r\n   */\r\n  let id: number;\r\n\r\n  /**\r\n   * Indicates whether the interval is currently paused or not.\r\n   */\r\n  let paused = true;\r\n\r\n  /**\r\n   * The loop count. This only works when the `limit` argument is provided.\r\n   */\r\n  let count = 0;\r\n\r\n  /**\r\n   * The update function called on every animation frame.\r\n   */\r\n  function update(): void {\r\n    if ( ! paused ) {\r\n      rate = interval ? min( ( now() - startTime ) / interval, 1 ) : 1;\r\n      onUpdate && onUpdate( rate );\r\n\r\n      if ( rate >= 1 ) {\r\n        onInterval();\r\n        startTime = now();\r\n\r\n        if ( limit && ++count >= limit ) {\r\n          return pause();\r\n        }\r\n      }\r\n\r\n      id = raf( update );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Starts the interval.\r\n   *\r\n   * @param resume - Optional. Whether to resume the paused progress or not.\r\n   */\r\n  function start( resume?: boolean ): void {\r\n    resume || cancel();\r\n    startTime = now() - ( resume ? rate * interval : 0 );\r\n    paused    = false;\r\n    id        = raf( update );\r\n  }\r\n\r\n  /**\r\n   * Pauses the interval.\r\n   */\r\n  function pause(): void {\r\n    paused = true;\r\n  }\r\n\r\n  /**\r\n   * Rewinds the current progress.\r\n   */\r\n  function rewind(): void {\r\n    startTime = now();\r\n    rate      = 0;\r\n\r\n    if ( onUpdate ) {\r\n      onUpdate( rate );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Cancels the interval.\r\n   */\r\n  function cancel() {\r\n    id && cancelAnimationFrame( id );\r\n    rate   = 0;\r\n    id     = 0;\r\n    paused = true;\r\n  }\r\n\r\n  /**\r\n   * Sets new interval duration.\r\n   *\r\n   * @param time - The interval duration in milliseconds.\r\n   */\r\n  function set( time: number ): void {\r\n    interval = time;\r\n  }\r\n\r\n  /**\r\n   * Checks if the interval is paused or not.\r\n   *\r\n   * @return `true` if the interval is paused, or otherwise `false`.\r\n   */\r\n  function isPaused(): boolean {\r\n    return paused;\r\n  }\r\n\r\n  return {\r\n    start,\r\n    rewind,\r\n    pause,\r\n    cancel,\r\n    set,\r\n    isPaused,\r\n  };\r\n}\r\n","import { includes, toArray } from '../../utils';\r\n\r\n\r\n/**\r\n * The interface for the State object.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport interface StateObject {\r\n  set( state: number ): void;\r\n  is( states: number | number[] ): boolean;\r\n}\r\n\r\n/**\r\n * The function providing a super simple state system.\r\n *\r\n * @param initialState - Specifies the initial state.\r\n */\r\nexport function State( initialState: number ): StateObject {\r\n  /**\r\n   * The current state.\r\n   */\r\n  let state = initialState;\r\n\r\n  /**\r\n   * Sets a new state.\r\n   *\r\n   * @param value - A new state value.\r\n   */\r\n  function set( value: number ): void {\r\n    state = value;\r\n  }\r\n\r\n  /**\r\n   * Checks if the current state matches the provided one.\r\n   *\r\n   * @param states - A state to check.\r\n   *\r\n   * @return `true` if the current state is the provided one.\r\n   */\r\n  function is( states: number | number[] ): boolean {\r\n    return includes( toArray( states ), state );\r\n  }\r\n\r\n  return { set, is };\r\n}\r\n","const ARROW = 'Arrow';\r\nexport const ARROW_LEFT  = `${ ARROW }Left`;\r\nexport const ARROW_RIGHT = `${ ARROW }Right`;\r\nexport const ARROW_UP    = `${ ARROW }Up`;\r\nexport const ARROW_DOWN  = `${ ARROW }Down`;","/**\r\n * Enumerates slides from left to right.\r\n */\r\nexport const LTR = 'ltr';\r\n\r\n/**\r\n * Enumerates slides from right to left.\r\n */\r\nexport const RTL = 'rtl';\r\n\r\n/**\r\n * Enumerates slides in a col.\r\n */\r\nexport const TTB = 'ttb';\r\n","import { ARROW_DOWN, ARROW_LEFT, ARROW_RIGHT, ARROW_UP } from '../../constants/arrows';\r\nimport { RTL, TTB } from '../../constants/directions';\r\nimport { Splide } from '../../core/Splide/Splide';\r\nimport { BaseComponent, Components, Options } from '../../types';\r\n\r\n\r\n/**\r\n * The interface for the Direction component.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport interface DirectionComponent extends BaseComponent {\r\n  resolve( prop: string, axisOnly?: boolean, direction?: Options['direction'] ): string;\r\n  orient( value: number ): number;\r\n}\r\n\r\n/**\r\n * The translation map for directions.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport const ORIENTATION_MAP = {\r\n  width     : [ 'height' ],\r\n  left      : [ 'top', 'right' ],\r\n  right     : [ 'bottom', 'left' ],\r\n  x         : [ 'y' ],\r\n  X         : [ 'Y' ],\r\n  Y         : [ 'X' ],\r\n  ArrowLeft : [ ARROW_UP, ARROW_RIGHT ],\r\n  ArrowRight: [ ARROW_DOWN, ARROW_LEFT ],\r\n};\r\n\r\n/**\r\n * The component that absorbs the difference among directions.\r\n *\r\n * @since 3.0.0\r\n *\r\n * @param Splide     - A Splide instance.\r\n * @param Components - A collection of components.\r\n * @param options    - Options.\r\n *\r\n * @return A Direction component object.\r\n */\r\nexport function Direction( Splide: Splide, Components: Components, options: Options ): DirectionComponent {\r\n  /**\r\n   * Resolves the provided property name.\r\n   *\r\n   * @param prop      - A property name to translate.\r\n   * @param axisOnly  - Optional. If `ture`, returns the same property for LTR and RTL.\r\n   * @param direction - Optional. Specify the direction. The default value is the `direction` option.\r\n   */\r\n  function resolve( prop: string, axisOnly?: boolean, direction?: Options['direction'] ): string {\r\n    direction = direction || options.direction;\r\n    const index = direction === RTL && ! axisOnly ? 1 : direction === TTB ? 0 : -1;\r\n\r\n    return ORIENTATION_MAP[ prop ] && ORIENTATION_MAP[ prop ][ index ]\r\n      || prop.replace( /width|left|right/i, ( match, offset ) => {\r\n        const replacement = ORIENTATION_MAP[ match.toLowerCase() ][ index ] || match;\r\n        return offset > 0 ? replacement.charAt( 0 ).toUpperCase() + replacement.slice( 1 ) : replacement;\r\n      } );\r\n  }\r\n\r\n  /**\r\n   * Orients the value towards the current direction.\r\n   *\r\n   * @param value - A value to orient.\r\n   *\r\n   * @return The oriented value.\r\n   */\r\n  function orient( value: number ): number {\r\n    return value * ( options.direction === RTL ? 1 : -1 );\r\n  }\r\n\r\n  return {\r\n    resolve,\r\n    orient,\r\n  };\r\n}\r\n","export const ROLE      = 'role';\r\nexport const TAB_INDEX = 'tabindex';\r\nexport const DISABLED  = 'disabled';\r\n\r\nexport const ARIA_PREFIX          = 'aria-';\r\nexport const ARIA_CONTROLS        = `${ ARIA_PREFIX }controls`;\r\nexport const ARIA_CURRENT         = `${ ARIA_PREFIX }current`;\r\nexport const ARIA_SELECTED        = `${ ARIA_PREFIX }selected`;\r\nexport const ARIA_LABEL           = `${ ARIA_PREFIX }label`;\r\nexport const ARIA_LABELLEDBY      = `${ ARIA_PREFIX }labelledby`;\r\nexport const ARIA_HIDDEN          = `${ ARIA_PREFIX }hidden`;\r\nexport const ARIA_ORIENTATION     = `${ ARIA_PREFIX }orientation`;\r\nexport const ARIA_ROLEDESCRIPTION = `${ ARIA_PREFIX }roledescription`;\r\nexport const ARIA_LIVE            = `${ ARIA_PREFIX }live`;\r\nexport const ARIA_BUSY            = `${ ARIA_PREFIX }busy`;\r\nexport const ARIA_ATOMIC          = `${ ARIA_PREFIX }atomic`;\r\n\r\n/**\r\n * The array with all attributes to remove later.\r\n * Need to manually remove attributes that are not in this.\r\n * Note that removing `aria-live` disables the live region until the page reload.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport const ALL_ATTRIBUTES = [\r\n  ROLE,\r\n  TAB_INDEX,\r\n  DISABLED,\r\n  ARIA_CONTROLS,\r\n  ARIA_CURRENT,\r\n  ARIA_LABEL,\r\n  ARIA_LABELLEDBY,\r\n  ARIA_HIDDEN,\r\n  ARIA_ORIENTATION,\r\n  ARIA_ROLEDESCRIPTION,\r\n];\r\n","import { PROJECT_CODE } from './project';\r\n\r\n/**\r\n * The prefix for classes.\r\n *\r\n * @since 4.1.0\r\n */\r\nconst CLASS_PREFIX = `${ PROJECT_CODE }__`;\r\n\r\n/**\r\n * The prefix for status classes.\r\n *\r\n * @since 4.1.0\r\n */\r\nconst STATUS_CLASS_PREFIX = 'is-';\r\n\r\n/**\r\n * All classes as constants.\r\n */\r\nexport const CLASS_ROOT            = PROJECT_CODE;\r\nexport const CLASS_TRACK           = `${ CLASS_PREFIX }track`;\r\nexport const CLASS_LIST            = `${ CLASS_PREFIX }list`;\r\nexport const CLASS_SLIDE           = `${ CLASS_PREFIX }slide`;\r\nexport const CLASS_CLONE           = `${ CLASS_SLIDE }--clone`;\r\nexport const CLASS_CONTAINER       = `${ CLASS_SLIDE }__container`;\r\nexport const CLASS_ARROWS          = `${ CLASS_PREFIX }arrows`;\r\nexport const CLASS_ARROW           = `${ CLASS_PREFIX }arrow`;\r\nexport const CLASS_ARROW_PREV      = `${ CLASS_ARROW }--prev`;\r\nexport const CLASS_ARROW_NEXT      = `${ CLASS_ARROW }--next`;\r\nexport const CLASS_PAGINATION      = `${ CLASS_PREFIX }pagination`;\r\nexport const CLASS_PAGINATION_PAGE = `${ CLASS_PAGINATION }__page`;\r\nexport const CLASS_PROGRESS        = `${ CLASS_PREFIX }progress`;\r\nexport const CLASS_PROGRESS_BAR    = `${ CLASS_PROGRESS }__bar`;\r\nexport const CLASS_TOGGLE          = `${ CLASS_PREFIX }toggle`;\r\nexport const CLASS_TOGGLE_PLAY     = `${ CLASS_TOGGLE }__play`;\r\nexport const CLASS_TOGGLE_PAUSE    = `${ CLASS_TOGGLE }__pause`;\r\nexport const CLASS_SPINNER         = `${ CLASS_PREFIX }spinner`;\r\nexport const CLASS_SR              = `${ CLASS_PREFIX }sr`;\r\nexport const CLASS_INITIALIZED     = `${ STATUS_CLASS_PREFIX }initialized`;\r\nexport const CLASS_ACTIVE          = `${ STATUS_CLASS_PREFIX }active`;\r\nexport const CLASS_PREV            = `${ STATUS_CLASS_PREFIX }prev`;\r\nexport const CLASS_NEXT            = `${ STATUS_CLASS_PREFIX }next`;\r\nexport const CLASS_VISIBLE         = `${ STATUS_CLASS_PREFIX }visible`;\r\nexport const CLASS_LOADING         = `${ STATUS_CLASS_PREFIX }loading`;\r\nexport const CLASS_FOCUS_IN        = `${ STATUS_CLASS_PREFIX }focus-in`;\r\nexport const CLASS_OVERFLOW        = `${ STATUS_CLASS_PREFIX }overflow`;\r\n\r\n/**\r\n * The array with all status classes except for `is-initialized`.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport const STATUS_CLASSES = [\r\n  CLASS_ACTIVE,\r\n  CLASS_VISIBLE,\r\n  CLASS_PREV,\r\n  CLASS_NEXT,\r\n  CLASS_LOADING,\r\n  CLASS_FOCUS_IN,\r\n  CLASS_OVERFLOW,\r\n];\r\n\r\n/**\r\n * The collection of classes for elements that Splide dynamically creates.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport const CLASSES = {\r\n  slide     : CLASS_SLIDE,\r\n  clone     : CLASS_CLONE,\r\n  arrows    : CLASS_ARROWS,\r\n  arrow     : CLASS_ARROW,\r\n  prev      : CLASS_ARROW_PREV,\r\n  next      : CLASS_ARROW_NEXT,\r\n  pagination: CLASS_PAGINATION,\r\n  page      : CLASS_PAGINATION_PAGE,\r\n  spinner   : CLASS_SPINNER,\r\n};\r\n","/**\r\n * The power of the friction.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport const FRICTION = 5;\r\n\r\n/**\r\n * If the user stops dragging for this duration with keeping the pointer down, updates the base coord and time.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport const LOG_INTERVAL = 200;\r\n\r\n/**\r\n * Start events for dragging.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport const POINTER_DOWN_EVENTS = 'touchstart mousedown';\r\n\r\n/**\r\n * Update events for dragging.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport const POINTER_MOVE_EVENTS = 'touchmove mousemove';\r\n\r\n/**\r\n * End events for dragging.\r\n * The `click` event is required because the browser sometimes dispatches `drag` events instead of `mouse`.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport const POINTER_UP_EVENTS = 'touchend touchcancel mouseup click';\r\n","/**\r\n * The type for the regular slider.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport const SLIDE = 'slide';\r\n\r\n/**\r\n * The type for the carousel slider.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport const LOOP = 'loop';\r\n\r\n/**\r\n * The type for the fade slider that can not have multiple slides in a page.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport const FADE = 'fade';\r\n","import {\r\n  ALL_ATTRIBUTES,\r\n  ARIA_CONTROLS,\r\n  ARIA_CURRENT,\r\n  ARIA_HIDDEN,\r\n  ARIA_LABEL,\r\n  ARIA_ROLEDESCRIPTION,\r\n  ROLE,\r\n  TAB_INDEX,\r\n} from '../../constants/attributes';\r\nimport {\r\n  CLASS_ACTIVE,\r\n  CLASS_CONTAINER,\r\n  CLASS_NEXT,\r\n  CLASS_PREV,\r\n  CLASS_VISIBLE,\r\n  STATUS_CLASSES,\r\n} from '../../constants/classes';\r\nimport {\r\n  EVENT_ACTIVE,\r\n  EVENT_CLICK,\r\n  EVENT_HIDDEN,\r\n  EVENT_INACTIVE,\r\n  EVENT_MOVE,\r\n  EVENT_MOVED,\r\n  EVENT_NAVIGATION_MOUNTED,\r\n  EVENT_SCROLLED,\r\n  EVENT_SHIFTED,\r\n  EVENT_SLIDE_KEYDOWN,\r\n  EVENT_VISIBLE,\r\n} from '../../constants/events';\r\nimport { MOVING, SCROLLING } from '../../constants/states';\r\nimport { FADE, LOOP } from '../../constants/types';\r\nimport { EventInterface } from '../../constructors';\r\nimport { Splide } from '../../core/Splide/Splide';\r\nimport { BaseComponent } from '../../types';\r\nimport {\r\n  abs,\r\n  apply,\r\n  ceil,\r\n  child,\r\n  floor,\r\n  focus,\r\n  format,\r\n  getAttribute,\r\n  hasClass,\r\n  min,\r\n  pad,\r\n  queryAll,\r\n  rect,\r\n  removeAttribute,\r\n  removeClass,\r\n  setAttribute,\r\n  style as _style,\r\n  toggleClass,\r\n} from '../../utils';\r\n\r\n\r\n/**\r\n * The interface for the Slide sub component.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport interface  SlideComponent extends BaseComponent {\r\n  index: number;\r\n  slideIndex: number;\r\n  slide: HTMLElement;\r\n  container: HTMLElement;\r\n  isClone: boolean;\r\n  update(): void;\r\n  style( prop: string, value: string | number, useContainer?: boolean ): void\r\n  isWithin( from: number, distance: number ): boolean;\r\n}\r\n\r\n/**\r\n * The subcomponent for managing each slide.\r\n *\r\n * @since 3.0.0\r\n *\r\n * @param Splide     - A Splide instance.\r\n * @param index      - A slide index.\r\n * @param slideIndex - A slide index for clones. This must be `-1` if the slide is not a clone.\r\n * @param slide      - A slide element.\r\n *\r\n * @return A Slide subcomponent.\r\n */\r\nexport function Slide( Splide: Splide, index: number, slideIndex: number, slide: HTMLElement ): SlideComponent {\r\n  const event = EventInterface( Splide );\r\n  const { on, emit, bind } = event;\r\n  const { Components, root, options } = Splide;\r\n  const { isNavigation, updateOnMove, i18n, pagination, slideFocus } = options;\r\n  const { resolve } = Components.Direction;\r\n  const styles    = getAttribute( slide, 'style' );\r\n  const label     = getAttribute( slide, ARIA_LABEL );\r\n  const isClone   = slideIndex > -1;\r\n  const container = child( slide, `.${ CLASS_CONTAINER }` );\r\n\r\n  /**\r\n   * Turns into `true` when the component is destroyed.\r\n   */\r\n  let destroyed: boolean;\r\n\r\n  /**\r\n   * Called when the component is mounted.\r\n   */\r\n  function mount( this: SlideComponent ): void {\r\n    if ( ! isClone ) {\r\n      slide.id = `${ root.id }-slide${ pad( index + 1 ) }`;\r\n      setAttribute( slide, ROLE, pagination ? 'tabpanel' : 'group' );\r\n      setAttribute( slide, ARIA_ROLEDESCRIPTION, i18n.slide );\r\n      setAttribute( slide, ARIA_LABEL, label || format( i18n.slideLabel, [ index + 1, Splide.length ] ) );\r\n    }\r\n\r\n    listen();\r\n  }\r\n\r\n  /**\r\n   * Listens to some events.\r\n   */\r\n  function listen(): void {\r\n    bind( slide, 'click', apply( emit, EVENT_CLICK, self ) );\r\n    bind( slide, 'keydown', apply( emit, EVENT_SLIDE_KEYDOWN, self ) );\r\n    on( [ EVENT_MOVED, EVENT_SHIFTED, EVENT_SCROLLED ], update );\r\n    on( EVENT_NAVIGATION_MOUNTED, initNavigation );\r\n\r\n    if ( updateOnMove ) {\r\n      on( EVENT_MOVE, onMove );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Destroys the component.\r\n   */\r\n  function destroy(): void {\r\n    destroyed = true;\r\n    event.destroy();\r\n    removeClass( slide, STATUS_CLASSES );\r\n    removeAttribute( slide, ALL_ATTRIBUTES );\r\n    setAttribute( slide, 'style', styles );\r\n    setAttribute( slide, ARIA_LABEL, label || '' );\r\n  }\r\n\r\n  /**\r\n   * Initializes slides as navigation.\r\n   */\r\n  function initNavigation(): void {\r\n    const controls = Splide.splides.map( target => {\r\n      const Slide = target.splide.Components.Slides.getAt( index );\r\n      return Slide ? Slide.slide.id : '';\r\n    } ).join( ' ' );\r\n\r\n    setAttribute( slide, ARIA_LABEL, format( i18n.slideX, ( isClone ? slideIndex : index ) + 1 ) );\r\n    setAttribute( slide, ARIA_CONTROLS, controls );\r\n    setAttribute( slide, ROLE, slideFocus ? 'button' : '' );\r\n    slideFocus && removeAttribute( slide, ARIA_ROLEDESCRIPTION );\r\n  }\r\n\r\n  /**\r\n   * If the `updateOnMove` option is `true`, called when the slider starts moving.\r\n   */\r\n  function onMove(): void {\r\n    if ( ! destroyed ) {\r\n      update();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Updates attribute and classes of the slide.\r\n   */\r\n  function update(): void {\r\n    if ( ! destroyed ) {\r\n      const { index: curr } = Splide;\r\n\r\n      updateActivity();\r\n      updateVisibility();\r\n      toggleClass( slide, CLASS_PREV, index === curr - 1 );\r\n      toggleClass( slide, CLASS_NEXT, index === curr + 1 );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Updates the status related with activity.\r\n   */\r\n  function updateActivity(): void {\r\n    const active = isActive();\r\n\r\n    if ( active !== hasClass( slide, CLASS_ACTIVE ) ) {\r\n      toggleClass( slide, CLASS_ACTIVE, active );\r\n      setAttribute( slide, ARIA_CURRENT, isNavigation && active || '' );\r\n      emit( active ? EVENT_ACTIVE : EVENT_INACTIVE, self );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Updates classes and attributes related with visibility.\r\n   * - Do not update aria-hidden on shifting to avoid Window Narrator from start reading contents.\r\n   * - If the slide has focus and gets hidden, moves focus to the active slide.\r\n   */\r\n  function updateVisibility(): void {\r\n    const visible = isVisible();\r\n    const hidden = ! visible && ( ! isActive() || isClone );\r\n\r\n    if ( ! Splide.state.is( [ MOVING, SCROLLING ] ) ) {\r\n      setAttribute( slide, ARIA_HIDDEN, hidden || '' );\r\n    }\r\n\r\n    setAttribute( queryAll( slide, options.focusableNodes || '' ), TAB_INDEX, hidden ? -1 : '' );\r\n\r\n    if ( slideFocus ) {\r\n      setAttribute( slide, TAB_INDEX, hidden ? -1 : 0 );\r\n    }\r\n\r\n    if ( visible !== hasClass( slide, CLASS_VISIBLE ) ) {\r\n      toggleClass( slide, CLASS_VISIBLE, visible );\r\n      emit( visible ? EVENT_VISIBLE : EVENT_HIDDEN, self );\r\n    }\r\n\r\n    if ( ! visible && document.activeElement === slide ) {\r\n      const Slide = Components.Slides.getAt( Splide.index );\r\n      Slide && focus( Slide.slide );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Adds a CSS rule to the slider or the container.\r\n   *\r\n   * @param prop         - A property name.\r\n   * @param value        - A CSS value to add.\r\n   * @param useContainer - Optional. Determines whether to apply the rule to the container or not.\r\n   */\r\n  function style( prop: string, value: string | number, useContainer?: boolean ): void {\r\n    _style( ( useContainer && container ) || slide, prop, value );\r\n  }\r\n\r\n  /**\r\n   * Checks if the slide is active or not.\r\n   *\r\n   * @return `true` if the slide is active.\r\n   */\r\n  function isActive(): boolean {\r\n    const { index: curr } = Splide;\r\n    return curr === index || ( options.cloneStatus && curr === slideIndex );\r\n  }\r\n\r\n  /**\r\n   * Checks if the slide is visible or not.\r\n   */\r\n  function isVisible(): boolean {\r\n    if ( Splide.is( FADE ) ) {\r\n      return isActive();\r\n    }\r\n\r\n    const trackRect = rect( Components.Elements.track );\r\n    const slideRect = rect( slide );\r\n    const left      = resolve( 'left', true );\r\n    const right     = resolve( 'right', true );\r\n\r\n    return floor( trackRect[ left ] ) <= ceil( slideRect[ left ] )\r\n      && floor( slideRect[ right ] ) <= ceil( trackRect[ right ] );\r\n  }\r\n\r\n  /**\r\n   * Calculates how far this slide is from another slide and\r\n   * returns `true` if the distance is within the given number.\r\n   *\r\n   * @param from     - An index of a base slide.\r\n   * @param distance - `true` if the slide is within this number.\r\n   *\r\n   * @return `true` if the slide is within the `distance` from the base slide, or otherwise `false`.\r\n   */\r\n  function isWithin( from: number, distance: number ): boolean {\r\n    let diff = abs( from - index );\r\n\r\n    if ( ! isClone && ( options.rewind || Splide.is( LOOP ) ) ) {\r\n      diff = min( diff, Splide.length - diff );\r\n    }\r\n\r\n    return diff <= distance;\r\n  }\r\n\r\n  const self = {\r\n    index,\r\n    slideIndex,\r\n    slide,\r\n    container,\r\n    isClone,\r\n    mount,\r\n    destroy,\r\n    update,\r\n    style,\r\n    isWithin,\r\n  };\r\n\r\n  return self;\r\n}\r\n","import { DATA_ATTRIBUTE } from '../../constants/project';\r\n\r\n\r\n/**\r\n * The data attribute for the autoplay interval duration.\r\n *\r\n * @since 3.5.0\r\n */\r\nexport const INTERVAL_DATA_ATTRIBUTE = `${ DATA_ATTRIBUTE }-interval`;\r\n","/**\r\n * AddEventListenerOptions for listeners that may prevent the browser scroll.\r\n *\r\n * @since 3.4.1\r\n */\r\nexport const SCROLL_LISTENER_OPTIONS = { passive: false, capture: true };\r\n","import { ARROW_DOWN, ARROW_LEFT, ARROW_RIGHT, ARROW_UP } from '../../../constants/arrows';\r\nimport { isString } from '../../type/type';\r\n\r\n\r\n/**\r\n * The map to associate a non-standard name to the standard one.\r\n *\r\n * @since 4.0.0\r\n */\r\nexport const NORMALIZATION_MAP = {\r\n  Spacebar: ' ',\r\n  Right   : ARROW_RIGHT,\r\n  Left    : ARROW_LEFT,\r\n  Up      : ARROW_UP,\r\n  Down    : ARROW_DOWN,\r\n};\r\n\r\n/**\r\n * Normalizes the key.\r\n *\r\n * @param key - A string or a KeyboardEvent object.\r\n *\r\n * @return A normalized key.\r\n */\r\nexport function normalizeKey( key: string | KeyboardEvent ): string {\r\n  key = isString( key ) ? key : key.key;\r\n  return NORMALIZATION_MAP[ key ] || key;\r\n}","import { ARROW_LEFT, ARROW_RIGHT } from '../../constants/arrows';\r\nimport { EVENT_MOVE, EVENT_UPDATED } from '../../constants/events';\r\nimport { EventInterface } from '../../constructors';\r\nimport { Splide } from '../../core/Splide/Splide';\r\nimport { BaseComponent, Components, Options } from '../../types';\r\nimport { nextTick } from '../../utils';\r\nimport { normalizeKey } from '../../utils/dom/normalizeKey/normalizeKey';\r\n\r\n\r\n/**\r\n * The interface for the Keyboard component.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport interface KeyboardComponent extends BaseComponent {\r\n  disable( disabled: boolean ): void;\r\n}\r\n\r\n/**\r\n * The keyboard event name.\r\n *\r\n * @since 3.6.0\r\n */\r\nconst KEYBOARD_EVENT = 'keydown';\r\n\r\n/**\r\n * The component for controlling the slider by keyboards.\r\n *\r\n * @since 3.0.0\r\n *\r\n * @param Splide     - A Splide instance.\r\n * @param Components - A collection of components.\r\n * @param options    - Options.\r\n *\r\n * @return A Keyboard component object.\r\n */\r\nexport function Keyboard( Splide: Splide, Components: Components, options: Options ): KeyboardComponent {\r\n  const { on, bind, unbind } = EventInterface( Splide );\r\n  const { root } = Splide;\r\n  const { resolve } = Components.Direction;\r\n\r\n  /**\r\n   * The target element of the keyboard event.\r\n   */\r\n  let target: Window | HTMLElement;\r\n\r\n  /**\r\n   * Indicates whether the component is currently disabled or not.\r\n   */\r\n  let disabled: boolean;\r\n\r\n  /**\r\n   * Called when the component is mounted.\r\n   */\r\n  function mount(): void {\r\n    init();\r\n    on( EVENT_UPDATED, destroy );\r\n    on( EVENT_UPDATED, init );\r\n    on( EVENT_MOVE, onMove );\r\n  }\r\n\r\n  /**\r\n   * Initializes the component.\r\n   */\r\n  function init(): void {\r\n    const { keyboard } = options;\r\n\r\n    if ( keyboard ) {\r\n      target = keyboard === 'global' ? window : root;\r\n      bind( target, KEYBOARD_EVENT, onKeydown );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Destroys the component.\r\n   */\r\n  function destroy(): void {\r\n    unbind( target, KEYBOARD_EVENT );\r\n  }\r\n\r\n  /**\r\n   * Disables the keyboard input.\r\n   *\r\n   * @param value - Toggles disabling/enabling the keyboard input.\r\n   */\r\n  function disable( value: boolean ): void {\r\n    disabled = value;\r\n  }\r\n\r\n  /**\r\n   * Called when the slider moves.\r\n   * To avoid the slider from moving twice, wait for a tick.\r\n   */\r\n  function onMove(): void {\r\n    const _disabled = disabled;\r\n    disabled = true;\r\n    nextTick( () => { disabled = _disabled } );\r\n  }\r\n\r\n  /**\r\n   * Called when any key is pressed on the target.\r\n   *\r\n   * @param e - A KeyboardEvent object.\r\n   */\r\n  function onKeydown( e: KeyboardEvent ): void {\r\n    if ( ! disabled ) {\r\n      const key = normalizeKey( e );\r\n\r\n      if ( key === resolve( ARROW_LEFT ) ) {\r\n        Splide.go( '<' );\r\n      } else if ( key === resolve( ARROW_RIGHT ) ) {\r\n        Splide.go( '>' );\r\n      }\r\n    }\r\n  }\r\n\r\n  return {\r\n    mount,\r\n    destroy,\r\n    disable,\r\n  };\r\n}\r\n","import { DATA_ATTRIBUTE } from '../../constants/project';\r\n\r\n\r\n/**\r\n * The data attribute for the src value.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport const SRC_DATA_ATTRIBUTE = `${ DATA_ATTRIBUTE }-lazy`;\r\n\r\n/**\r\n * The data attribute for the srcset value.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport const SRCSET_DATA_ATTRIBUTE = `${ SRC_DATA_ATTRIBUTE }-srcset`;\r\n\r\n/**\r\n * The selector string for images to load.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport const IMAGE_SELECTOR = `[${ SRC_DATA_ATTRIBUTE }], [${ SRCSET_DATA_ATTRIBUTE }]`;\r\n","import { ARIA_ORIENTATION } from '../../constants/attributes';\r\nimport { TTB } from '../../constants/directions';\r\nimport {\r\n  EVENT_CLICK,\r\n  EVENT_MOUNTED,\r\n  EVENT_MOVE,\r\n  EVENT_NAVIGATION_MOUNTED,\r\n  EVENT_SLIDE_KEYDOWN,\r\n  EVENT_UPDATED,\r\n} from '../../constants/events';\r\nimport { LOOP } from '../../constants/types';\r\nimport { EventInterface, EventInterfaceObject } from '../../constructors';\r\nimport { Splide } from '../../core/Splide/Splide';\r\nimport { BaseComponent, Components, Options } from '../../types';\r\nimport { apply, empty, includes, isUndefined, prevent, setAttribute } from '../../utils';\r\nimport { normalizeKey } from '../../utils/dom/normalizeKey/normalizeKey';\r\nimport { SlideComponent } from '../Slides/Slide';\r\n\r\n\r\n/**\r\n * The interface for the Sync component.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport interface SyncComponent extends BaseComponent {\r\n  remount(): void;\r\n}\r\n\r\n/**\r\n * The keys for triggering the navigation slide.\r\n *\r\n * @since 3.0.0\r\n */\r\nconst TRIGGER_KEYS = [ ' ', 'Enter' ];\r\n\r\n/**\r\n * The component for syncing multiple sliders.\r\n *\r\n * @since 3.0.0\r\n *\r\n * @param Splide     - A Splide instance.\r\n * @param Components - A collection of components.\r\n * @param options    - Options.\r\n *\r\n * @return A Sync component object.\r\n */\r\nexport function Sync( Splide: Splide, Components: Components, options: Options ): SyncComponent {\r\n  const { isNavigation, slideFocus } = options;\r\n\r\n  /**\r\n   * Stores event objects.\r\n   */\r\n  const events: EventInterfaceObject[] = [];\r\n\r\n  /**\r\n   * Called when the component is mounted.\r\n   */\r\n  function mount(): void {\r\n    Splide.splides.forEach( target => {\r\n      if ( ! target.isParent ) {\r\n        sync( Splide, target.splide );\r\n        sync( target.splide, Splide );\r\n      }\r\n    } );\r\n\r\n    if ( isNavigation ) {\r\n      navigate();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Destroys the component.\r\n   */\r\n  function destroy(): void {\r\n    events.forEach( event => { event.destroy() } );\r\n    empty( events );\r\n  }\r\n\r\n  /**\r\n   * Remounts the component.\r\n   *\r\n   * @internal\r\n   */\r\n  function remount(): void {\r\n    destroy();\r\n    mount();\r\n  }\r\n\r\n  /**\r\n   * Syncs the current index with a provided child splide instance.\r\n   *\r\n   * @param splide - A splide instance to sync with.\r\n   * @param target - A target splide instance.\r\n   */\r\n  function sync( splide: Splide, target: Splide ): void {\r\n    const event = EventInterface( splide );\r\n\r\n    event.on( EVENT_MOVE, ( index, prev, dest ) => {\r\n      target.go( target.is( LOOP ) ? dest : index );\r\n    } );\r\n\r\n    events.push( event );\r\n  }\r\n\r\n  /**\r\n   * Makes slides clickable and moves the slider to the index of clicked slide.\r\n   * Note that the direction of `menu` is implicitly `vertical` as default.\r\n   */\r\n  function navigate(): void {\r\n    const event = EventInterface( Splide );\r\n    const { on } = event;\r\n\r\n    on( EVENT_CLICK, onClick );\r\n    on( EVENT_SLIDE_KEYDOWN, onKeydown );\r\n    on( [ EVENT_MOUNTED, EVENT_UPDATED ], update );\r\n\r\n    events.push( event );\r\n    event.emit( EVENT_NAVIGATION_MOUNTED, Splide.splides );\r\n  }\r\n\r\n  /**\r\n   * Update attributes.\r\n   */\r\n  function update(): void {\r\n    setAttribute( Components.Elements.list, ARIA_ORIENTATION, options.direction === TTB ? 'vertical' : '' );\r\n  }\r\n\r\n  /**\r\n   * Called when the navigation slide is clicked.\r\n   *\r\n   * @param Slide - A clicked Slide component.\r\n   */\r\n  function onClick( Slide: SlideComponent ): void {\r\n    Splide.go( Slide.index );\r\n  }\r\n\r\n  /**\r\n   * Called when any key is pressed on the navigation slide.\r\n   *\r\n   * @param Slide - A Slide component.\r\n   * @param e     - A KeyboardEvent object.\r\n   */\r\n  function onKeydown( Slide: SlideComponent, e: KeyboardEvent ): void {\r\n    if ( includes( TRIGGER_KEYS, normalizeKey( e ) ) ) {\r\n      onClick( Slide );\r\n      prevent( e );\r\n    }\r\n  }\r\n\r\n  return {\r\n    setup: apply(\r\n      Components.Media.set,\r\n      { slideFocus: isUndefined( slideFocus ) ? isNavigation : slideFocus },\r\n      true\r\n    ),\r\n    mount,\r\n    destroy,\r\n    remount,\r\n  };\r\n}\r\n","import { MEDIA_PREFERS_REDUCED_MOTION } from '../../constants/media';\r\nimport { CREATED, DESTROYED } from '../../constants/states';\r\nimport { EventBinder } from '../../constructors';\r\nimport { Splide } from '../../core/Splide/Splide';\r\nimport { BaseComponent, Components, Options } from '../../types';\r\nimport { merge, omit, ownKeys } from '../../utils';\r\nimport { EVENT_UPDATED } from '../../constants/events';\r\n\r\n\r\n/**\r\n * The interface for the Media component.\r\n *\r\n * @since 4.0.0\r\n */\r\nexport interface MediaComponent extends BaseComponent {\r\n  /** @internal */\r\n  reduce( reduced: boolean ): void;\r\n  set( options: Options, base?: boolean, notify?: boolean ): void;\r\n}\r\n\r\n/**\r\n * The component for observing media queries and updating options if necessary.\r\n * This used to be the Options component.\r\n *\r\n * @since 4.0.0\r\n *\r\n * @param Splide     - A Splide instance.\r\n * @param Components - A collection of components.\r\n * @param options    - Options.\r\n *\r\n * @return A Media component object.\r\n */\r\nexport function Media( Splide: Splide, Components: Components, options: Options ): MediaComponent {\r\n  const { state } = Splide;\r\n  const breakpoints   = options.breakpoints || {};\r\n  const reducedMotion = options.reducedMotion || {};\r\n  const binder        = EventBinder();\r\n\r\n  /**\r\n   * Stores options and MediaQueryList object.\r\n   */\r\n  const queries: Array<[ Options, MediaQueryList ]> = [];\r\n\r\n  /**\r\n   * Called when the component is constructed.\r\n   */\r\n  function setup(): void {\r\n    const isMin = options.mediaQuery === 'min';\r\n\r\n    ownKeys( breakpoints )\r\n      .sort( ( n, m ) => isMin ? +n - +m : +m - +n )\r\n      .forEach( key => {\r\n        register( breakpoints[ key ], `(${ isMin ? 'min' : 'max' }-width:${ key }px)` );\r\n      } );\r\n\r\n    register( reducedMotion, MEDIA_PREFERS_REDUCED_MOTION );\r\n    update();\r\n  }\r\n\r\n  /**\r\n   * Destroys the component.\r\n   *\r\n   * @param completely - Will be `true` for complete destruction.\r\n   */\r\n  function destroy( completely: boolean ): void {\r\n    if ( completely ) {\r\n      binder.destroy();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Registers entries as [ Options, media query string ].\r\n   *\r\n   * @param options - Options merged to current options when the document matches the query.\r\n   * @param query   - A query string.\r\n   */\r\n  function register( options: Options, query: string ): void {\r\n    const queryList = matchMedia( query );\r\n    binder.bind( queryList, 'change', update );\r\n    queries.push( [ options, queryList ] );\r\n  }\r\n\r\n  /**\r\n   * Checks all media queries in entries and updates options.\r\n   */\r\n  function update(): void {\r\n    const destroyed = state.is( DESTROYED );\r\n    const direction = options.direction;\r\n    const merged = queries.reduce<Options>( ( merged, entry ) => {\r\n      return merge( merged, entry[ 1 ].matches ? entry[ 0 ] : {} );\r\n    }, {} );\r\n\r\n    omit( options );\r\n    set( merged );\r\n\r\n    if ( options.destroy ) {\r\n      Splide.destroy( options.destroy === 'completely' );\r\n    } else if ( destroyed ) {\r\n      destroy( true );\r\n      Splide.mount();\r\n    } else {\r\n      direction !== options.direction && Splide.refresh();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Disables or enables `reducedMotion` options.\r\n   * This method does nothing when the document does not match the query.\r\n   *\r\n   * @internal\r\n   *\r\n   * @param enable - Determines whether to apply `reducedMotion` options or not.\r\n   */\r\n  function reduce( enable: boolean ): void {\r\n    if ( matchMedia( MEDIA_PREFERS_REDUCED_MOTION ).matches ) {\r\n      enable ? merge( options, reducedMotion ) : omit( options, ownKeys( reducedMotion ) );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sets current options or base options (prototype).\r\n   * If changing base options, always emits the `updated` event.\r\n   *\r\n   * @internal\r\n   *\r\n   * @param opts   - New options.\r\n   * @param base   - Optional. Determines whether to also update base options or not.\r\n   * @param notify - Optional. If `true`, always emits the `update` event.\r\n   */\r\n  function set( opts: Options, base?: boolean, notify?: boolean ): void {\r\n    merge( options, opts );\r\n    base && merge( Object.getPrototypeOf( options ), opts );\r\n\r\n    if ( notify || ! state.is( CREATED ) ) {\r\n      Splide.emit( EVENT_UPDATED, options );\r\n    }\r\n  }\r\n\r\n  return {\r\n    setup,\r\n    destroy,\r\n    reduce,\r\n    set,\r\n  };\r\n}\r\n","import { ALL_ATTRIBUTES, ARIA_LABEL, ARIA_LABELLEDBY, ARIA_ROLEDESCRIPTION, ROLE } from '../../constants/attributes';\r\nimport {\r\n  CLASS_ACTIVE,\r\n  CLASS_ARROW_NEXT,\r\n  CLASS_ARROW_PREV,\r\n  CLASS_ARROWS,\r\n  CLASS_CLONE,\r\n  CLASS_FOCUS_IN,\r\n  CLASS_LIST,\r\n  CLASS_PAGINATION,\r\n  CLASS_PROGRESS_BAR,\r\n  CLASS_ROOT,\r\n  CLASS_SLIDE,\r\n  CLASS_TOGGLE,\r\n  CLASS_TRACK,\r\n} from '../../constants/classes';\r\nimport { EVENT_REFRESH, EVENT_UPDATED } from '../../constants/events';\r\nimport { PROJECT_CODE } from '../../constants/project';\r\nimport { EventInterface } from '../../constructors';\r\nimport { Splide } from '../../core/Splide/Splide';\r\nimport { BaseComponent, Components, Options } from '../../types';\r\nimport {\r\n  addClass,\r\n  assert,\r\n  assign,\r\n  child,\r\n  children,\r\n  empty,\r\n  forOwn,\r\n  getAttribute,\r\n  push,\r\n  query,\r\n  removeAttribute,\r\n  removeClass,\r\n  setAttribute,\r\n  toggleClass,\r\n  uniqueId,\r\n} from '../../utils';\r\nimport { closest } from '../../utils/dom/closest/closest';\r\nimport { POINTER_DOWN_EVENTS } from '../Drag/constants';\r\n\r\n\r\n/**\r\n * The interface for elements which the slider consists of.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport interface ElementCollection {\r\n  root: HTMLElement;\r\n  track: HTMLElement;\r\n  list: HTMLElement;\r\n  slides: HTMLElement[];\r\n  arrows?: HTMLElement;\r\n  pagination?: HTMLUListElement;\r\n  prev?: HTMLButtonElement;\r\n  next?: HTMLButtonElement;\r\n  bar?: HTMLElement;\r\n  toggle?: HTMLElement;\r\n}\r\n\r\n/**\r\n * The interface for the Elements component.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport interface ElementsComponent extends BaseComponent, ElementCollection {\r\n}\r\n\r\n/**\r\n * The component that collects and handles elements which the slider consists of.\r\n *\r\n * @since 3.0.0\r\n *\r\n * @param Splide     - A Splide instance.\r\n * @param Components - A collection of components.\r\n * @param options    - Options.\r\n *\r\n * @return An Elements component object.\r\n */\r\nexport function Elements( Splide: Splide, Components: Components, options: Options ): ElementsComponent {\r\n  const { on, bind } = EventInterface( Splide );\r\n  const { root } = Splide;\r\n  const { i18n } = options;\r\n  const elements: ElementCollection = {} as ElementCollection;\r\n\r\n  /**\r\n   * Stores all slide elements.\r\n   */\r\n  const slides: HTMLElement[] = [];\r\n\r\n  /**\r\n   * Stores all root classes.\r\n   */\r\n  let rootClasses: string[] = [];\r\n\r\n  /**\r\n   * Stores all list classes.\r\n   */\r\n  let trackClasses: string[] = [];\r\n\r\n  /**\r\n   * The track element.\r\n   */\r\n  let track: HTMLElement;\r\n\r\n  /**\r\n   * The list element.\r\n   */\r\n  let list: HTMLElement;\r\n\r\n  /**\r\n   * Turns into `true` when detecting keydown, and `false` when detecting pointerdown.\r\n   */\r\n  let isUsingKey: boolean;\r\n\r\n  /**\r\n   * Called when the component is constructed.\r\n   */\r\n  function setup(): void {\r\n    collect();\r\n    init();\r\n    update();\r\n  }\r\n\r\n  /**\r\n   * Called when the component is mounted.\r\n   */\r\n  function mount(): void {\r\n    on( EVENT_REFRESH, destroy );\r\n    on( EVENT_REFRESH, setup );\r\n    on( EVENT_UPDATED, update );\r\n\r\n    bind( document, `${ POINTER_DOWN_EVENTS } keydown`, e => {\r\n      isUsingKey = e.type === 'keydown';\r\n    }, { capture: true } );\r\n\r\n    bind( root, 'focusin', () => {\r\n      toggleClass( root, CLASS_FOCUS_IN, !! isUsingKey );\r\n    } );\r\n  }\r\n\r\n  /**\r\n   * Destroys the component.\r\n   *\r\n   * @param completely - Whether to destroy the component completely or not.\r\n   */\r\n  function destroy( completely?: boolean ): void {\r\n    const attrs = ALL_ATTRIBUTES.concat( 'style' );\r\n\r\n    empty( slides );\r\n    removeClass( root, rootClasses );\r\n    removeClass( track, trackClasses );\r\n    removeAttribute( [ track, list ], attrs );\r\n    removeAttribute( root, completely ? attrs : [ 'style', ARIA_ROLEDESCRIPTION ] );\r\n  }\r\n\r\n  /**\r\n   * Updates the status of elements.\r\n   */\r\n  function update(): void {\r\n    removeClass( root, rootClasses );\r\n    removeClass( track, trackClasses );\r\n\r\n    rootClasses  = getClasses( CLASS_ROOT );\r\n    trackClasses = getClasses( CLASS_TRACK );\r\n\r\n    addClass( root, rootClasses );\r\n    addClass( track, trackClasses );\r\n\r\n    setAttribute( root, ARIA_LABEL, options.label );\r\n    setAttribute( root, ARIA_LABELLEDBY, options.labelledby );\r\n  }\r\n\r\n  /**\r\n   * Collects elements which the slider consists of.\r\n   */\r\n  function collect(): void {\r\n    track = find( `.${ CLASS_TRACK }` );\r\n    list  = child( track, `.${ CLASS_LIST }` );\r\n\r\n    assert( track && list, 'A track/list element is missing.' );\r\n    push( slides, children( list, `.${ CLASS_SLIDE }:not(.${ CLASS_CLONE })` ) );\r\n\r\n    forOwn( {\r\n      arrows    : CLASS_ARROWS,\r\n      pagination: CLASS_PAGINATION,\r\n      prev      : CLASS_ARROW_PREV,\r\n      next      : CLASS_ARROW_NEXT,\r\n      bar       : CLASS_PROGRESS_BAR,\r\n      toggle    : CLASS_TOGGLE,\r\n    }, ( className, key ) => {\r\n      elements[ key ] = find( `.${ className }` );\r\n    } );\r\n\r\n    assign( elements, { root, track, list, slides } );\r\n  }\r\n\r\n  /**\r\n   * Initializes essential elements.\r\n   * Note that do not change the role of the root element,\r\n   * which removes the region from the accessibility tree.\r\n   */\r\n  function init(): void {\r\n    const id   = root.id || uniqueId( PROJECT_CODE );\r\n    const role = options.role;\r\n\r\n    root.id  = id;\r\n    track.id = track.id || `${ id }-track`;\r\n    list.id  = list.id || `${ id }-list`;\r\n\r\n    if ( ! getAttribute( root, ROLE ) && root.tagName !== 'SECTION' && role ) {\r\n      setAttribute( root, ROLE, role );\r\n    }\r\n\r\n    setAttribute( root, ARIA_ROLEDESCRIPTION, i18n.carousel );\r\n    setAttribute( list, ROLE, 'presentation' );\r\n  }\r\n\r\n  /**\r\n   * Finds an element only in this slider, ignoring elements in a nested slider.\r\n   *\r\n   * @return A found element or null.\r\n   */\r\n  function find( selector: string ): HTMLElement | undefined {\r\n    const elm = query<HTMLElement>( root, selector );\r\n    return elm && closest( elm, `.${ CLASS_ROOT }` ) === root ? elm : undefined;\r\n  }\r\n\r\n  /**\r\n   * Return an array with modifier classes.\r\n   *\r\n   * @param base - A base class name.\r\n   *\r\n   * @return An array with classes.\r\n   */\r\n  function getClasses( base: string ): string[] {\r\n    return [\r\n      `${ base }--${ options.type }`,\r\n      `${ base }--${ options.direction }`,\r\n      options.drag && `${ base }--draggable`,\r\n      options.isNavigation && `${ base }--nav`,\r\n      base === CLASS_ROOT && CLASS_ACTIVE,\r\n    ];\r\n  }\r\n\r\n  return assign( elements, {\r\n    setup,\r\n    mount,\r\n    destroy,\r\n  } );\r\n}\r\n","import { isFunction } from '../../type/type';\r\nimport { matches } from '../matches/matches';\r\n\r\n\r\n/**\r\n * Starts from the provided element, searches for the first element that matches the selector in ascendants.\r\n *\r\n * @param from     - An element to search from.\r\n * @param selector - A selector.\r\n *\r\n * @return The found element if available, or `null`.\r\n */\r\nexport function closest( from: HTMLElement, selector: string ): HTMLElement | null {\r\n  if ( isFunction( from.closest ) ) {\r\n    return from.closest( selector );\r\n  }\r\n\r\n  let elm: HTMLElement | null = from;\r\n\r\n  while ( elm && elm.nodeType === 1 ) {\r\n    if ( matches( elm, selector ) ) {\r\n      break;\r\n    }\r\n\r\n    elm = elm.parentElement;\r\n  }\r\n\r\n  return elm;\r\n}","import { EVENT_REFRESH, EVENT_RESIZE } from '../../constants/events';\r\nimport { EventInterface } from '../../constructors';\r\nimport { Splide } from '../../core/Splide/Splide';\r\nimport { AnyFunction, BaseComponent, Components, Options } from '../../types';\r\nimport {\r\n  addClass,\r\n  append,\r\n  apply,\r\n  before,\r\n  between,\r\n  empty,\r\n  forEach as forEachItem,\r\n  includes,\r\n  isFunction,\r\n  isHTMLElement,\r\n  isString,\r\n  matches,\r\n  parseHtml,\r\n  queryAll,\r\n  remove as removeNode,\r\n  toArray,\r\n} from '../../utils';\r\nimport { Slide, SlideComponent } from './Slide';\r\n\r\n\r\n/**\r\n * The interface for the Slides component.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport interface SlidesComponent extends BaseComponent {\r\n  update(): void;\r\n  register( slide: HTMLElement, index: number, slideIndex: number ): void;\r\n  get( excludeClones?: boolean ): SlideComponent[];\r\n  getIn( page: number ): SlideComponent[];\r\n  getAt( index: number ): SlideComponent | undefined;\r\n  add( slide: string | Element | Array<string | Element>, index?: number ): void;\r\n  remove( selector: SlideMatcher ): void;\r\n  forEach( iteratee: SlidesIteratee, excludeClones?: boolean ): void;\r\n  filter( matcher: SlideMatcher ): SlideComponent[];\r\n  style( prop: string, value: string | number, useContainer?: boolean ): void\r\n  getLength( excludeClones?: boolean ): number;\r\n  isEnough(): boolean;\r\n}\r\n\r\n/**\r\n * The iteratee function for Slides.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport type SlidesIteratee = ( Slide: SlideComponent, index: number, Slides: SlideComponent[] ) => void\r\n\r\n/**\r\n * The predicate function for Slides.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport type SlidesPredicate = ( Slide: SlideComponent, index: number, Slides: SlideComponent[] ) => any\r\n\r\n/**\r\n * The type for filtering SlideComponent objects.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport type SlideMatcher = number | number[] | string | SlidesPredicate;\r\n\r\n/**\r\n * The component for managing all slides include clones.\r\n *\r\n * @since 3.0.0\r\n *\r\n * @param Splide     - A Splide instance.\r\n * @param Components - A collection of components.\r\n * @param options    - Options.\r\n *\r\n * @return An Slides component object.\r\n */\r\nexport function Slides( Splide: Splide, Components: Components, options: Options ): SlidesComponent {\r\n  const { on, emit, bind } = EventInterface( Splide );\r\n  const { slides, list } = Components.Elements;\r\n\r\n  /**\r\n   * Stores all SlideComponent objects.\r\n   */\r\n  const Slides: SlideComponent[] = [];\r\n\r\n  /**\r\n   * Called when the component is mounted.\r\n   */\r\n  function mount(): void {\r\n    init();\r\n    on( EVENT_REFRESH, destroy );\r\n    on( EVENT_REFRESH, init );\r\n  }\r\n\r\n  /**\r\n   * Initializes the component.\r\n   */\r\n  function init(): void {\r\n    slides.forEach( ( slide, index ) => { register( slide, index, -1 ) } );\r\n  }\r\n\r\n  /**\r\n   * Destroys the component.\r\n   */\r\n  function destroy(): void {\r\n    forEach( Slide => { Slide.destroy() } );\r\n    empty( Slides );\r\n  }\r\n\r\n  /**\r\n   * Manually updates the status of all slides.\r\n   */\r\n  function update(): void {\r\n    forEach( Slide => { Slide.update() } );\r\n  }\r\n\r\n  /**\r\n   * Registers a slide element and creates a Slide object.\r\n   * Needs to sort every time when a new slide is registered especially for clones.\r\n   *\r\n   * @param slide      - A slide element to register.\r\n   * @param index      - A slide index.\r\n   * @param slideIndex - A slide index for clones. This must be `-1` for regular slides.\r\n   */\r\n  function register( slide: HTMLElement, index: number, slideIndex: number ): void {\r\n    const object = Slide( Splide, index, slideIndex, slide );\r\n    object.mount();\r\n    Slides.push( object );\r\n    Slides.sort( ( Slide1, Slide2 ) => Slide1.index - Slide2.index );\r\n  }\r\n\r\n  /**\r\n   * Returns all Slide objects.\r\n   *\r\n   * @param excludeClones - Optional. Determines whether to exclude clones or not.\r\n   *\r\n   * @return An array with Slide objects.\r\n   */\r\n  function get( excludeClones?: boolean ): SlideComponent[] {\r\n    return excludeClones ? filter( Slide => ! Slide.isClone ) : Slides;\r\n  }\r\n\r\n  /**\r\n   * Returns slides in the specified page.\r\n   *\r\n   * @param page - A page index.\r\n   *\r\n   * @return An array with slides that belong to the page.\r\n   */\r\n  function getIn( page: number ): SlideComponent[] {\r\n    const { Controller } = Components;\r\n    const index = Controller.toIndex( page );\r\n    const max   = Controller.hasFocus() ? 1 : options.perPage;\r\n    return filter( Slide => between( Slide.index, index, index + max - 1 ) );\r\n  }\r\n\r\n  /**\r\n   * Returns a Slide object at the specified index.\r\n   *\r\n   * @param index - A slide index.\r\n   *\r\n   * @return A Slide object if available, or otherwise `undefined`.\r\n   */\r\n  function getAt( index: number ): SlideComponent | undefined {\r\n    return filter( index )[ 0 ];\r\n  }\r\n\r\n  /**\r\n   * Inserts a slide or slides at a specified index.\r\n   *\r\n   * @param items - A slide element, an HTML string or an array with them.\r\n   * @param index - Optional. An index to insert the slide at. If omitted, appends it to the list.\r\n   */\r\n  function add( items: string | Element | Array<string | Element>, index?: number ): void {\r\n    forEachItem( items, slide => {\r\n      if ( isString( slide ) ) {\r\n        slide = parseHtml( slide );\r\n      }\r\n\r\n      if ( isHTMLElement( slide ) ) {\r\n        const ref = slides[ index ];\r\n        ref ? before( slide, ref ) : append( list, slide );\r\n        addClass( slide, options.classes.slide );\r\n        observeImages( slide, apply( emit, EVENT_RESIZE ) );\r\n      }\r\n    } );\r\n\r\n    emit( EVENT_REFRESH );\r\n  }\r\n\r\n  /**\r\n   * Removes slides that match the matcher\r\n   * that can be an index, an array with indices, a selector, or an iteratee function.\r\n   *\r\n   * @param matcher - An index, an array with indices, a selector string, or an iteratee function.\r\n   */\r\n  function remove( matcher: SlideMatcher ): void {\r\n    removeNode( filter( matcher ).map( Slide => Slide.slide ) );\r\n    emit( EVENT_REFRESH );\r\n  }\r\n\r\n  /**\r\n   * Iterates over Slide objects by the iteratee function.\r\n   *\r\n   * @param iteratee      - An iteratee function that takes a Slide object, an index and an array with Slides.\r\n   * @param excludeClones - Optional. Determines whether to exclude clones or not.\r\n   */\r\n  function forEach( iteratee: SlidesIteratee, excludeClones?: boolean ): void {\r\n    get( excludeClones ).forEach( iteratee );\r\n  }\r\n\r\n  /**\r\n   * Filters Slides by the matcher\r\n   * that can be an index, an array with indices, a selector, or a predicate function.\r\n   *\r\n   * @param matcher - An index, an array with indices, a selector string, or a predicate function.\r\n   *\r\n   * @return An array with SlideComponent objects.\r\n   */\r\n  function filter( matcher: SlideMatcher ): SlideComponent[] {\r\n    return Slides.filter( isFunction( matcher )\r\n      ? matcher\r\n      : Slide => isString( matcher )\r\n        ? matches( Slide.slide, matcher )\r\n        : includes( toArray( matcher ), Slide.index )\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Adds a CSS rule to all slides or containers.\r\n   *\r\n   * @param prop         - A property name.\r\n   * @param value        - A CSS value to add.\r\n   * @param useContainer - Optional. Determines whether to apply the rule to the container or not.\r\n   */\r\n  function style( prop: string, value: string | number, useContainer?: boolean ): void {\r\n    forEach( Slide => { Slide.style( prop, value, useContainer ) } );\r\n  }\r\n\r\n  /**\r\n   * Invokes the callback after all images in the element are loaded.\r\n   *\r\n   * @param elm      - An element that may contain images.\r\n   * @param callback - A callback function.\r\n   */\r\n  function observeImages( elm: Element, callback: AnyFunction ): void {\r\n    const images = queryAll( elm, 'img' );\r\n    let { length } = images;\r\n\r\n    if ( length ) {\r\n      images.forEach( img => {\r\n        bind( img, 'load error', () => {\r\n          if ( ! --length ) {\r\n            callback();\r\n          }\r\n        } );\r\n      } );\r\n    } else {\r\n      callback();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the length of slides.\r\n   *\r\n   * @param excludeClones - Optional. Determines whether to exclude clones or not.\r\n   *\r\n   * @return The length of slides.\r\n   */\r\n  function getLength( excludeClones?: boolean ): number {\r\n    return excludeClones ? slides.length : Slides.length;\r\n  }\r\n\r\n  /**\r\n   * Checks if the number of slides is over than the `perPage` option, including clones.\r\n   *\r\n   * @return `true` if there are enough slides, or otherwise `false`.\r\n   */\r\n  function isEnough(): boolean {\r\n    return Slides.length > options.perPage;\r\n  }\r\n\r\n  return {\r\n    mount,\r\n    destroy,\r\n    update,\r\n    register,\r\n    get,\r\n    getIn,\r\n    getAt,\r\n    add,\r\n    remove,\r\n    forEach,\r\n    filter,\r\n    style,\r\n    getLength,\r\n    isEnough,\r\n  };\r\n}\r\n","import { TTB } from '../../constants/directions';\r\nimport { EVENT_OVERFLOW, EVENT_REFRESH, EVENT_RESIZE, EVENT_RESIZED, EVENT_UPDATED } from '../../constants/events';\r\nimport { EventInterface, Throttle } from '../../constructors';\r\nimport { Splide } from '../../core/Splide/Splide';\r\nimport { BaseComponent, Components, Options } from '../../types';\r\nimport { abs, apply, assert, isObject, rect, style, toggleClass, unit } from '../../utils';\r\nimport { FADE } from '../../constants/types';\r\nimport { CLASS_OVERFLOW } from '../../constants/classes';\r\n\r\n\r\n/**\r\n * The interface for the Layout component.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport interface LayoutComponent extends BaseComponent {\r\n  listSize(): number;\r\n  slideSize( index: number, withoutGap?: boolean ): number;\r\n  sliderSize( withoutGap?: boolean ): number;\r\n  totalSize( index?: number, withoutGap?: boolean ): number;\r\n  getPadding( right: boolean ): number;\r\n  isOverflow(): boolean;\r\n\r\n  /** @internal */\r\n  resize( force?: boolean ): void;\r\n}\r\n\r\n/**\r\n * The component that adjusts slider styles and provides methods for dimensions.\r\n *\r\n * @since 3.0.0\r\n *\r\n * @param Splide     - A Splide instance.\r\n * @param Components - A collection of components.\r\n * @param options    - Options.\r\n *\r\n * @return An Layout component object.\r\n */\r\nexport function Layout( Splide: Splide, Components: Components, options: Options ): LayoutComponent {\r\n  const { on, bind, emit } = EventInterface( Splide );\r\n  const { Slides } = Components;\r\n  const { resolve } = Components.Direction;\r\n  const { root, track, list } = Components.Elements;\r\n  const { getAt, style: styleSlides } = Slides;\r\n\r\n  /**\r\n   * Indicates whether the slider direction is vertical or not.\r\n   */\r\n  let vertical: boolean;\r\n\r\n  /**\r\n   * Keeps the DOMRect object of the root element.\r\n   */\r\n  let rootRect: DOMRect;\r\n\r\n  /**\r\n   * Turns into `true` when the carousel is wider than the list.\r\n   */\r\n  let overflow: boolean;\r\n\r\n  /**\r\n   * Called when the component is mounted.\r\n   */\r\n  function mount(): void {\r\n    init();\r\n    bind( window, 'resize load', Throttle( apply( emit, EVENT_RESIZE ) ) );\r\n    on( [ EVENT_UPDATED, EVENT_REFRESH ], init );\r\n    on( EVENT_RESIZE, resize );\r\n  }\r\n\r\n  /**\r\n   * Initializes the component on `mount` or `updated`.\r\n   * Uses `max-width` for the root to prevent the slider from exceeding the parent element.\r\n   */\r\n  function init(): void {\r\n    vertical = options.direction === TTB;\r\n\r\n    style( root, 'maxWidth', unit( options.width ) );\r\n    style( track, resolve( 'paddingLeft' ), cssPadding( false ) );\r\n    style( track, resolve( 'paddingRight' ), cssPadding( true ) );\r\n\r\n    resize( true );\r\n  }\r\n\r\n  /**\r\n   * Updates dimensions of some elements when the carousel is resized.\r\n   * Also checks the carousel size and emits `overflow` events when it exceeds the list width.\r\n   *\r\n   * @param force - Skips checking the root dimension change and always performs the resizing process.\r\n   */\r\n  function resize( force?: boolean ): void {\r\n    const newRect = rect( root );\r\n\r\n    if ( force || rootRect.width !== newRect.width || rootRect.height !== newRect.height ) {\r\n      style( track, 'height', cssTrackHeight() );\r\n\r\n      styleSlides( resolve( 'marginRight' ), unit( options.gap ) );\r\n      styleSlides( 'width', cssSlideWidth() );\r\n      styleSlides( 'height', cssSlideHeight(), true );\r\n\r\n      rootRect = newRect;\r\n      emit( EVENT_RESIZED );\r\n\r\n      if ( overflow !== ( overflow = isOverflow() ) ) {\r\n        toggleClass( root, CLASS_OVERFLOW, overflow );\r\n        emit( EVENT_OVERFLOW, overflow );\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Parses the padding option and returns the value for each side.\r\n   * This method returns `paddingTop` or `paddingBottom` for the vertical slider.\r\n   *\r\n   * @param right - Determines whether to get `paddingRight/Bottom` or `paddingLeft/Top`.\r\n   *\r\n   * @return The padding value as a CSS string.\r\n   */\r\n  function cssPadding( right: boolean ): string {\r\n    const { padding } = options;\r\n    const prop = resolve( right ? 'right' : 'left' );\r\n    return padding\r\n      && unit( padding[ prop ] || ( isObject( padding ) ? 0 : padding ) )\r\n      || '0px';\r\n  }\r\n\r\n  /**\r\n   * Returns the height of the track element as a CSS string.\r\n   *\r\n   * @return The height of the track.\r\n   */\r\n  function cssTrackHeight(): string {\r\n    let height = '';\r\n\r\n    if ( vertical ) {\r\n      height = cssHeight();\r\n      assert( height, 'height or heightRatio is missing.' );\r\n      height = `calc(${ height } - ${ cssPadding( false ) } - ${ cssPadding( true ) })`;\r\n    }\r\n\r\n    return height;\r\n  }\r\n\r\n  /**\r\n   * Converts options related with height to a CSS string.\r\n   *\r\n   * @return The height as a CSS string if available, or otherwise an empty string.\r\n   */\r\n  function cssHeight(): string {\r\n    return unit( options.height || rect( list ).width * options.heightRatio );\r\n  }\r\n\r\n  /**\r\n   * Returns the width of the slide as a CSS string.\r\n   *\r\n   * @return The width of the slide.\r\n   */\r\n  function cssSlideWidth(): string | null {\r\n    return options.autoWidth\r\n      ? null\r\n      : unit( options.fixedWidth ) || ( vertical ? '' : cssSlideSize() );\r\n  }\r\n\r\n  /**\r\n   * Returns the height of the slide as a CSS string.\r\n   *\r\n   * @return The height of the slide.\r\n   */\r\n  function cssSlideHeight(): string | null {\r\n    return unit( options.fixedHeight )\r\n      || ( vertical ? ( options.autoHeight ? null : cssSlideSize() ) : cssHeight() );\r\n  }\r\n\r\n  /**\r\n   * Returns the CSS string for slide width or height without gap.\r\n   *\r\n   * @return The CSS string for slide width or height.\r\n   */\r\n  function cssSlideSize(): string {\r\n    const gap = unit( options.gap );\r\n    return `calc((100%${ gap && ` + ${ gap }` })/${ options.perPage || 1 }${ gap && ` - ${ gap }` })`;\r\n  }\r\n\r\n  /**\r\n   * Returns the list width for the horizontal slider, or the height for the vertical slider.\r\n   *\r\n   * @return The size of the list element in pixel.\r\n   */\r\n  function listSize(): number {\r\n    return rect( list )[ resolve( 'width' ) ];\r\n  }\r\n\r\n  /**\r\n   * Returns the slide width for the horizontal slider, or the height for the vertical slider.\r\n   *\r\n   * @param index      - Optional. A slide index.\r\n   * @param withoutGap - Optional. Determines whether to exclude the gap amount or not.\r\n   *\r\n   * @return The size of the specified slide element in pixel.\r\n   */\r\n  function slideSize( index?: number, withoutGap?: boolean ): number {\r\n    const Slide = getAt( index || 0 );\r\n    return Slide\r\n      ? rect( Slide.slide )[ resolve( 'width' ) ] + ( withoutGap ? 0 : getGap() )\r\n      : 0;\r\n  }\r\n\r\n  /**\r\n   * Returns the total width or height of slides from the head of the slider to the specified index.\r\n   * This includes sizes of clones before the first slide.\r\n   *\r\n   * @param index      - A slide index. If omitted, uses the last index.\r\n   * @param withoutGap - Optional. Determines whether to exclude the last gap or not.\r\n   *\r\n   * @return The total width of slides in the horizontal slider, or the height in the vertical one.\r\n   */\r\n  function totalSize( index: number, withoutGap?: boolean ): number {\r\n    const Slide = getAt( index );\r\n\r\n    if ( Slide ) {\r\n      const right = rect( Slide.slide )[ resolve( 'right' ) ];\r\n      const left  = rect( list )[ resolve( 'left' ) ];\r\n      return abs( right - left ) + ( withoutGap ? 0 : getGap() );\r\n    }\r\n\r\n    return 0;\r\n  }\r\n\r\n  /**\r\n   * Returns the slider size without clones before the first slide.\r\n   * Do not use the clone's size because it's unstable while initializing and refreshing process.\r\n   *\r\n   * @param withoutGap - Optional. Determines whether to exclude the last gap or not.\r\n   *\r\n   * @return The width or height of the slider without clones.\r\n   */\r\n  function sliderSize( withoutGap?: boolean ): number {\r\n    return totalSize( Splide.length - 1 ) - totalSize( 0 ) + slideSize( 0, withoutGap );\r\n  }\r\n\r\n  /**\r\n   * Returns the gap value in pixel by using the computed style of the first slide.\r\n   *\r\n   * @return The gap value in pixel.\r\n   */\r\n  function getGap(): number {\r\n    const Slide = getAt( 0 );\r\n    return Slide && parseFloat( style( Slide.slide, resolve( 'marginRight' ) ) ) || 0;\r\n  }\r\n\r\n  /**\r\n   * Returns the padding value.\r\n   * This method resolves the difference of the direction.\r\n   *\r\n   * @param right - Determines whether to get `paddingRight/Bottom` or `paddingLeft/Top`.\r\n   *\r\n   * @return The padding value in pixel.\r\n   */\r\n  function getPadding( right: boolean ): number {\r\n    return parseFloat( style( track, resolve( `padding${ right ? 'Right' : 'Left' }` ) ) ) || 0;\r\n  }\r\n\r\n  /**\r\n   * Checks if the carousel is wider than the list.\r\n   * This method always returns `true` for a fade carousel.\r\n   *\r\n   * @return `true` if the carousel is wider than the list, or otherwise `false`.\r\n   */\r\n  function isOverflow(): boolean {\r\n    return Splide.is( FADE ) || sliderSize( true ) > listSize();\r\n  }\r\n\r\n  return {\r\n    mount,\r\n    resize,\r\n    listSize,\r\n    slideSize,\r\n    sliderSize,\r\n    totalSize,\r\n    getPadding,\r\n    isOverflow,\r\n  };\r\n}\r\n","import { AnyFunction } from '../../types';\r\nimport { RequestInterval } from '../RequestInterval/RequestInterval';\r\n\r\n\r\n/**\r\n * The interface for the returning value of the RequestInterval.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport interface ThrottleInstance<F extends AnyFunction> extends Function {\r\n  ( ...args: Parameters<F> ): void;\r\n}\r\n\r\n/**\r\n * Returns the throttled function.\r\n *\r\n * @param func     - A function to throttle.\r\n * @param duration - Optional. Throttle duration in milliseconds.\r\n *\r\n * @return A throttled function.\r\n */\r\nexport function Throttle<F extends AnyFunction>(\r\n  func: F,\r\n  duration?: number\r\n): ThrottleInstance<F> {\r\n  const interval = RequestInterval( duration || 0, func, null, 1 );\r\n\r\n  return () => {\r\n    interval.isPaused() && interval.start();\r\n  };\r\n}\r\n","import { EVENT_REFRESH, EVENT_RESIZE, EVENT_UPDATED } from '../../constants/events';\r\nimport { LOOP } from '../../constants/types';\r\nimport { EventInterface } from '../../constructors';\r\nimport { Splide } from '../../core/Splide/Splide';\r\nimport { BaseComponent, Components, Options } from '../../types';\r\nimport { addClass, append, before, ceil, empty, isUndefined, pad, push, rect, remove } from '../../utils';\r\n\r\n\r\n/**\r\n * The interface for the Clone component.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport interface ClonesComponent extends BaseComponent {\r\n}\r\n\r\n/**\r\n * The multiplier to determine the number of clones.\r\n *\r\n * @since 4.0.0\r\n */\r\nexport const MULTIPLIER = 2;\r\n\r\n/**\r\n * The component that generates clones for the loop slider.\r\n *\r\n * @since 3.0.0\r\n *\r\n * @param Splide     - A Splide instance.\r\n * @param Components - A collection of components.\r\n * @param options    - Options.\r\n *\r\n * @return A Clones component object.\r\n */\r\nexport function Clones( Splide: Splide, Components: Components, options: Options ): ClonesComponent {\r\n  const event = EventInterface( Splide );\r\n  const { on } = event;\r\n  const { Elements, Slides } = Components;\r\n  const { resolve } = Components.Direction;\r\n\r\n  /**\r\n   * Stores all cloned elements.\r\n   */\r\n  const clones: HTMLElement[] = [];\r\n\r\n  /**\r\n   * Keeps the current number of clones.\r\n   */\r\n  let cloneCount: number;\r\n\r\n  /**\r\n   * Called when the component is mounted.\r\n   * Needs to remount the component on refresh, otherwise `refresh` event will be triggered again while refreshing.\r\n   */\r\n  function mount(): void {\r\n    on( EVENT_REFRESH, remount );\r\n    on( [ EVENT_UPDATED, EVENT_RESIZE ], observe );\r\n\r\n    if ( ( cloneCount = computeCloneCount() ) ) {\r\n      generate( cloneCount );\r\n      Components.Layout.resize( true );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remounts the component.\r\n   */\r\n  function remount(): void {\r\n    destroy();\r\n    mount();\r\n  }\r\n\r\n  /**\r\n   * Destroys clones.\r\n   */\r\n  function destroy(): void {\r\n    remove( clones );\r\n    empty( clones );\r\n    event.destroy();\r\n  }\r\n\r\n  /**\r\n   * Observes the required clone count and refreshes the slider if necessary.\r\n   */\r\n  function observe(): void {\r\n    const count = computeCloneCount();\r\n\r\n    if ( cloneCount !== count ) {\r\n      if ( cloneCount < count || ! count ) {\r\n        event.emit( EVENT_REFRESH );\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generates the specified number of clones.\r\n   *\r\n   * @param count - The number of clones to generate for each side.\r\n   */\r\n  function generate( count: number ): void {\r\n    const slides = Slides.get().slice();\r\n    const { length } = slides;\r\n\r\n    if ( length ) {\r\n      while ( slides.length < count ) {\r\n        push( slides, slides );\r\n      }\r\n\r\n      push( slides.slice( -count ), slides.slice( 0, count ) ).forEach( ( Slide, index ) => {\r\n        const isHead = index < count;\r\n        const clone  = cloneDeep( Slide.slide, index );\r\n        isHead ? before( clone, slides[ 0 ].slide ) : append( Elements.list, clone );\r\n        push( clones, clone );\r\n        Slides.register( clone, index - count + ( isHead ? 0 : length ), Slide.index );\r\n      } );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Deeply clones the provided element with removing the ID attribute.\r\n   *\r\n   * @param elm   - An element to clone.\r\n   * @param index - An index of the clone.\r\n   *\r\n   * @return A cloned element.\r\n   */\r\n  function cloneDeep( elm: HTMLElement, index: number ): HTMLElement {\r\n    const clone = elm.cloneNode( true ) as HTMLElement;\r\n    addClass( clone, options.classes.clone );\r\n    clone.id = `${ Splide.root.id }-clone${ pad( index + 1 ) }`;\r\n    return clone;\r\n  }\r\n\r\n  /**\r\n   * Returns the number of elements to generate.\r\n   * This always returns 0 if the slider type is not `'loop'`.\r\n   *\r\n   * @return The number of clones.\r\n   */\r\n  function computeCloneCount(): number {\r\n    let { clones } = options;\r\n\r\n    if ( ! Splide.is( LOOP ) ) {\r\n      clones = 0;\r\n    } else if ( isUndefined( clones ) ) {\r\n      const fixedSize  = options[ resolve( 'fixedWidth' ) ] && Components.Layout.slideSize( 0 );\r\n      const fixedCount = fixedSize && ceil( rect( Elements.track )[ resolve( 'width' ) ] / fixedSize );\r\n      clones = fixedCount || ( options[ resolve( 'autoWidth' ) ] && Splide.length ) || options.perPage * MULTIPLIER;\r\n    }\r\n\r\n    return clones;\r\n  }\r\n\r\n  return {\r\n    mount,\r\n    destroy,\r\n  };\r\n}\r\n","import {\r\n  EVENT_MOUNTED,\r\n  EVENT_MOVE,\r\n  EVENT_MOVED,\r\n  EVENT_REFRESH,\r\n  EVENT_RESIZED,\r\n  EVENT_SHIFTED,\r\n  EVENT_UPDATED,\r\n} from '../../constants/events';\r\nimport { IDLE, MOVING } from '../../constants/states';\r\nimport { FADE, LOOP, SLIDE } from '../../constants/types';\r\nimport { EventInterface } from '../../constructors';\r\nimport { Splide } from '../../core/Splide/Splide';\r\nimport { AnyFunction, BaseComponent, Components, Options, TransitionComponent } from '../../types';\r\nimport { abs, ceil, clamp, isUndefined, rect, style } from '../../utils';\r\n\r\n\r\n/**\r\n * The interface for the Move component.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport interface MoveComponent extends BaseComponent {\r\n  move( dest: number, index: number, prev: number, callback?: AnyFunction ): void;\r\n  jump( index: number ): void;\r\n  translate( position: number, preventLoop?: boolean ): void;\r\n  shift( position: number, backwards: boolean ): number;\r\n  cancel(): void;\r\n  toIndex( position: number ): number;\r\n  toPosition( index: number, trimming?: boolean ): number;\r\n  getPosition(): number;\r\n  getLimit( max: boolean ): number;\r\n  exceededLimit( max?: boolean | undefined, position?: number ): boolean;\r\n\r\n  /** @internal */\r\n  reposition(): void;\r\n}\r\n\r\n/**\r\n * The component for moving the slider.\r\n *\r\n * @since 3.0.0\r\n *\r\n * @param Splide     - A Splide instance.\r\n * @param Components - A collection of components.\r\n * @param options    - Options.\r\n *\r\n * @return A Move component object.\r\n */\r\nexport function Move( Splide: Splide, Components: Components, options: Options ): MoveComponent {\r\n  const { on, emit } = EventInterface( Splide );\r\n  const { set } = Splide.state;\r\n  const { slideSize, getPadding, totalSize, listSize, sliderSize } = Components.Layout;\r\n  const { resolve, orient } = Components.Direction;\r\n  const { list, track } = Components.Elements;\r\n\r\n  /**\r\n   * Holds the Transition component.\r\n   */\r\n  let Transition: TransitionComponent;\r\n\r\n  /**\r\n   * Called when the component is mounted.\r\n   */\r\n  function mount(): void {\r\n    Transition = Components.Transition;\r\n    on( [ EVENT_MOUNTED, EVENT_RESIZED, EVENT_UPDATED, EVENT_REFRESH ], reposition );\r\n  }\r\n\r\n  /**\r\n   * Repositions the slider.\r\n   * - Do not call `cancel()` here because LazyLoad may emit resize while transitioning.\r\n   * - iOS Safari emits window resize event while the user swipes the slider because of the bottom bar.\r\n   */\r\n  function reposition(): void {\r\n    if ( ! Components.Controller.isBusy() ) {\r\n      Components.Scroll.cancel();\r\n      jump( Splide.index );\r\n      Components.Slides.update();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Moves the slider to the dest index with the Transition component.\r\n   *\r\n   * @param dest     - A destination index to go to, including clones'.\r\n   * @param index    - A slide index.\r\n   * @param prev     - A previous index.\r\n   * @param callback - Optional. A callback function invoked after transition ends.\r\n   */\r\n  function move( dest: number, index: number, prev: number, callback?: AnyFunction ): void {\r\n    if ( dest !== index && canShift( dest > prev ) ) {\r\n      cancel();\r\n      translate( shift( getPosition(), dest > prev ), true );\r\n    }\r\n\r\n    set( MOVING );\r\n    emit( EVENT_MOVE, index, prev, dest );\r\n\r\n    Transition.start( index, () => {\r\n      set( IDLE );\r\n      emit( EVENT_MOVED, index, prev, dest );\r\n      callback && callback();\r\n    } );\r\n  }\r\n\r\n  /**\r\n   * Jumps to the slide at the specified index.\r\n   *\r\n   * @param index - An index to jump to.\r\n   */\r\n  function jump( index: number ): void {\r\n    translate( toPosition( index, true ) );\r\n  }\r\n\r\n  /**\r\n   * Moves the slider to the provided position.\r\n   *\r\n   * @param position    - The position to move to.\r\n   * @param preventLoop - Optional. If `true`, sets the provided position as is.\r\n   */\r\n  function translate( position: number, preventLoop?: boolean ): void {\r\n    if ( ! Splide.is( FADE ) ) {\r\n      const destination = preventLoop ? position : loop( position );\r\n      style( list, 'transform', `translate${ resolve( 'X' ) }(${ destination }px)` );\r\n      position !== destination && emit( EVENT_SHIFTED );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Loops the provided position if it exceeds bounds (limit indices).\r\n   *\r\n   * @param position - A position to loop.\r\n   */\r\n  function loop( position: number ): number {\r\n    if ( Splide.is( LOOP ) ) {\r\n      const index       = toIndex( position );\r\n      const exceededMax = index > Components.Controller.getEnd();\r\n      const exceededMin = index < 0;\r\n\r\n      if ( exceededMin || exceededMax ) {\r\n        position = shift( position, exceededMax );\r\n      }\r\n    }\r\n\r\n    return position;\r\n  }\r\n\r\n  /**\r\n   * Adds or subtracts the slider width to the provided position.\r\n   *\r\n   * @param position  - A position to shift.\r\n   * @param backwards - Determines whether to shift the slider backwards or forwards.\r\n   *\r\n   * @return The shifted position.\r\n   */\r\n  function shift( position: number, backwards: boolean ): number {\r\n    const excess = position - getLimit( backwards );\r\n    const size   = sliderSize();\r\n    position -= orient( size * ( ceil( abs( excess ) / size ) || 1 ) ) * ( backwards ? 1 : -1 );\r\n    return position;\r\n  }\r\n\r\n  /**\r\n   * Cancels transition.\r\n   */\r\n  function cancel(): void {\r\n    translate( getPosition(), true );\r\n    Transition.cancel();\r\n  }\r\n\r\n  /**\r\n   * Returns the closest index to the position.\r\n   *\r\n   * @param position - A position to convert.\r\n   *\r\n   * @return The closest index to the position.\r\n   */\r\n  function toIndex( position: number ): number {\r\n    const Slides = Components.Slides.get();\r\n\r\n    let index       = 0;\r\n    let minDistance = Infinity;\r\n\r\n    for ( let i = 0; i < Slides.length; i++ ) {\r\n      const slideIndex = Slides[ i ].index;\r\n      const distance   = abs( toPosition( slideIndex, true ) - position );\r\n\r\n      if ( distance <= minDistance ) {\r\n        minDistance = distance;\r\n        index       = slideIndex;\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n\r\n    return index;\r\n  }\r\n\r\n  /**\r\n   * Converts the slide index to the position.\r\n   *\r\n   * @param index    - An index to convert.\r\n   * @param trimming - Optional. Whether to trim edge spaces or not.\r\n   *\r\n   * @return The position corresponding with the index.\r\n   */\r\n  function toPosition( index: number, trimming?: boolean ): number {\r\n    const position = orient( totalSize( index - 1 ) - offset( index ) );\r\n    return trimming ? trim( position ) : position;\r\n  }\r\n\r\n  /**\r\n   * Returns the current position.\r\n   *\r\n   * @return The position of the list element.\r\n   */\r\n  function getPosition(): number {\r\n    const left = resolve( 'left' );\r\n    return rect( list )[ left ] - rect( track )[ left ] + orient( getPadding( false ) );\r\n  }\r\n\r\n  /**\r\n   * Trims spaces on the edge of the slider.\r\n   *\r\n   * @param position - A position to trim.\r\n   *\r\n   * @return A trimmed position.\r\n   */\r\n  function trim( position: number ): number {\r\n    if ( options.trimSpace && Splide.is( SLIDE ) ) {\r\n      position = clamp( position, 0, orient( sliderSize( true ) - listSize() ) );\r\n    }\r\n\r\n    return position;\r\n  }\r\n\r\n  /**\r\n   * Returns the offset amount.\r\n   *\r\n   * @param index - An index.\r\n   */\r\n  function offset( index: number ): number {\r\n    const { focus } = options;\r\n    return focus === 'center' ? ( listSize() - slideSize( index, true ) ) / 2 : +focus * slideSize( index ) || 0;\r\n  }\r\n\r\n  /**\r\n   * Returns the limit number that the slider can move to.\r\n   *\r\n   * @param max - Determines whether to return the maximum or minimum limit.\r\n   *\r\n   * @return The border number.\r\n   */\r\n  function getLimit( max: boolean ): number {\r\n    return toPosition( max ? Components.Controller.getEnd() : 0, !! options.trimSpace );\r\n  }\r\n\r\n  /**\r\n   * Checks if there is enough width to shift the slider.\r\n   *\r\n   * @param backwards - `true` for checking backwards, or `false` for doing forwards.\r\n   *\r\n   * @return `true` if the slider can be shifted for the specified direction, or otherwise `false`.\r\n   */\r\n  function canShift( backwards: boolean ): boolean {\r\n    const shifted = orient( shift( getPosition(), backwards ) );\r\n    return backwards\r\n      ? shifted >= 0\r\n      : shifted <= list[ resolve( 'scrollWidth' ) ] - rect( track )[ resolve( 'width' ) ];\r\n  }\r\n\r\n  /**\r\n   * Checks if the provided position exceeds the minimum or maximum limit or not.\r\n   *\r\n   * @param max      - Optional. `true` for testing max, `false` for min, and `undefined` for both.\r\n   * @param position - Optional. A position to test. If omitted, tests the current position.\r\n   *\r\n   * @return `true` if the position exceeds the limit, or otherwise `false`.\r\n   */\r\n  function exceededLimit( max?: boolean | undefined, position?: number ): boolean {\r\n    position = isUndefined( position ) ? getPosition() : position;\r\n    const exceededMin = max !== true && orient( position ) < orient( getLimit( false ) );\r\n    const exceededMax = max !== false && orient( position ) > orient( getLimit( true ) );\r\n    return exceededMin || exceededMax;\r\n  }\r\n\r\n  return {\r\n    mount,\r\n    move,\r\n    jump,\r\n    translate,\r\n    shift,\r\n    cancel,\r\n    toIndex,\r\n    toPosition,\r\n    getPosition,\r\n    getLimit,\r\n    exceededLimit,\r\n    reposition,\r\n  };\r\n}\r\n","import { EVENT_END_INDEX_CHANGED, EVENT_REFRESH, EVENT_RESIZED, EVENT_UPDATED } from '../../constants/events';\r\nimport { MOVING, SCROLLING } from '../../constants/states';\r\nimport { LOOP, SLIDE } from '../../constants/types';\r\nimport { EventInterface } from '../../constructors';\r\nimport { Splide } from '../../core/Splide/Splide';\r\nimport { AnyFunction, BaseComponent, Components, Options } from '../../types';\r\nimport { apply, approximatelyEqual, between, clamp, floor, isString, isUndefined, min } from '../../utils';\r\n\r\n\r\n/**\r\n * The interface for the Controller component.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport interface ControllerComponent extends BaseComponent {\r\n  go( control: number | string, allowSameIndex?: boolean, callback?: AnyFunction ): void;\r\n  scroll( destination: number, duration?: number, snap?: boolean, callback?: AnyFunction ): void;\r\n  getNext( destination?: boolean ): number;\r\n  getPrev( destination?: boolean ): number;\r\n  getEnd(): number;\r\n  setIndex( index: number ): void;\r\n  getIndex( prev?: boolean ): number;\r\n  toIndex( page: number ): number;\r\n  toPage( index: number ): number;\r\n  toDest( position: number ): number;\r\n  hasFocus(): boolean;\r\n  isBusy(): boolean;\r\n\r\n  /** @internal */\r\n  getAdjacent( prev: boolean, destination?: boolean ): number;\r\n}\r\n\r\n/**\r\n * The component for controlling the slider.\r\n *\r\n * @since 3.0.0\r\n *\r\n * @param Splide     - A Splide instance.\r\n * @param Components - A collection of components.\r\n * @param options    - Options.\r\n *\r\n * @return A Controller component object.\r\n */\r\nexport function Controller( Splide: Splide, Components: Components, options: Options ): ControllerComponent {\r\n  const { on, emit } = EventInterface( Splide );\r\n  const { Move } = Components;\r\n  const { getPosition, getLimit, toPosition } = Move;\r\n  const { isEnough, getLength } = Components.Slides;\r\n  const { omitEnd } = options;\r\n  const isLoop  = Splide.is( LOOP );\r\n  const isSlide = Splide.is( SLIDE );\r\n  const getNext = apply( getAdjacent, false );\r\n  const getPrev = apply( getAdjacent, true );\r\n\r\n  /**\r\n   * The current index.\r\n   */\r\n  let currIndex = options.start || 0;\r\n\r\n  /**\r\n   * The latest end index.\r\n   */\r\n  let endIndex: number;\r\n\r\n  /**\r\n   * The previous index.\r\n   */\r\n  let prevIndex = currIndex;\r\n\r\n  /**\r\n   * The latest number of slides.\r\n   */\r\n  let slideCount: number;\r\n\r\n  /**\r\n   * The latest `perMove` value.\r\n   */\r\n  let perMove: number;\r\n\r\n  /**\r\n   * The latest `perMove` value.\r\n   */\r\n  let perPage: number;\r\n\r\n  /**\r\n   * Called when the component is mounted.\r\n   */\r\n  function mount(): void {\r\n    init();\r\n    on( [ EVENT_UPDATED, EVENT_REFRESH, EVENT_END_INDEX_CHANGED ], init );\r\n    on( EVENT_RESIZED, onResized );\r\n  }\r\n\r\n  /**\r\n   * Initializes some parameters.\r\n   * Needs to check the number of slides since the current index may be out of the range after refresh.\r\n   * The process order must be Elements -> Controller -> Move.\r\n   */\r\n  function init(): void {\r\n    slideCount = getLength( true );\r\n    perMove    = options.perMove;\r\n    perPage    = options.perPage;\r\n    endIndex   = getEnd();\r\n\r\n    const index = clamp( currIndex, 0, omitEnd ? endIndex : slideCount - 1 );\r\n\r\n    if ( index !== currIndex ) {\r\n      currIndex = index;\r\n      Move.reposition();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Called when the viewport width is changed.\r\n   * The end index can change if `autoWidth` or `fixedWidth` is enabled.\r\n   */\r\n  function onResized(): void {\r\n    if ( endIndex !== getEnd() ) {\r\n      emit( EVENT_END_INDEX_CHANGED );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Moves the slider by the control pattern.\r\n   *\r\n   * @see `Splide#go()`\r\n   *\r\n   * @param control        - A control pattern.\r\n   * @param allowSameIndex - Optional. Determines whether to allow going to the current index or not.\r\n   * @param callback       - Optional. A callback function invoked after transition ends.\r\n   */\r\n  function go( control: number | string, allowSameIndex?: boolean, callback?: AnyFunction ): void {\r\n    if ( ! isBusy() ) {\r\n      const dest  = parse( control );\r\n      const index = loop( dest );\r\n\r\n      if ( index > -1 && ( allowSameIndex || index !== currIndex ) ) {\r\n        setIndex( index );\r\n        Move.move( dest, index, prevIndex, callback );\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Scrolls the slider to the specified destination with updating indices.\r\n   *\r\n   * @param destination - The position to scroll the slider to.\r\n   * @param duration    - Optional. Specifies the scroll duration.\r\n   * @param snap        - Optional. Whether to snap the slider to the closest slide or not.\r\n   * @param callback    - Optional. A callback function invoked after scroll ends.\r\n   */\r\n  function scroll( destination: number, duration?: number, snap?: boolean, callback?: AnyFunction ): void {\r\n    Components.Scroll.scroll( destination, duration, snap, () => {\r\n      const index = loop( Move.toIndex( getPosition() ) );\r\n      setIndex( omitEnd ? min( index, endIndex ) : index );\r\n      callback && callback();\r\n    } );\r\n  }\r\n\r\n  /**\r\n   * Parses the control and returns a slide index.\r\n   *\r\n   * @param control - A control pattern to parse.\r\n   *\r\n   * @return A `dest` index.\r\n   */\r\n  function parse( control: number | string ): number {\r\n    let index = currIndex;\r\n\r\n    if ( isString( control ) ) {\r\n      const [ , indicator, number ] = control.match( /([+\\-<>])(\\d+)?/ ) || [];\r\n\r\n      if ( indicator === '+' || indicator === '-' ) {\r\n        index = computeDestIndex( currIndex + +`${ indicator }${ +number || 1 }`, currIndex );\r\n      } else if ( indicator === '>' ) {\r\n        index = number ? toIndex( +number ) : getNext( true );\r\n      } else if ( indicator === '<' ) {\r\n        index = getPrev( true );\r\n      }\r\n    } else {\r\n      index = isLoop ? control : clamp( control, 0, endIndex );\r\n    }\r\n\r\n    return index;\r\n  }\r\n\r\n  /**\r\n   * Returns an adjacent destination index.\r\n   *\r\n   * @internal\r\n   *\r\n   * @param prev        - Determines whether to return a previous or next index.\r\n   * @param destination - Optional. Determines whether to get a destination index or a slide one.\r\n   *\r\n   * @return An adjacent index if available, or otherwise `-1`.\r\n   */\r\n  function getAdjacent( prev: boolean, destination?: boolean ): number {\r\n    const number = perMove || ( hasFocus() ? 1 : perPage );\r\n    const dest   = computeDestIndex( currIndex + number * ( prev ? -1 : 1 ), currIndex, ! ( perMove || hasFocus() ) );\r\n\r\n    if ( dest === -1 && isSlide ) {\r\n      if ( ! approximatelyEqual( getPosition(), getLimit( ! prev ), 1 ) ) {\r\n        return prev ? 0 : endIndex;\r\n      }\r\n    }\r\n\r\n    return destination ? dest : loop( dest );\r\n  }\r\n\r\n  /**\r\n   * Converts the desired destination index to the valid one.\r\n   * - If the `move` option is `true`, finds the dest index whose position is different with the current one.\r\n   * - This may return clone indices if the editor is the loop mode,\r\n   *   or `-1` if there is no slide to go.\r\n   * - There are still slides where the carousel can go if borders are between `from` and `dest`.\r\n   * - If `focus` is available, needs to calculate the dest index even if there are enough number of slides.\r\n   *\r\n   * @param dest     - The desired destination index.\r\n   * @param from     - A base index.\r\n   * @param snapPage - Optional. Whether to snap a page or not.\r\n   *\r\n   * @return A converted destination index, including clones.\r\n   */\r\n  function computeDestIndex( dest: number, from: number, snapPage?: boolean ): number {\r\n    if ( isEnough() || hasFocus() ) {\r\n      const index = computeMovableDestIndex( dest );\r\n\r\n      if ( index !== dest ) {\r\n        from     = dest;\r\n        dest     = index;\r\n        snapPage = false;\r\n      }\r\n\r\n      if ( dest < 0 || dest > endIndex ) {\r\n        if ( ! perMove && ( between( 0, dest, from, true ) || between( endIndex, from, dest, true ) ) ) {\r\n          dest = toIndex( toPage( dest ) );\r\n        } else {\r\n          if ( isLoop ) {\r\n            dest = snapPage\r\n              ? dest < 0 ? - ( slideCount % perPage || perPage ) : slideCount\r\n              : dest;\r\n          } else if ( options.rewind ) {\r\n            dest = dest < 0 ? endIndex : 0;\r\n          } else {\r\n            dest = -1;\r\n          }\r\n        }\r\n      } else {\r\n        if ( snapPage && dest !== from ) {\r\n          dest = toIndex( toPage( from ) + ( dest < from ? -1 : 1 ) );\r\n        }\r\n      }\r\n    } else {\r\n      dest = -1;\r\n    }\r\n\r\n    return dest;\r\n  }\r\n\r\n  /**\r\n   * Finds the dest index whose position is different with the current one for `trimSpace: 'move'`.\r\n   * This can be negative or greater than `length - 1`.\r\n   *\r\n   * @param dest - A dest index.\r\n   *\r\n   * @return A dest index.\r\n   */\r\n  function computeMovableDestIndex( dest: number ): number {\r\n    if ( isSlide && options.trimSpace === 'move' && dest !== currIndex ) {\r\n      const position = getPosition();\r\n\r\n      while ( position === toPosition( dest, true ) && between( dest, 0, Splide.length - 1, ! options.rewind ) ) {\r\n        dest < currIndex ? --dest : ++dest;\r\n      }\r\n    }\r\n\r\n    return dest;\r\n  }\r\n\r\n  /**\r\n   * Loops the provided index only in the loop mode.\r\n   *\r\n   * @param index - An index to loop.\r\n   *\r\n   * @return A looped index.\r\n   */\r\n  function loop( index: number ): number {\r\n    return isLoop ? ( index + slideCount ) % slideCount || 0 : index;\r\n  }\r\n\r\n  /**\r\n   * Returns the end index where the slider can go.\r\n   * For example, if the slider has 10 slides and the `perPage` option is 3,\r\n   * the slider can go to the slide 8 (the index is 7).\r\n   * If the `omitEnd` option is available, computes the index from the slide position.\r\n   *\r\n   * @return An end index.\r\n   */\r\n  function getEnd(): number {\r\n    let end = slideCount - ( hasFocus() || ( isLoop && perMove ) ? 1 : perPage );\r\n\r\n    while ( omitEnd && end-- > 0 ) {\r\n      if ( toPosition( slideCount - 1, true ) !== toPosition( end, true ) ) {\r\n        end++;\r\n        break;\r\n      }\r\n    }\r\n\r\n    return clamp( end, 0, slideCount - 1 );\r\n  }\r\n\r\n  /**\r\n   * Converts the page index to the slide index.\r\n   *\r\n   * @param page - A page index to convert.\r\n   *\r\n   * @return A slide index.\r\n   */\r\n  function toIndex( page: number ): number {\r\n    return clamp( hasFocus() ? page : perPage * page, 0, endIndex );\r\n  }\r\n\r\n  /**\r\n   * Converts the slide index to the page index.\r\n   *\r\n   * @param index - An index to convert.\r\n   *\r\n   * @return A page index.\r\n   */\r\n  function toPage( index: number ): number {\r\n    return hasFocus()\r\n      ? min( index, endIndex )\r\n      : floor( ( index >= endIndex ? slideCount - 1 : index ) / perPage );\r\n  }\r\n\r\n  /**\r\n   * Converts the destination position to the dest index.\r\n   *\r\n   * @param destination - A position to convert.\r\n   *\r\n   * @return A dest index.\r\n   */\r\n  function toDest( destination: number ): number {\r\n    const closest = Move.toIndex( destination );\r\n    return isSlide ? clamp( closest, 0, endIndex ) : closest;\r\n  }\r\n\r\n  /**\r\n   * Sets a new index and retains old one.\r\n   *\r\n   * @param index - A new index to set.\r\n   */\r\n  function setIndex( index: number ): void {\r\n    if ( index !== currIndex ) {\r\n      prevIndex = currIndex;\r\n      currIndex = index;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the current/previous index.\r\n   *\r\n   * @param prev - Optional. Whether to return previous index or not.\r\n   */\r\n  function getIndex( prev?: boolean ): number {\r\n    return prev ? prevIndex : currIndex;\r\n  }\r\n\r\n  /**\r\n   * Verifies if the focus option is available or not.\r\n   *\r\n   * @return `true` if the slider has the focus option.\r\n   */\r\n  function hasFocus(): boolean {\r\n    return ! isUndefined( options.focus ) || options.isNavigation;\r\n  }\r\n\r\n  /**\r\n   * Checks if the slider is moving/scrolling or not.\r\n   *\r\n   * @return `true` if the slider can move, or otherwise `false`.\r\n   */\r\n  function isBusy(): boolean {\r\n    return Splide.state.is( [ MOVING, SCROLLING ] ) && !! options.waitForTransition;\r\n  }\r\n\r\n  return {\r\n    mount,\r\n    go,\r\n    scroll,\r\n    getNext,\r\n    getPrev,\r\n    getAdjacent,\r\n    getEnd,\r\n    setIndex,\r\n    getIndex,\r\n    toIndex,\r\n    toPage,\r\n    toDest,\r\n    hasFocus,\r\n    isBusy,\r\n  };\r\n}\r\n","import { ALL_ATTRIBUTES, ARIA_CONTROLS, ARIA_LABEL } from '../../constants/attributes';\r\nimport { CLASS_ARROWS } from '../../constants/classes';\r\nimport {\r\n  EVENT_ARROWS_MOUNTED,\r\n  EVENT_ARROWS_UPDATED,\r\n  EVENT_END_INDEX_CHANGED,\r\n  EVENT_MOUNTED,\r\n  EVENT_MOVED,\r\n  EVENT_REFRESH,\r\n  EVENT_SCROLLED,\r\n  EVENT_UPDATED,\r\n} from '../../constants/events';\r\nimport { EventInterface } from '../../constructors';\r\nimport { Splide } from '../../core/Splide/Splide';\r\nimport { BaseComponent, Components, Options } from '../../types';\r\nimport {\r\n  addClass,\r\n  append,\r\n  apply,\r\n  assign,\r\n  before,\r\n  create,\r\n  display,\r\n  parseHtml,\r\n  remove,\r\n  removeAttribute,\r\n  removeClass,\r\n  setAttribute,\r\n} from '../../utils';\r\nimport { PATH, SIZE, XML_NAME_SPACE } from './path';\r\n\r\n\r\n/**\r\n * The interface for the Arrows component.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport interface ArrowsComponent extends BaseComponent {\r\n  arrows: { prev?: HTMLButtonElement, next?: HTMLButtonElement };\r\n\r\n  /** @internal */\r\n  update(): void;\r\n}\r\n\r\n/**\r\n * The component for handling previous and next arrows.\r\n *\r\n * @since 3.0.0\r\n *\r\n * @param Splide     - A Splide instance.\r\n * @param Components - A collection of components.\r\n * @param options    - Options.\r\n *\r\n * @return An Arrows component object.\r\n */\r\nexport function Arrows( Splide: Splide, Components: Components, options: Options ): ArrowsComponent {\r\n  const event = EventInterface( Splide );\r\n  const { on, bind, emit } = event;\r\n  const { classes, i18n } = options;\r\n  const { Elements, Controller } = Components;\r\n  const { arrows: placeholder, track } = Elements;\r\n\r\n  /**\r\n   * The wrapper element.\r\n   */\r\n  let wrapper = placeholder;\r\n\r\n  /**\r\n   * The previous arrow element.\r\n   */\r\n  let prev = Elements.prev;\r\n\r\n  /**\r\n   * The next arrow element.\r\n   */\r\n  let next = Elements.next;\r\n\r\n  /**\r\n   * Indicates whether the component creates arrows or retrieved from the DOM.\r\n   */\r\n  let created: boolean;\r\n\r\n  /**\r\n   * Holds modifier classes.\r\n   */\r\n  let wrapperClasses: string;\r\n\r\n  /**\r\n   * An object with previous and next arrows.\r\n   */\r\n  const arrows: ArrowsComponent[ 'arrows' ] = {};\r\n\r\n  /**\r\n   * Called when the component is mounted.\r\n   */\r\n  function mount(): void {\r\n    init();\r\n    on( EVENT_UPDATED, remount );\r\n  }\r\n\r\n  /**\r\n   * Remounts the component.\r\n   */\r\n  function remount(): void {\r\n    destroy();\r\n    mount();\r\n  }\r\n\r\n  /**\r\n   * Initializes the component.\r\n   */\r\n  function init(): void {\r\n    const enabled = options.arrows;\r\n\r\n    if ( enabled && ! ( prev && next ) ) {\r\n      createArrows();\r\n    }\r\n\r\n    if ( prev && next ) {\r\n      assign( arrows, { prev, next } );\r\n      display( wrapper, enabled ? '' : 'none' );\r\n      addClass( wrapper, ( wrapperClasses = `${ CLASS_ARROWS }--${ options.direction }` ) );\r\n\r\n      if ( enabled ) {\r\n        listen();\r\n        update();\r\n        setAttribute( [ prev, next ], ARIA_CONTROLS, track.id );\r\n        emit( EVENT_ARROWS_MOUNTED, prev, next );\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Destroys the component.\r\n   */\r\n  function destroy(): void {\r\n    event.destroy();\r\n    removeClass( wrapper, wrapperClasses );\r\n\r\n    if ( created ) {\r\n      remove( placeholder ? [ prev, next ] : wrapper );\r\n      prev = next = null;\r\n    } else {\r\n      removeAttribute( [ prev, next ], ALL_ATTRIBUTES );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Listens to some events.\r\n   */\r\n  function listen(): void {\r\n    on( [ EVENT_MOUNTED, EVENT_MOVED, EVENT_REFRESH, EVENT_SCROLLED, EVENT_END_INDEX_CHANGED ], update );\r\n    bind( next, 'click', apply( go, '>' ) );\r\n    bind( prev, 'click', apply( go, '<' ) );\r\n  }\r\n\r\n  /**\r\n   * The wrapper function of Controller#go().\r\n   *\r\n   * @param control - The control pattern.\r\n   */\r\n  function go( control: string ): void {\r\n    Controller.go( control, true );\r\n  }\r\n\r\n  /**\r\n   * Create arrows and append them to the slider.\r\n   */\r\n  function createArrows(): void {\r\n    wrapper = placeholder || create( 'div', classes.arrows );\r\n    prev    = createArrow( true );\r\n    next    = createArrow( false );\r\n    created = true;\r\n\r\n    append( wrapper, [ prev, next ] );\r\n    ! placeholder && before( wrapper, track );\r\n  }\r\n\r\n  /**\r\n   * Creates an arrow button.\r\n   * In IE, A SVG element is focusable.\r\n   *\r\n   * @param prev - Determines whether to create a previous or next arrow.\r\n   *\r\n   * @return A created button element.\r\n   */\r\n  function createArrow( prev: boolean ): HTMLButtonElement {\r\n    const arrow = `<button class=\"${ classes.arrow } ${ prev ? classes.prev : classes.next }\" type=\"button\">`\r\n      +\t`<svg xmlns=\"${ XML_NAME_SPACE }\" viewBox=\"0 0 ${ SIZE } ${ SIZE }\" width=\"${ SIZE }\" height=\"${ SIZE }\" focusable=\"false\">`\r\n      + `<path d=\"${ options.arrowPath || PATH }\" />`;\r\n\r\n    return parseHtml<HTMLButtonElement>( arrow );\r\n  }\r\n\r\n  /**\r\n   * Updates status of arrows, such as `disabled` and `aria-label`.\r\n   */\r\n  function update(): void {\r\n    if ( prev && next ) {\r\n      const index     = Splide.index;\r\n      const prevIndex = Controller.getPrev();\r\n      const nextIndex = Controller.getNext();\r\n      const prevLabel = prevIndex > -1 && index < prevIndex ? i18n.last : i18n.prev;\r\n      const nextLabel = nextIndex > -1 && index > nextIndex ? i18n.first : i18n.next;\r\n\r\n      prev.disabled = prevIndex < 0;\r\n      next.disabled = nextIndex < 0;\r\n\r\n      setAttribute( prev, ARIA_LABEL, prevLabel );\r\n      setAttribute( next, ARIA_LABEL, nextLabel );\r\n\r\n      emit( EVENT_ARROWS_UPDATED, prev, next, prevIndex, nextIndex );\r\n    }\r\n  }\r\n\r\n  return {\r\n    arrows,\r\n    mount,\r\n    destroy,\r\n    update,\r\n  };\r\n}\r\n","/**\r\n * The namespace for SVG elements.\r\n */\r\nexport const XML_NAME_SPACE = 'http://www.w3.org/2000/svg';\r\n\r\n/**\r\n * The arrow path.\r\n */\r\nexport const PATH = 'm15.5 0.932-4.3 4.38 14.5 14.6-14.5 14.5 4.3 4.4 14.6-14.6 4.4-4.3-4.4-4.4-14.6-14.6z';\r\n\r\n/**\r\n * SVG width and height.\r\n */\r\nexport const SIZE = 40;\r\n","import { ARIA_CONTROLS, ARIA_LABEL } from '../../constants/attributes';\r\nimport { CLASS_ACTIVE } from '../../constants/classes';\r\nimport {\r\n  EVENT_AUTOPLAY_PAUSE,\r\n  EVENT_AUTOPLAY_PLAY,\r\n  EVENT_AUTOPLAY_PLAYING,\r\n  EVENT_MOVE,\r\n  EVENT_REFRESH,\r\n  EVENT_SCROLL,\r\n} from '../../constants/events';\r\nimport { EventInterface, RequestInterval } from '../../constructors';\r\nimport { Splide } from '../../core/Splide/Splide';\r\nimport { BaseComponent, Components, Options } from '../../types';\r\nimport { getAttribute, setAttribute, style, toggleClass } from '../../utils';\r\nimport { INTERVAL_DATA_ATTRIBUTE } from './constants';\r\n\r\n\r\n/**\r\n * The interface for the Autoplay component.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport interface AutoplayComponent extends BaseComponent {\r\n  play(): void;\r\n  pause(): void;\r\n  isPaused(): boolean;\r\n}\r\n\r\n/**\r\n * The component for autoplay, handling a progress bar and a toggle button.\r\n *\r\n * @since 3.0.0\r\n *\r\n * @param Splide     - A Splide instance.\r\n * @param Components - A collection of components.\r\n * @param options    - Options.\r\n *\r\n * @return An Autoplay component object.\r\n */\r\nexport function Autoplay( Splide: Splide, Components: Components, options: Options ): AutoplayComponent {\r\n  const { on, bind, emit } = EventInterface( Splide );\r\n  const interval = RequestInterval( options.interval, Splide.go.bind( Splide, '>' ), onAnimationFrame );\r\n  const { isPaused } = interval;\r\n  const { Elements, Elements: { root, toggle } } = Components;\r\n  const { autoplay } = options;\r\n\r\n  /**\r\n   * Indicates whether the slider is hovered or not.\r\n   */\r\n  let hovered: boolean;\r\n\r\n  /**\r\n   * Indicates whether one of slider elements has focus or not.\r\n   */\r\n  let focused: boolean;\r\n\r\n  /**\r\n   * Indicates whether the autoplay is stopped or not.\r\n   * If stopped, autoplay won't start automatically unless `play()` is explicitly called.\r\n   */\r\n  let stopped = autoplay === 'pause';\r\n\r\n  /**\r\n   * Called when the component is mounted.\r\n   */\r\n  function mount(): void {\r\n    if ( autoplay ) {\r\n      listen();\r\n      toggle && setAttribute( toggle, ARIA_CONTROLS, Elements.track.id );\r\n      stopped || play();\r\n      update();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Listens to some events.\r\n   */\r\n  function listen(): void {\r\n    if ( options.pauseOnHover ) {\r\n      bind( root, 'mouseenter mouseleave', e => {\r\n        hovered = e.type === 'mouseenter';\r\n        autoToggle();\r\n      } );\r\n    }\r\n\r\n    if ( options.pauseOnFocus ) {\r\n      bind( root, 'focusin focusout', e => {\r\n        focused = e.type === 'focusin';\r\n        autoToggle();\r\n      } );\r\n    }\r\n\r\n    if ( toggle ) {\r\n      bind( toggle, 'click', () => {\r\n        stopped ? play() : pause( true );\r\n      } );\r\n    }\r\n\r\n    on( [ EVENT_MOVE, EVENT_SCROLL, EVENT_REFRESH ], interval.rewind );\r\n    on( EVENT_MOVE, onMove );\r\n  }\r\n\r\n  /**\r\n   * Starts autoplay and clears all flags.\r\n   */\r\n  function play(): void {\r\n    if ( isPaused() && Components.Slides.isEnough() ) {\r\n      interval.start( ! options.resetProgress );\r\n      focused = hovered = stopped = false;\r\n      update();\r\n      emit( EVENT_AUTOPLAY_PLAY );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Pauses autoplay.\r\n   *\r\n   * @param stop - If `true`, autoplay keeps paused until `play()` is explicitly called.\r\n   */\r\n  function pause( stop = true ): void {\r\n    stopped = !! stop;\r\n    update();\r\n\r\n    if ( ! isPaused() ) {\r\n      interval.pause();\r\n      emit( EVENT_AUTOPLAY_PAUSE );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Toggles play/pause according to current flags.\r\n   * If autoplay is manually paused, this will do nothing.\r\n   */\r\n  function autoToggle(): void {\r\n    if ( ! stopped ) {\r\n      hovered || focused ? pause( false ) : play();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Updates the toggle button status.\r\n   */\r\n  function update(): void {\r\n    if ( toggle ) {\r\n      toggleClass( toggle, CLASS_ACTIVE, ! stopped );\r\n      setAttribute( toggle, ARIA_LABEL, options.i18n[ stopped ? 'play' : 'pause' ] );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Called on every animation frame while autoplay is active.\r\n   *\r\n   * @param rate - The progress rate between 0 and 1.\r\n   */\r\n  function onAnimationFrame( rate: number ): void {\r\n    const { bar } = Elements;\r\n    bar && style( bar, 'width', `${ rate * 100 }%` );\r\n    emit( EVENT_AUTOPLAY_PLAYING, rate );\r\n  }\r\n\r\n  /**\r\n   * Updates or restores the interval duration.\r\n   *\r\n   * @param index - An index to move to.\r\n   */\r\n  function onMove( index: number ): void {\r\n    const Slide = Components.Slides.getAt( index );\r\n    interval.set( Slide && +getAttribute( Slide.slide, INTERVAL_DATA_ATTRIBUTE ) || options.interval );\r\n  }\r\n\r\n  return {\r\n    mount,\r\n    destroy: interval.cancel,\r\n    play,\r\n    pause,\r\n    isPaused,\r\n  };\r\n}\r\n","import { EVENT_LAZYLOAD_LOADED, EVENT_MOUNTED, EVENT_REFRESH, EVENT_UPDATED } from '../../constants/events';\r\nimport { EventInterface } from '../../constructors';\r\nimport { Splide } from '../../core/Splide/Splide';\r\nimport { BaseComponent, Components, Options } from '../../types';\r\nimport { apply, child, display } from '../../utils';\r\nimport { SlideComponent } from '../Slides/Slide';\r\n\r\n\r\n/**\r\n * The interface for the Cover component.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport interface CoverComponent extends BaseComponent {\r\n}\r\n\r\n/**\r\n * The component for setting the image as the slide background.\r\n *\r\n * @since 3.0.0\r\n *\r\n * @param Splide     - A Splide instance.\r\n * @param Components - A collection of components.\r\n * @param options    - Options.\r\n *\r\n * @return A Cover component object.\r\n */\r\nexport function Cover( Splide: Splide, Components: Components, options: Options ): CoverComponent {\r\n  const { on } = EventInterface( Splide );\r\n\r\n  /**\r\n   * Called when the component is mounted.\r\n   */\r\n  function mount(): void {\r\n    if ( options.cover ) {\r\n      on( EVENT_LAZYLOAD_LOADED, apply( toggle, true ) );\r\n      on( [ EVENT_MOUNTED, EVENT_UPDATED, EVENT_REFRESH ], apply( cover, true ) );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sets/removes the background image to/from all slides.\r\n   *\r\n   * @param cover - If `false`, removes the background image.\r\n   */\r\n  function cover( cover: boolean ): void {\r\n    Components.Slides.forEach( Slide => {\r\n      const img = child<HTMLImageElement>( Slide.container || Slide.slide, 'img' );\r\n\r\n      if ( img && img.src ) {\r\n        toggle( cover, img, Slide );\r\n      }\r\n    } );\r\n  }\r\n\r\n  /**\r\n   * Sets/removes the background image to/from the parent element.\r\n   *\r\n   * @param cover - If `false`, removes the background image.\r\n   * @param img   - A target image element.\r\n   * @param Slide - A SlideComponent object where the image belongs.\r\n   */\r\n  function toggle( cover: boolean, img: HTMLImageElement, Slide: SlideComponent ): void {\r\n    Slide.style( 'background', cover ? `center/cover no-repeat url(\"${ img.src }\")` : '', true );\r\n    display( img, cover ? 'none' : '' );\r\n  }\r\n\r\n  return {\r\n    mount,\r\n    destroy: apply( cover, false ),\r\n  };\r\n}\r\n","import { EVENT_MOVE, EVENT_REFRESH, EVENT_SCROLL, EVENT_SCROLLED, EVENT_UPDATED } from '../../constants/events';\r\nimport { IDLE, SCROLLING } from '../../constants/states';\r\nimport { SLIDE } from '../../constants/types';\r\nimport { EventInterface, RequestInterval, RequestIntervalInterface } from '../../constructors';\r\nimport { Splide } from '../../core/Splide/Splide';\r\nimport { AnyFunction, BaseComponent, Components, Options } from '../../types';\r\nimport { abs, apply, approximatelyEqual, floor, max, sign } from '../../utils';\r\nimport { BASE_VELOCITY, BOUNCE_DIFF_THRESHOLD, BOUNCE_DURATION, FRICTION_FACTOR, MIN_DURATION } from './constants';\r\n\r\n\r\n/**\r\n * The interface for the Scroll component.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport interface ScrollComponent extends BaseComponent {\r\n  scroll( position: number, duration?: number, snap?: boolean, callback?: AnyFunction ): void;\r\n  cancel(): void;\r\n}\r\n\r\n/**\r\n * The component for scrolling the slider.\r\n *\r\n * @since 3.0.0\r\n *\r\n * @param Splide     - A Splide instance.\r\n * @param Components - A collection of components.\r\n * @param options    - Options.\r\n *\r\n * @return A Scroll component object.\r\n */\r\nexport function Scroll( Splide: Splide, Components: Components, options: Options ): ScrollComponent {\r\n  const { on, emit } = EventInterface( Splide );\r\n  const { state: { set } } = Splide;\r\n  const { Move } = Components;\r\n  const { getPosition, getLimit, exceededLimit, translate } = Move;\r\n  const isSlide = Splide.is( SLIDE );\r\n\r\n  /**\r\n   * Retains the active RequestInterval object.\r\n   */\r\n  let interval: RequestIntervalInterface;\r\n\r\n  /**\r\n   * Holds the callback function.\r\n   */\r\n  let callback: AnyFunction;\r\n\r\n  /**\r\n   * The current friction (<= 1).\r\n   */\r\n  let friction = 1;\r\n\r\n  /**\r\n   * Called when the component is mounted.\r\n   */\r\n  function mount(): void {\r\n    on( EVENT_MOVE, clear );\r\n    on( [ EVENT_UPDATED, EVENT_REFRESH ], cancel );\r\n  }\r\n\r\n  /**\r\n   * Scrolls the slider to the provided destination.\r\n   *\r\n   * @param destination - The destination to scroll the slider to.\r\n   * @param duration    - Optional. The scroll duration. If omitted, calculates it by the distance.\r\n   * @param snap        - Optional. Whether to snap the slider to the closest slide or not.\r\n   * @param onScrolled  - Optional. A callback invoked after scroll ends.\r\n   * @param noConstrain - Optional. Whether to suppress constraint process when the slider exceeds bounds.\r\n   */\r\n  function scroll(\r\n    destination: number,\r\n    duration?: number,\r\n    snap?: boolean,\r\n    onScrolled?: AnyFunction,\r\n    noConstrain?: boolean\r\n  ): void {\r\n    const from = getPosition();\r\n\r\n    clear();\r\n\r\n    if ( snap && ( ! isSlide || ! exceededLimit() ) ) {\r\n      const size   = Components.Layout.sliderSize();\r\n      const offset = sign( destination ) * size * floor( abs( destination ) / size ) || 0;\r\n      destination = Move.toPosition( Components.Controller.toDest( destination % size ) ) + offset;\r\n    }\r\n\r\n    const noDistance = approximatelyEqual( from, destination, 1 );\r\n\r\n    friction = 1;\r\n    duration = noDistance ? 0 : duration || max( abs( destination - from ) / BASE_VELOCITY, MIN_DURATION );\r\n    callback = onScrolled;\r\n    interval = RequestInterval( duration, onEnd, apply( update, from, destination, noConstrain ), 1 );\r\n\r\n    set( SCROLLING );\r\n    emit( EVENT_SCROLL );\r\n    interval.start();\r\n  }\r\n\r\n  /**\r\n   * Called when scroll ends or has been just canceled.\r\n   */\r\n  function onEnd(): void {\r\n    set( IDLE );\r\n    callback && callback();\r\n    emit( EVENT_SCROLLED );\r\n  }\r\n\r\n  /**\r\n   * Called whenever the interval timer is updated.\r\n   *\r\n   * @param from        - A position where scroll starts.\r\n   * @param to          - A destination where the slider goes.\r\n   * @param noConstrain - Whether to suppress constraint process when the slider exceeds bounds.\r\n   * @param rate        - A current rate.\r\n   */\r\n  function update( from: number, to: number, noConstrain: boolean | undefined, rate: number ): void {\r\n    const position = getPosition();\r\n    const target   = from + ( to - from ) * easing( rate );\r\n    const diff     = ( target - position ) * friction;\r\n\r\n    translate( position + diff );\r\n\r\n    if ( isSlide && ! noConstrain && exceededLimit() ) {\r\n      friction *= FRICTION_FACTOR;\r\n\r\n      if ( abs( diff ) < BOUNCE_DIFF_THRESHOLD ) {\r\n        scroll( getLimit( exceededLimit( true ) ), BOUNCE_DURATION, false, callback, true );\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clears the active interval.\r\n   */\r\n  function clear(): void {\r\n    if ( interval ) {\r\n      interval.cancel();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Cancels the active interval and emits the `scrolled` event.\r\n   */\r\n  function cancel(): void {\r\n    if ( interval && ! interval.isPaused() ) {\r\n      clear();\r\n      onEnd();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The easing function.\r\n   *\r\n   * @param t - A value to ease.\r\n   *\r\n   * @return An eased value.\r\n   */\r\n  function easing( t: number ): number {\r\n    const { easingFunc } = options;\r\n    return easingFunc ? easingFunc( t ) : 1 - Math.pow( 1 - t, 4 );\r\n  }\r\n\r\n  return {\r\n    mount,\r\n    destroy: clear,\r\n    scroll,\r\n    cancel,\r\n  };\r\n}\r\n","/**\r\n * Triggers the bounce effect when the diff becomes less than this value.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport const BOUNCE_DIFF_THRESHOLD = 10;\r\n\r\n/**\r\n * The duration of the bounce effect.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport const BOUNCE_DURATION = 600;\r\n\r\n/**\r\n * The friction factor.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport const FRICTION_FACTOR = 0.6;\r\n\r\n/**\r\n * The velocity to calculate the scroll duration.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport const BASE_VELOCITY = 1.5;\r\n\r\n/**\r\n * The minimum duration of scroll.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport const MIN_DURATION = 800;\r\n","import { CLASS_ARROW, CLASS_PAGINATION_PAGE } from '../../constants/classes';\r\nimport { EVENT_DRAG, EVENT_DRAGGED, EVENT_DRAGGING, EVENT_MOUNTED, EVENT_UPDATED } from '../../constants/events';\r\nimport { SCROLL_LISTENER_OPTIONS } from '../../constants/listener-options';\r\nimport { DRAGGING, IDLE, MOVING, SCROLLING } from '../../constants/states';\r\nimport { FADE, LOOP, SLIDE } from '../../constants/types';\r\nimport { EventInterface } from '../../constructors';\r\nimport { Splide } from '../../core/Splide/Splide';\r\nimport { BaseComponent, Components, Options } from '../../types';\r\nimport { abs, isObject, matches, min, noop, prevent, sign, timeOf } from '../../utils';\r\nimport { FRICTION, LOG_INTERVAL, POINTER_DOWN_EVENTS, POINTER_MOVE_EVENTS, POINTER_UP_EVENTS } from './constants';\r\n\r\n\r\n/**\r\n * The interface for the Drag component.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport interface DragComponent extends BaseComponent {\r\n  disable( disabled: boolean ): void;\r\n  isDragging(): boolean;\r\n}\r\n\r\n/**\r\n * The component for dragging the slider.\r\n *\r\n * @since 3.0.0\r\n *\r\n * @param Splide     - A Splide instance.\r\n * @param Components - A collection of components.\r\n * @param options    - Options.\r\n *\r\n * @return A Drag component object.\r\n */\r\nexport function Drag( Splide: Splide, Components: Components, options: Options ): DragComponent {\r\n  const { on, emit, bind, unbind } = EventInterface( Splide );\r\n  const { state } = Splide;\r\n  const { Move, Scroll, Controller, Elements: { track }, Media: { reduce } } = Components;\r\n  const { resolve, orient } = Components.Direction;\r\n  const { getPosition, exceededLimit } = Move;\r\n\r\n  /**\r\n   * The base slider position to calculate the delta of coords.\r\n   */\r\n  let basePosition: number;\r\n\r\n  /**\r\n   * The base event object saved per specific sampling interval.\r\n   */\r\n  let baseEvent: TouchEvent | MouseEvent;\r\n\r\n  /**\r\n   * Holds the previous base event object.\r\n   */\r\n  let prevBaseEvent: TouchEvent | MouseEvent;\r\n\r\n  /**\r\n   * Indicates whether the drag mode is `free` or not.\r\n   */\r\n  let isFree: boolean;\r\n\r\n  /**\r\n   * Indicates whether the user is dragging the slider or not.\r\n   */\r\n  let dragging: boolean;\r\n\r\n  /**\r\n   * Indicates whether the slider exceeds limits or not.\r\n   * This must not be `undefined` for strict comparison.\r\n   */\r\n  let exceeded = false;\r\n\r\n  /**\r\n   * Turns into `true` when the user starts dragging the slider.\r\n   */\r\n  let clickPrevented: boolean;\r\n\r\n  /**\r\n   * Indicates whether the drag component is now disabled or not.\r\n   */\r\n  let disabled: boolean;\r\n\r\n  /**\r\n   * The target element to attach listeners.\r\n   */\r\n  let target: Window | HTMLElement;\r\n\r\n  /**\r\n   * Called when the component is mounted.\r\n   */\r\n  function mount(): void {\r\n    bind( track, POINTER_MOVE_EVENTS, noop, SCROLL_LISTENER_OPTIONS );\r\n    bind( track, POINTER_UP_EVENTS, noop, SCROLL_LISTENER_OPTIONS );\r\n    bind( track, POINTER_DOWN_EVENTS, onPointerDown, SCROLL_LISTENER_OPTIONS );\r\n    bind( track, 'click', onClick, { capture: true } );\r\n    bind( track, 'dragstart', prevent );\r\n    on( [ EVENT_MOUNTED, EVENT_UPDATED ], init );\r\n  }\r\n\r\n  /**\r\n   * Initializes the component.\r\n   */\r\n  function init(): void {\r\n    const { drag } = options;\r\n    disable( ! drag );\r\n    isFree = drag === 'free';\r\n  }\r\n\r\n  /**\r\n   * Called when the user clicks or touches the slider.\r\n   * - Needs to prevent the default behaviour when the slider is busy to deny any action, such as dragging images\r\n   * - IE does not support MouseEvent and TouchEvent constructors\r\n   * - The `dragging` state always becomes `true` when the user starts dragging while the slider is moving\r\n   *\r\n   * @param e - A TouchEvent or MouseEvent object\r\n   */\r\n  function onPointerDown( e: TouchEvent | MouseEvent ): void {\r\n    clickPrevented = false;\r\n\r\n    if ( ! disabled ) {\r\n      const isTouch = isTouchEvent( e );\r\n\r\n      if ( isDraggable( e.target ) && ( isTouch || ! e.button ) ) {\r\n        if ( ! Controller.isBusy() ) {\r\n          target        = isTouch ? track : window;\r\n          dragging      = state.is( [ MOVING, SCROLLING ] );\r\n          prevBaseEvent = null;\r\n\r\n          bind( target, POINTER_MOVE_EVENTS, onPointerMove, SCROLL_LISTENER_OPTIONS );\r\n          bind( target, POINTER_UP_EVENTS, onPointerUp, SCROLL_LISTENER_OPTIONS );\r\n          Move.cancel();\r\n          Scroll.cancel();\r\n          save( e );\r\n        } else {\r\n          prevent( e, true );\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Called while the user moves the pointer on the slider.\r\n   *\r\n   * @param e - A TouchEvent or MouseEvent object\r\n   */\r\n  function onPointerMove( e: TouchEvent | MouseEvent ): void {\r\n    if ( ! state.is( DRAGGING ) ) {\r\n      state.set( DRAGGING );\r\n      emit( EVENT_DRAG );\r\n    }\r\n\r\n    if ( e.cancelable ) {\r\n      if ( dragging ) {\r\n        Move.translate( basePosition + constrain( diffCoord( e ) ) );\r\n\r\n        const expired     = diffTime( e ) > LOG_INTERVAL;\r\n        const hasExceeded = exceeded !== ( exceeded = exceededLimit() );\r\n\r\n        if ( expired || hasExceeded ) {\r\n          save( e );\r\n        }\r\n\r\n        clickPrevented = true;\r\n        emit( EVENT_DRAGGING );\r\n        prevent( e );\r\n      } else if ( isSliderDirection( e ) ) {\r\n        dragging = shouldStart( e );\r\n        prevent( e );\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Called when the user releases pointing devices.\r\n   * Needs to move the slider when:\r\n   * - The user drags the slider and the distance exceeds the threshold\r\n   * - The user aborted the slider moving by pointerdown and just released it without dragging the slider\r\n   *\r\n   * @param e - A TouchEvent or MouseEvent object\r\n   */\r\n  function onPointerUp( e: TouchEvent | MouseEvent ): void {\r\n    if ( state.is( DRAGGING ) ) {\r\n      state.set( IDLE );\r\n      emit( EVENT_DRAGGED );\r\n    }\r\n\r\n    if ( dragging ) {\r\n      move( e );\r\n      prevent( e );\r\n    }\r\n\r\n    unbind( target, POINTER_MOVE_EVENTS, onPointerMove );\r\n    unbind( target, POINTER_UP_EVENTS, onPointerUp );\r\n    dragging = false;\r\n  }\r\n\r\n  /**\r\n   * Called when the track element is clicked.\r\n   * Disables click any elements inside it while dragging.\r\n   *\r\n   * @param e - A MouseEvent object.\r\n   */\r\n  function onClick( e: MouseEvent ): void {\r\n    if ( ! disabled && clickPrevented ) {\r\n      prevent( e, true );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Saves data at the specific moment.\r\n   *\r\n   * @param e - A TouchEvent or MouseEvent object.\r\n   */\r\n  function save( e: TouchEvent | MouseEvent ): void {\r\n    prevBaseEvent = baseEvent;\r\n    baseEvent     = e;\r\n    basePosition  = getPosition();\r\n  }\r\n\r\n  /**\r\n   * Calculates the destination by the drag velocity and moves the carousel.\r\n   * If motion is reduced, restores transition speed to the initial value\r\n   * because it's \"essential\" motion for the user to recognize what happens on the carousel.\r\n   *\r\n   * @param e - A TouchEvent or MouseEvent object.\r\n   */\r\n  function move( e: TouchEvent | MouseEvent ): void {\r\n    const velocity    = computeVelocity( e );\r\n    const destination = computeDestination( velocity );\r\n    const rewind      = options.rewind && options.rewindByDrag;\r\n\r\n    reduce( false );\r\n\r\n    if ( isFree ) {\r\n      Controller.scroll( destination, 0, options.snap );\r\n    } else if ( Splide.is( FADE ) ) {\r\n      Controller.go( orient( sign( velocity ) ) < 0 ? ( rewind ? '<' : '-' ) : ( rewind ? '>' : '+' ) );\r\n    } else if ( Splide.is( SLIDE ) && exceeded && rewind ) {\r\n      Controller.go( exceededLimit( true ) ? '>' : '<' );\r\n    } else {\r\n      Controller.go( Controller.toDest( destination ), true );\r\n    }\r\n\r\n    reduce( true );\r\n  }\r\n\r\n  /**\r\n   * Checks if the drag distance exceeds the defined threshold.\r\n   *\r\n   * @param e - A TouchEvent or MouseEvent object.\r\n   *\r\n   * @return `true` if the distance exceeds the threshold, or `false` if not.\r\n   */\r\n  function shouldStart( e: TouchEvent | MouseEvent ): boolean {\r\n    const { dragMinThreshold: thresholds } = options;\r\n    const isObj = isObject( thresholds );\r\n    const mouse = isObj && thresholds.mouse || 0;\r\n    const touch = ( isObj ? thresholds.touch : +thresholds ) || 10;\r\n    return abs( diffCoord( e ) ) > ( isTouchEvent( e ) ? touch : mouse );\r\n  }\r\n\r\n  /**\r\n   * Checks whether dragging towards the slider or the scroll direction.\r\n   *\r\n   * @return `true` if dragging towards the slider direction, or otherwise `false`.\r\n   *\r\n   * @param e - A TouchEvent or MouseEvent object\r\n   */\r\n  function isSliderDirection( e: TouchEvent | MouseEvent ): boolean {\r\n    return abs( diffCoord( e ) ) > abs( diffCoord( e, true ) );\r\n  }\r\n\r\n  /**\r\n   * Computes the drag velocity.\r\n   *\r\n   * @param e - A TouchEvent or MouseEvent object\r\n   *\r\n   * @return The drag velocity.\r\n   */\r\n  function computeVelocity( e: TouchEvent | MouseEvent ): number {\r\n    if ( Splide.is( LOOP ) || ! exceeded ) {\r\n      const time = diffTime( e );\r\n\r\n      if ( time && time < LOG_INTERVAL ) {\r\n        return diffCoord( e ) / time;\r\n      }\r\n    }\r\n\r\n    return 0;\r\n  }\r\n\r\n  /**\r\n   * Computes the destination by the velocity and the `flickPower` option.\r\n   *\r\n   * @param velocity - The drag velocity.\r\n   *\r\n   * @return The destination.\r\n   */\r\n  function computeDestination( velocity: number ): number {\r\n    return getPosition() + sign( velocity ) * min(\r\n      abs( velocity ) * ( options.flickPower || 600 ),\r\n      isFree ? Infinity : Components.Layout.listSize() * ( options.flickMaxPages || 1 )\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Returns the coord difference between the provided and base events.\r\n   *\r\n   * @param e          - A TouchEvent or MouseEvent object.\r\n   * @param orthogonal - Optional. If `true`, returns the coord of the orthogonal axis against the drag one.\r\n   *\r\n   * @return The difference of the coord.\r\n   */\r\n  function diffCoord( e: TouchEvent | MouseEvent, orthogonal?: boolean ): number {\r\n    return coordOf( e, orthogonal ) - coordOf( getBaseEvent( e ), orthogonal );\r\n  }\r\n\r\n  /**\r\n   * Returns the elapsed time from the base event to `e`.\r\n   *\r\n   * @param e - A TouchEvent or MouseEvent object.\r\n   *\r\n   * @return The elapsed time in milliseconds.\r\n   */\r\n  function diffTime( e: TouchEvent | MouseEvent ): number {\r\n    return timeOf( e ) - timeOf( getBaseEvent( e ) );\r\n  }\r\n\r\n  /**\r\n   * Returns the base event.\r\n   * If the base event is same with `e`, returns previous one.\r\n   *\r\n   * @param e - A TouchEvent or MouseEvent object.\r\n   *\r\n   * @return A base event.\r\n   */\r\n  function getBaseEvent( e: TouchEvent | MouseEvent ): TouchEvent | MouseEvent {\r\n    return baseEvent === e && prevBaseEvent || baseEvent;\r\n  }\r\n\r\n  /**\r\n   * Returns the `pageX` and `pageY` coordinates provided by the event.\r\n   * Be aware that IE does not support both TouchEvent and MouseEvent constructors.\r\n   *\r\n   * @param e          - A TouchEvent or MouseEvent object.\r\n   * @param orthogonal - Optional. If `true`, returns the coord of the orthogonal axis against the drag one.\r\n   *\r\n   * @return A pageX or pageY coordinate.\r\n   */\r\n  function coordOf( e: TouchEvent | MouseEvent, orthogonal?: boolean ): number {\r\n    return ( isTouchEvent( e ) ? e.changedTouches[ 0 ] : e )[ `page${ resolve( orthogonal ? 'Y' : 'X' ) }` ];\r\n  }\r\n\r\n  /**\r\n   * Reduces the distance to move by the predefined friction.\r\n   * This does nothing when the slider type is not `slide`, or the position is inside borders.\r\n   *\r\n   * @param diff - Diff to constrain.\r\n   *\r\n   * @return The constrained diff.\r\n   */\r\n  function constrain( diff: number ): number {\r\n    return diff / ( exceeded && Splide.is( SLIDE ) ? FRICTION : 1 );\r\n  }\r\n\r\n  /**\r\n   * Returns `true` if the user can drag the target.\r\n   *\r\n   * @param target - An event target.\r\n   *\r\n   * @return `true` if the target is draggable.\r\n   */\r\n  function isDraggable( target: EventTarget ): boolean {\r\n    const { noDrag } = options;\r\n\r\n    return ! matches( target, `.${ CLASS_PAGINATION_PAGE }, .${ CLASS_ARROW }` )\r\n      && ( ! noDrag || ! matches( target, noDrag ) );\r\n  }\r\n\r\n  /**\r\n   * Checks if the provided event is TouchEvent or MouseEvent.\r\n   *\r\n   * @param e - An event to check.\r\n   *\r\n   * @return `true` if the `e` is TouchEvent.\r\n   */\r\n  function isTouchEvent( e: TouchEvent | MouseEvent ): e is TouchEvent {\r\n    return typeof TouchEvent !== 'undefined' && e instanceof TouchEvent;\r\n  }\r\n\r\n  /**\r\n   * Checks if now the user is dragging the slider or not.\r\n   *\r\n   * @return `true` if the user is dragging the slider or otherwise `false`.\r\n   */\r\n  function isDragging(): boolean {\r\n    return dragging;\r\n  }\r\n\r\n  /**\r\n   * Disables the component.\r\n   *\r\n   * @param value - Set `true` to disable the component.\r\n   */\r\n  function disable( value: boolean ): void {\r\n    disabled = value;\r\n  }\r\n\r\n  return {\r\n    mount,\r\n    disable,\r\n    isDragging,\r\n  };\r\n}\r\n","import { CLASS_LOADING } from '../../constants/classes';\r\nimport {\r\n  EVENT_LAZYLOAD_LOADED,\r\n  EVENT_MOVED,\r\n  EVENT_REFRESH,\r\n  EVENT_RESIZE,\r\n  EVENT_SCROLLED,\r\n} from '../../constants/events';\r\nimport { EventInterface } from '../../constructors';\r\nimport { Splide } from '../../core/Splide/Splide';\r\nimport { BaseComponent, Components, Options } from '../../types';\r\nimport {\r\n  addClass,\r\n  apply,\r\n  child,\r\n  create,\r\n  display,\r\n  empty,\r\n  getAttribute,\r\n  queryAll,\r\n  remove,\r\n  removeAttribute,\r\n  removeClass,\r\n  setAttribute,\r\n} from '../../utils';\r\nimport { SlideComponent } from '../Slides/Slide';\r\nimport { IMAGE_SELECTOR, SRC_DATA_ATTRIBUTE, SRCSET_DATA_ATTRIBUTE } from './constants';\r\n\r\n\r\n/**\r\n * The interface for the LazyLoad component.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport interface LazyLoadComponent extends BaseComponent {\r\n  /** @internal */\r\n  check(): void;\r\n}\r\n\r\n/**\r\n * The type for each entry.\r\n * Use a tuple for better compression.\r\n *\r\n * @since 4.0.0\r\n */\r\ntype LazyLoadEntry = [ HTMLImageElement, SlideComponent, HTMLSpanElement ];\r\n\r\n/**\r\n * The component for lazily loading images.\r\n *\r\n * @since 3.0.0\r\n *\r\n * @param Splide     - A Splide instance.\r\n * @param Components - A collection of components.\r\n * @param options    - Options.\r\n *\r\n * @return An LazyLoad component object.\r\n */\r\nexport function LazyLoad( Splide: Splide, Components: Components, options: Options ): LazyLoadComponent {\r\n  const { on, off, bind, emit } = EventInterface( Splide );\r\n  const isSequential = options.lazyLoad === 'sequential';\r\n  const events       = [ EVENT_MOVED, EVENT_SCROLLED ];\r\n\r\n  /**\r\n   * Stores data of images.\r\n   */\r\n  let entries: LazyLoadEntry[] = [];\r\n\r\n  /**\r\n   * Called when the component is mounted.\r\n   */\r\n  function mount(): void {\r\n    if ( options.lazyLoad ) {\r\n      init();\r\n      on( EVENT_REFRESH, init );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Initializes the component and start loading images.\r\n   * Be aware that `refresh` also calls this method.\r\n   */\r\n  function init() {\r\n    empty( entries );\r\n    register();\r\n\r\n    if ( isSequential ) {\r\n      loadNext();\r\n    } else {\r\n      off( events );\r\n      on( events, check );\r\n      check();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Finds images and register them as entries with creating spinner elements.\r\n   * Note that spinner can be already available because of `refresh()`.\r\n   */\r\n  function register(): void {\r\n    Components.Slides.forEach( Slide => {\r\n      queryAll<HTMLImageElement>( Slide.slide, IMAGE_SELECTOR ).forEach( img => {\r\n        const src    = getAttribute( img, SRC_DATA_ATTRIBUTE );\r\n        const srcset = getAttribute( img, SRCSET_DATA_ATTRIBUTE );\r\n\r\n        if ( src !== img.src || srcset !== img.srcset ) {\r\n          const className = options.classes.spinner;\r\n          const parent    = img.parentElement;\r\n          const spinner   = child( parent, `.${ className }` ) || create( 'span', className, parent );\r\n\r\n          entries.push( [ img, Slide, spinner ] );\r\n          img.src || display( img, 'none' );\r\n        }\r\n      } );\r\n    } );\r\n  }\r\n\r\n  /**\r\n   * Checks how close each image is from the active slide, and determines whether to start loading or not.\r\n   * The last `+1` is for the current page.\r\n   */\r\n  function check(): void {\r\n    entries = entries.filter( data => {\r\n      const distance = options.perPage * ( ( options.preloadPages || 1 ) + 1 ) - 1;\r\n      return data[ 1 ].isWithin( Splide.index, distance ) ? load( data ) : true;\r\n    } );\r\n\r\n    entries.length || off( events );\r\n  }\r\n\r\n  /**\r\n   * Starts loading the image in the provided data.\r\n   *\r\n   * @param data - A LazyLoadEntry object.\r\n   */\r\n  function load( data: LazyLoadEntry ): void {\r\n    const [ img ] = data;\r\n\r\n    addClass( data[ 1 ].slide, CLASS_LOADING );\r\n    bind( img, 'load error', apply( onLoad, data ) );\r\n\r\n    setAttribute( img, 'src', getAttribute( img, SRC_DATA_ATTRIBUTE ) );\r\n    setAttribute( img, 'srcset', getAttribute( img, SRCSET_DATA_ATTRIBUTE ) );\r\n    removeAttribute( img, SRC_DATA_ATTRIBUTE );\r\n    removeAttribute( img, SRCSET_DATA_ATTRIBUTE );\r\n  }\r\n\r\n  /**\r\n   * Called when the image is loaded or any error occurs.\r\n   *\r\n   * @param data - A LazyLoadEntry object.\r\n   * @param e    - An Event object.\r\n   */\r\n  function onLoad( data: LazyLoadEntry, e: Event ): void {\r\n    const [ img, Slide ] = data;\r\n\r\n    removeClass( Slide.slide, CLASS_LOADING );\r\n\r\n    if ( e.type !== 'error' ) {\r\n      remove( data[ 2 ] );\r\n      display( img, '' );\r\n      emit( EVENT_LAZYLOAD_LOADED, img, Slide );\r\n      emit( EVENT_RESIZE );\r\n    }\r\n\r\n    isSequential && loadNext();\r\n  }\r\n\r\n  /**\r\n   * Starts loading a next image.\r\n   */\r\n  function loadNext(): void {\r\n    entries.length && load( entries.shift() );\r\n  }\r\n\r\n  return {\r\n    mount,\r\n    destroy: apply( empty, entries ),\r\n    check,\r\n  };\r\n}\r\n","import { ARROW_LEFT, ARROW_RIGHT } from '../../constants/arrows';\r\nimport {\r\n  ARIA_CONTROLS,\r\n  ARIA_LABEL,\r\n  ARIA_ORIENTATION,\r\n  ARIA_SELECTED,\r\n  ROLE,\r\n  TAB_INDEX,\r\n} from '../../constants/attributes';\r\nimport { CLASS_ACTIVE, CLASS_PAGINATION } from '../../constants/classes';\r\nimport { TTB } from '../../constants/directions';\r\nimport {\r\n  EVENT_END_INDEX_CHANGED,\r\n  EVENT_MOVE,\r\n  EVENT_PAGINATION_MOUNTED,\r\n  EVENT_PAGINATION_UPDATED,\r\n  EVENT_REFRESH,\r\n  EVENT_SCROLL,\r\n  EVENT_SCROLLED,\r\n  EVENT_UPDATED,\r\n} from '../../constants/events';\r\nimport { EventInterface } from '../../constructors';\r\nimport { Splide } from '../../core/Splide/Splide';\r\nimport { BaseComponent, Components, Options } from '../../types';\r\nimport {\r\n  addClass,\r\n  apply,\r\n  ceil,\r\n  create,\r\n  display,\r\n  empty,\r\n  focus,\r\n  format,\r\n  prevent,\r\n  remove,\r\n  removeAttribute,\r\n  removeClass,\r\n  setAttribute,\r\n  slice,\r\n} from '../../utils';\r\nimport { normalizeKey } from '../../utils/dom/normalizeKey/normalizeKey';\r\n\r\n\r\n/**\r\n * The interface for the Pagination component.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport interface PaginationComponent extends BaseComponent {\r\n  items: PaginationItem[];\r\n  getAt( index: number ): PaginationItem;\r\n  update(): void;\r\n}\r\n\r\n/**\r\n * The interface for data of the pagination.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport interface PaginationData {\r\n  list: HTMLUListElement;\r\n  items: PaginationItem[];\r\n}\r\n\r\n/**\r\n * The interface for each pagination item.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport interface PaginationItem {\r\n  li: HTMLLIElement;\r\n  button: HTMLButtonElement;\r\n  page: number;\r\n}\r\n\r\n/**\r\n * The component for the pagination UI (a slide picker).\r\n *\r\n * @link https://www.w3.org/TR/2021/NOTE-wai-aria-practices-1.2-20211129/#grouped-carousel-elements\r\n * @since 3.0.0\r\n *\r\n * @param Splide     - A Splide instance.\r\n * @param Components - A collection of components.\r\n * @param options    - Options.\r\n *\r\n * @return A Pagination component object.\r\n */\r\nexport function Pagination( Splide: Splide, Components: Components, options: Options ): PaginationComponent {\r\n  const event = EventInterface( Splide );\r\n  const { on, emit, bind } = event;\r\n  const { Slides, Elements, Controller } = Components;\r\n  const { hasFocus, getIndex, go } = Controller;\r\n  const { resolve } = Components.Direction;\r\n  const { pagination: placeholder } = Elements;\r\n\r\n  /**\r\n   * Stores all pagination items.\r\n   */\r\n  const items: PaginationItem[] = [];\r\n\r\n  /**\r\n   * The pagination element.\r\n   */\r\n  let list: HTMLUListElement | null;\r\n\r\n  /**\r\n   * Holds modifier classes.\r\n   */\r\n  let paginationClasses: string;\r\n\r\n  /**\r\n   * Called when the component is mounted.\r\n   */\r\n  function mount(): void {\r\n    destroy();\r\n    on( [ EVENT_UPDATED, EVENT_REFRESH, EVENT_END_INDEX_CHANGED ], mount );\r\n\r\n    const enabled = options.pagination;\r\n    placeholder && display( placeholder, enabled ? '' : 'none' );\r\n\r\n    if ( enabled ) {\r\n      on( [ EVENT_MOVE, EVENT_SCROLL, EVENT_SCROLLED ], update );\r\n      createPagination();\r\n      update();\r\n      emit( EVENT_PAGINATION_MOUNTED, { list, items }, getAt( Splide.index ) );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Destroys the component.\r\n   */\r\n  function destroy(): void {\r\n    if ( list ) {\r\n      remove( placeholder ? slice( list.children ) : list );\r\n      removeClass( list, paginationClasses );\r\n      empty( items );\r\n      list = null;\r\n    }\r\n\r\n    event.destroy();\r\n  }\r\n\r\n  /**\r\n   * Creates the pagination element and appends it to the slider.\r\n   */\r\n  function createPagination(): void {\r\n    const { length } = Splide;\r\n    const { classes, i18n, perPage } = options;\r\n    const max = hasFocus() ? Controller.getEnd() + 1 : ceil( length / perPage );\r\n\r\n    list = placeholder || create( 'ul', classes.pagination, Elements.track.parentElement );\r\n\r\n    addClass( list, ( paginationClasses = `${ CLASS_PAGINATION }--${ getDirection() }` ) );\r\n    setAttribute( list, ROLE, 'tablist' );\r\n    setAttribute( list, ARIA_LABEL, i18n.select );\r\n    setAttribute( list, ARIA_ORIENTATION, getDirection() === TTB ? 'vertical' : '' );\r\n\r\n    for ( let i = 0; i < max; i++ ) {\r\n      const li       = create( 'li', null, list );\r\n      const button   = create( 'button', { class: classes.page, type: 'button' }, li );\r\n      const controls = Slides.getIn( i ).map( Slide => Slide.slide.id );\r\n      const text     = ! hasFocus() && perPage > 1 ? i18n.pageX : i18n.slideX;\r\n\r\n      bind( button, 'click', apply( onClick, i ) );\r\n\r\n      if ( options.paginationKeyboard ) {\r\n        bind( button, 'keydown', apply( onKeydown, i ) );\r\n      }\r\n\r\n      setAttribute( li, ROLE, 'presentation' );\r\n      setAttribute( button, ROLE, 'tab' );\r\n      setAttribute( button, ARIA_CONTROLS, controls.join( ' ' ) );\r\n      setAttribute( button, ARIA_LABEL, format( text, i + 1 ) );\r\n      setAttribute( button, TAB_INDEX, -1 );\r\n\r\n      items.push( { li, button, page: i } );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Called when the user clicks each pagination dot.\r\n   * Moves the focus to the active slide for accessibility.\r\n   *\r\n   * @link https://www.w3.org/WAI/tutorials/carousels/functionality/\r\n   *\r\n   * @param page - A clicked page index.\r\n   */\r\n  function onClick( page: number ): void {\r\n    go( `>${ page }`, true );\r\n  }\r\n\r\n  /**\r\n   * Called when any key is pressed on the pagination.\r\n   *\r\n   * @link https://www.w3.org/TR/2021/NOTE-wai-aria-practices-1.2-20211129/#keyboard-interaction-21\r\n   *\r\n   * @param page - A page index.\r\n   * @param e    - A KeyboardEvent object.\r\n   */\r\n  function onKeydown( page: number, e: KeyboardEvent ): void {\r\n    const { length } = items;\r\n    const key = normalizeKey( e );\r\n    const dir = getDirection();\r\n\r\n    let nextPage = -1;\r\n\r\n    if ( key === resolve( ARROW_RIGHT, false, dir ) ) {\r\n      nextPage = ++page % length;\r\n    } else if ( key === resolve( ARROW_LEFT, false, dir ) ) {\r\n      nextPage = ( --page + length ) % length;\r\n    } else if ( key === 'Home' ) {\r\n      nextPage = 0;\r\n    } else if ( key === 'End' ) {\r\n      nextPage = length - 1;\r\n    }\r\n\r\n    const item = items[ nextPage ];\r\n\r\n    if ( item ) {\r\n      focus( item.button );\r\n      go( `>${ nextPage }` );\r\n      prevent( e, true );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the latest direction for pagination.\r\n   */\r\n  function getDirection(): Options['direction'] {\r\n    return options.paginationDirection || options.direction;\r\n  }\r\n\r\n  /**\r\n   * Returns the pagination item at the specified index.\r\n   *\r\n   * @param index - An index.\r\n   *\r\n   * @return A pagination item object if available, or otherwise `undefined`.\r\n   */\r\n  function getAt( index: number ): PaginationItem | undefined {\r\n    return items[ Controller.toPage( index ) ];\r\n  }\r\n\r\n  /**\r\n   * Updates the pagination status.\r\n   */\r\n  function update(): void {\r\n    const prev = getAt( getIndex( true ) );\r\n    const curr = getAt( getIndex() );\r\n\r\n    if ( prev ) {\r\n      const { button } = prev;\r\n      removeClass( button, CLASS_ACTIVE );\r\n      removeAttribute( button, ARIA_SELECTED );\r\n      setAttribute( button, TAB_INDEX, -1 );\r\n    }\r\n\r\n    if ( curr ) {\r\n      const { button } = curr;\r\n      addClass( button, CLASS_ACTIVE );\r\n      setAttribute( button, ARIA_SELECTED, true );\r\n      setAttribute( button, TAB_INDEX, '' );\r\n    }\r\n\r\n    emit( EVENT_PAGINATION_UPDATED, { list, items }, prev, curr );\r\n  }\r\n\r\n  return {\r\n    items,\r\n    mount,\r\n    destroy,\r\n    getAt,\r\n    update,\r\n  };\r\n}\r\n","import { SCROLL_LISTENER_OPTIONS } from '../../constants/listener-options';\r\nimport { MOVING } from '../../constants/states';\r\nimport { EventInterface } from '../../constructors';\r\nimport { Splide } from '../../core/Splide/Splide';\r\nimport { BaseComponent, Components, Options } from '../../types';\r\nimport { abs, prevent, timeOf } from '../../utils';\r\n\r\n\r\n/**\r\n * The interface for the Wheel component.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport interface WheelComponent extends BaseComponent {\r\n}\r\n\r\n/**\r\n * The component for observing the mouse wheel and moving the slider.\r\n *\r\n * @since 3.0.0\r\n *\r\n * @param Splide     - A Splide instance.\r\n * @param Components - A collection of components.\r\n * @param options    - Options.\r\n *\r\n * @return A Wheel component object.\r\n */\r\nexport function Wheel( Splide: Splide, Components: Components, options: Options ): WheelComponent {\r\n  const { bind } = EventInterface( Splide );\r\n\r\n  /**\r\n   * Holds the last time when the wheel moves the slider.\r\n   */\r\n  let lastTime = 0;\r\n\r\n  /**\r\n   * Called when the component is mounted.\r\n   */\r\n  function mount(): void {\r\n    if ( options.wheel ) {\r\n      bind( Components.Elements.track, 'wheel', onWheel, SCROLL_LISTENER_OPTIONS );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Called when the user rotates the mouse wheel on the slider.\r\n   *\r\n   * @param e - A WheelEvent object.\r\n   */\r\n  function onWheel( e: WheelEvent ): void {\r\n    if ( e.cancelable ) {\r\n      const { deltaY } = e;\r\n      const backwards = deltaY < 0;\r\n      const timeStamp = timeOf( e );\r\n      const min       = options.wheelMinThreshold || 0;\r\n      const sleep     = options.wheelSleep || 0;\r\n\r\n      if ( abs( deltaY ) > min && timeStamp - lastTime > sleep ) {\r\n        Splide.go( backwards ? '<' : '>' );\r\n        lastTime = timeStamp;\r\n      }\r\n\r\n      shouldPrevent( backwards ) && prevent( e );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Checks whether the component should prevent the default action of the wheel event or not.\r\n   *\r\n   * @param backwards - Set this to `true` for backwards direction.\r\n   *\r\n   * @return `true` if the action should be prevented.\r\n   */\r\n  function shouldPrevent( backwards: boolean ): boolean {\r\n    return ! options.releaseWheel\r\n      || Splide.state.is( MOVING )\r\n      || Components.Controller.getAdjacent( backwards ) !== -1;\r\n  }\r\n\r\n  return {\r\n    mount,\r\n  };\r\n}\r\n","import { ARIA_ATOMIC, ARIA_BUSY, ARIA_LIVE } from '../../constants/attributes';\r\nimport { CLASS_SR } from '../../constants/classes';\r\nimport { EVENT_AUTOPLAY_PAUSE, EVENT_AUTOPLAY_PLAY, EVENT_MOVED, EVENT_SCROLLED } from '../../constants/events';\r\nimport { EventInterface, RequestInterval } from '../../constructors';\r\nimport { Splide } from '../../core/Splide/Splide';\r\nimport { BaseComponent, Components, Options } from '../../types';\r\nimport { append, apply, create, remove, removeAttribute, setAttribute } from '../../utils';\r\n\r\n\r\n/**\r\n * The interface for the Live component.\r\n *\r\n * @since 4.0.0\r\n */\r\nexport interface LiveComponent extends BaseComponent {\r\n  disable( disabled: boolean ): void;\r\n}\r\n\r\n/**\r\n * Delay in milliseconds before removing the SR field for Windows Narrator.\r\n */\r\nconst SR_REMOVAL_DELAY = 90;\r\n\r\n/**\r\n * The component for implementing Live Region to the slider.\r\n *\r\n * @link https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Live_Regions\r\n *\r\n * @since 4.0.0\r\n *\r\n * @param Splide     - A Splide instance.\r\n * @param Components - A collection of components.\r\n * @param options    - Options.\r\n *\r\n * @return A Live component object.\r\n */\r\nexport function Live( Splide: Splide, Components: Components, options: Options ): LiveComponent {\r\n  const { on } = EventInterface( Splide );\r\n  const { track } = Components.Elements;\r\n\r\n  /**\r\n   * Indicates whether the live region is enabled or not.\r\n   */\r\n  const enabled = options.live && ! options.isNavigation;\r\n\r\n  /**\r\n   * The span element for the SR only text.\r\n   */\r\n  const sr = create( 'span', CLASS_SR );\r\n\r\n  /**\r\n   * Holds the RequestInterval instance.\r\n   */\r\n  const interval = RequestInterval( SR_REMOVAL_DELAY, apply( toggle, false ) );\r\n\r\n  /**\r\n   * Called when the component is mounted.\r\n   * - JAWS needs `aria-atomic` to make the `aria-busy` work.\r\n   * - Immediately removing the SR makes Windows Narrator silent, hence requires the delay around 50ms.\r\n   */\r\n  function mount(): void {\r\n    if ( enabled ) {\r\n      disable( ! Components.Autoplay.isPaused() );\r\n      setAttribute( track, ARIA_ATOMIC, true );\r\n      sr.textContent = '';\r\n\r\n      on( EVENT_AUTOPLAY_PLAY, apply( disable, true ) );\r\n      on( EVENT_AUTOPLAY_PAUSE, apply( disable, false ) );\r\n      on( [ EVENT_MOVED, EVENT_SCROLLED ], apply( toggle, true ) );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Toggles the SR field and `aria-busy`.\r\n   *\r\n   * @param active - Determines whether to activate the field or not.\r\n   */\r\n  function toggle( active: boolean ): void {\r\n    setAttribute( track, ARIA_BUSY, active );\r\n\r\n    if ( active ) {\r\n      append( track, sr );\r\n      interval.start();\r\n    } else {\r\n      remove( sr );\r\n      interval.cancel();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Destroys the component.\r\n   */\r\n  function destroy(): void {\r\n    removeAttribute( track, [ ARIA_LIVE, ARIA_ATOMIC, ARIA_BUSY ] );\r\n    remove( sr );\r\n  }\r\n\r\n  /**\r\n   * Disables/enables the live region.\r\n   * Does nothing when the `live` option is not enabled.\r\n   *\r\n   * @param disabled - `true` to disable the live region or `false` to enable it again.\r\n   */\r\n  function disable( disabled: boolean ): void {\r\n    if ( enabled ) {\r\n      setAttribute( track, ARIA_LIVE, disabled ? 'off' : 'polite' );\r\n    }\r\n  }\r\n\r\n  return {\r\n    mount,\r\n    disable,\r\n    destroy,\r\n  };\r\n}","import { Options } from '../types';\r\nimport { CLASSES } from './classes';\r\nimport { I18N } from './i18n';\r\n\r\n\r\n/**\r\n * The collection of default options.\r\n * Note that this collection does not contain all options.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport const DEFAULTS: Options = {\r\n  type              : 'slide',\r\n  role              : 'region',\r\n  speed             : 400,\r\n  perPage           : 1,\r\n  cloneStatus       : true,\r\n  arrows            : true,\r\n  pagination        : true,\r\n  paginationKeyboard: true,\r\n  interval          : 5000,\r\n  pauseOnHover      : true,\r\n  pauseOnFocus      : true,\r\n  resetProgress     : true,\r\n  easing            : 'cubic-bezier(0.25, 1, 0.5, 1)',\r\n  drag              : true,\r\n  direction         : 'ltr',\r\n  trimSpace         : true,\r\n  focusableNodes    : 'a, button, textarea, input, select, iframe',\r\n  live              : true,\r\n  classes           : CLASSES,\r\n  i18n              : I18N,\r\n  reducedMotion: {\r\n    speed      : 0,\r\n    rewindSpeed: 0,\r\n    autoplay   : 'pause',\r\n  },\r\n};","/**\r\n * The collection of i18n strings.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport const I18N = {\r\n  prev      : 'Previous slide',\r\n  next      : 'Next slide',\r\n  first     : 'Go to first slide',\r\n  last      : 'Go to last slide',\r\n  slideX    : 'Go to slide %s',\r\n  pageX     : 'Go to page %s',\r\n  play      : 'Start autoplay',\r\n  pause     : 'Pause autoplay',\r\n  carousel  : 'carousel',\r\n  slide     : 'slide',\r\n  select    : 'Select a slide to show',\r\n  slideLabel: '%s of %s', // [ slide number ] / [ slide size ]\r\n};\r\n","import { EVENT_MOUNTED, EVENT_REFRESH } from '../../constants/events';\r\nimport { EventInterface } from '../../constructors';\r\nimport { Splide } from '../../core/Splide/Splide';\r\nimport { Components, Options, TransitionComponent } from '../../types';\r\nimport { nextTick, noop } from '../../utils';\r\n\r\n\r\n/**\r\n * The component for the fade transition.\r\n *\r\n * @since 3.0.0\r\n *\r\n * @param Splide     - A Splide instance.\r\n * @param Components - A collection of components.\r\n * @param options    - Options.\r\n *\r\n * @return A Transition component object.\r\n */\r\nexport function Fade( Splide: Splide, Components: Components, options: Options ): TransitionComponent {\r\n  const { Slides } = Components;\r\n\r\n  /**\r\n   * Called when the component is mounted.\r\n   */\r\n  function mount(): void {\r\n    EventInterface( Splide ).on( [ EVENT_MOUNTED, EVENT_REFRESH ], init );\r\n  }\r\n\r\n  /**\r\n   * Initializes the component.\r\n   * Offsets all slides for stacking them onto the head of the list.\r\n   * The `nextTick` disables the initial fade transition of the first slide.\r\n   */\r\n  function init(): void {\r\n    Slides.forEach( Slide => {\r\n      Slide.style( 'transform', `translateX(-${ 100 * Slide.index }%)` );\r\n    } );\r\n  }\r\n\r\n  /**\r\n   * Starts the transition.\r\n   *\r\n   * @param index - A slide index to be active.\r\n   * @param done  - The callback function that must be called after the transition ends.\r\n   */\r\n  function start( index: number, done: () => void ): void {\r\n    Slides.style( 'transition', `opacity ${ options.speed }ms ${ options.easing }` );\r\n    nextTick( done );\r\n  }\r\n\r\n  return {\r\n    mount,\r\n    start,\r\n    cancel: noop,\r\n  };\r\n}\r\n","import { SLIDE } from '../../constants/types';\r\nimport { EventInterface } from '../../constructors';\r\nimport { Splide } from '../../core/Splide/Splide';\r\nimport { Components, Options, TransitionComponent } from '../../types';\r\nimport { abs, apply, style } from '../../utils';\r\n\r\n\r\n/**\r\n * The component for the slide transition.\r\n *\r\n * @since 3.0.0\r\n *\r\n * @param Splide     - A Splide instance.\r\n * @param Components - A collection of components.\r\n * @param options    - Options.\r\n *\r\n * @return A Transition component object.\r\n */\r\nexport function Slide( Splide: Splide, Components: Components, options: Options ): TransitionComponent {\r\n  const { Move, Controller, Scroll } = Components;\r\n  const { list } = Components.Elements;\r\n  const transition = apply( style, list, 'transition' );\r\n\r\n  /**\r\n   * Holds the `done` callback function.\r\n   */\r\n  let endCallback: () => void;\r\n\r\n  /**\r\n   * Called when the component is mounted.\r\n   */\r\n  function mount(): void {\r\n    EventInterface( Splide ).bind( list, 'transitionend', e => {\r\n      if ( e.target === list && endCallback ) {\r\n        cancel();\r\n        endCallback();\r\n      }\r\n    } );\r\n  }\r\n\r\n  /**\r\n   * Starts the transition.\r\n   * The Move component calls this method just before the slider moves.\r\n   *\r\n   * @param index - A destination index.\r\n   * @param done  - The callback function that must be called after the transition ends.\r\n   */\r\n  function start( index: number, done: () => void ): void {\r\n    const destination = Move.toPosition( index, true );\r\n    const position    = Move.getPosition();\r\n    const speed       = getSpeed( index );\r\n\r\n    if ( abs( destination - position ) >= 1 && speed >= 1 ) {\r\n      if ( options.useScroll ) {\r\n        Scroll.scroll( destination, speed, false, done );\r\n      } else {\r\n        transition( `transform ${ speed }ms ${ options.easing }` );\r\n        Move.translate( destination, true );\r\n        endCallback = done;\r\n      }\r\n    } else {\r\n      Move.jump( index );\r\n      done();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Cancels the transition.\r\n   */\r\n  function cancel(): void {\r\n    transition( '' );\r\n    Scroll.cancel();\r\n  }\r\n\r\n  /**\r\n   * Returns the transition speed.\r\n   *\r\n   * @param index - A destination index.\r\n   */\r\n  function getSpeed( index: number ): number {\r\n    const { rewindSpeed } = options;\r\n\r\n    if ( Splide.is( SLIDE ) && rewindSpeed ) {\r\n      const prev = Controller.getIndex( true );\r\n      const end  = Controller.getEnd();\r\n\r\n      if ( ( prev === 0 && index >= end ) || ( prev >= end && index === 0 ) ) {\r\n        return rewindSpeed;\r\n      }\r\n    }\r\n\r\n    return options.speed;\r\n  }\r\n\r\n  return {\r\n    mount,\r\n    start,\r\n    cancel,\r\n  };\r\n}\r\n","import * as ComponentConstructors from '../../components';\r\nimport { SlideMatcher } from '../../components/Slides/Slides';\r\nimport { CLASS_INITIALIZED } from '../../constants/classes';\r\nimport { DEFAULTS } from '../../constants/defaults';\r\nimport { EVENT_DESTROY, EVENT_MOUNTED, EVENT_READY, EVENT_REFRESH } from '../../constants/events';\r\nimport { DATA_ATTRIBUTE } from '../../constants/project';\r\nimport { CREATED, DESTROYED, IDLE, STATES } from '../../constants/states';\r\nimport { FADE } from '../../constants/types';\r\nimport { EventInterface, EventInterfaceObject, State, StateObject } from '../../constructors';\r\nimport { Fade, Slide } from '../../transitions';\r\nimport { AnyFunction, ComponentConstructor, Components, EventMap, Options, SyncTarget } from '../../types';\r\nimport { addClass, assert, assign, empty, forOwn, getAttribute, isString, merge, query, slice } from '../../utils';\r\nimport { ARIA_LABEL, ARIA_LABELLEDBY } from '../../constants/attributes';\r\n\r\n\r\n/**\r\n * The frontend class for the Splide slider.\r\n *\r\n * @since 3.0.0\r\n */\r\nexport class Splide {\r\n  /**\r\n   * Changes the default options for all Splide instances.\r\n   */\r\n  static defaults: Options = {};\r\n\r\n  /**\r\n   * The collection of state numbers.\r\n   */\r\n  static readonly STATES = STATES;\r\n\r\n  /**\r\n   * The root element where the Splide is applied.\r\n   */\r\n  readonly root: HTMLElement;\r\n\r\n  /**\r\n   * The EventBusObject object.\r\n   */\r\n  readonly event: EventInterfaceObject = EventInterface();\r\n\r\n  /**\r\n   * The collection of all component objects.\r\n   */\r\n  readonly Components: Components = {} as Components;\r\n\r\n  /**\r\n   * The StateObject object.\r\n   */\r\n  readonly state: StateObject = State( CREATED );\r\n\r\n  /**\r\n   * An array with SyncTarget objects for splide instances to sync with.\r\n   */\r\n  readonly splides: SyncTarget[] = [];\r\n\r\n  /**\r\n   * The current options.\r\n   */\r\n  private readonly _o: Options = {};\r\n\r\n  /**\r\n   * The collection of all components.\r\n   */\r\n  private _C: Components;\r\n\r\n  /**\r\n   * The collection of extensions.\r\n   */\r\n  private _E: Record<string, ComponentConstructor> = {};\r\n\r\n  /**\r\n   * The Transition component.\r\n   */\r\n  private _T: ComponentConstructor;\r\n\r\n  /**\r\n   * The Splide constructor.\r\n   *\r\n   * @param target  - The selector for the target element, or the element itself.\r\n   * @param options - Optional. An object with options.\r\n   */\r\n  constructor( target: string | HTMLElement, options?: Options ) {\r\n    const root = isString( target ) ? query<HTMLElement>( document, target ) : target;\r\n    assert( root, `${ root } is invalid.` );\r\n\r\n    this.root = root;\r\n\r\n    options = merge( {\r\n      label     : getAttribute( root, ARIA_LABEL ) || '',\r\n      labelledby: getAttribute( root, ARIA_LABELLEDBY ) || '',\r\n    }, DEFAULTS, Splide.defaults, options || {} );\r\n\r\n    try {\r\n      merge( options, JSON.parse( getAttribute( root, DATA_ATTRIBUTE ) ) );\r\n    } catch ( e ) {\r\n      assert( false, 'Invalid JSON' );\r\n    }\r\n\r\n    this._o = Object.create( merge( {}, options ) );\r\n  }\r\n\r\n  /**\r\n   * Initializes the instance.\r\n   *\r\n   * @param Extensions - Optional. An object with extensions.\r\n   * @param Transition - Optional. A Transition component.\r\n   *\r\n   * @return `this`\r\n   */\r\n  mount( Extensions?: Record<string, ComponentConstructor>, Transition?: ComponentConstructor ): this {\r\n    const { state, Components } = this;\r\n    assert( state.is( [ CREATED, DESTROYED ] ), 'Already mounted!' );\r\n\r\n    state.set( CREATED );\r\n\r\n    this._C = Components;\r\n    this._T = Transition || this._T || ( this.is( FADE ) ? Fade : Slide );\r\n    this._E = Extensions || this._E;\r\n\r\n    const Constructors = assign( {}, ComponentConstructors, this._E, { Transition: this._T } );\r\n\r\n    forOwn( Constructors, ( Component, key ) => {\r\n      const component = Component( this, Components, this._o );\r\n      Components[ key ] = component;\r\n      component.setup && component.setup();\r\n    } );\r\n\r\n    forOwn( Components, component => {\r\n      component.mount && component.mount();\r\n    } );\r\n\r\n    this.emit( EVENT_MOUNTED );\r\n\r\n    addClass( this.root, CLASS_INITIALIZED );\r\n\r\n    state.set( IDLE );\r\n    this.emit( EVENT_READY );\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Syncs the slider with the provided one.\r\n   * This method must be called before the `mount()`.\r\n   *\r\n   * @example\r\n   * ```ts\r\n   * var primary   = new Splide();\r\n   * var secondary = new Splide();\r\n   *\r\n   * primary.sync( secondary );\r\n   * primary.mount();\r\n   * secondary.mount();\r\n   * ```\r\n   *\r\n   * @param splide - A Splide instance to sync with.\r\n   *\r\n   * @return `this`\r\n   */\r\n  sync( splide: Splide ): this {\r\n    this.splides.push( { splide } );\r\n    splide.splides.push( { splide: this, isParent: true } );\r\n\r\n    if ( this.state.is( IDLE ) ) {\r\n      this._C.Sync.remount();\r\n      splide.Components.Sync.remount();\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Moves the slider with the following control pattern.\r\n   *\r\n   * | Pattern | Description |\r\n   * |---|---|\r\n   * | `i` | Goes to the slide `i` |\r\n   * | `'+${i}'` | Increments the slide index by `i` |\r\n   * | `'-${i}'` | Decrements the slide index by `i` |\r\n   * | `'>'` | Goes to the next page |\r\n   * | `'<'` | Goes to the previous page |\r\n   * | `>${i}` | Goes to the page `i` |\r\n   *\r\n   * In most cases, `'>'` and `'<'` notations are enough to control the slider\r\n   * because they respect `perPage` and `perMove` options.\r\n   *\r\n   * @example\r\n   * ```ts\r\n   * var splide = new Splide();\r\n   *\r\n   * // Goes to the slide 1:\r\n   * splide.go( 1 );\r\n   *\r\n   * // Increments the index:\r\n   * splide.go( '+2' );\r\n   *\r\n   * // Goes to the next page:\r\n   * splide.go( '>' );\r\n   *\r\n   * // Goes to the page 2:\r\n   * splide.go( '>2' );\r\n   * ```\r\n   *\r\n   * @param control - A control pattern.\r\n   *\r\n   * @return `this`\r\n   */\r\n  go( control: number | string ): this {\r\n    this._C.Controller.go( control );\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Registers an event handler.\r\n   *\r\n   * @example\r\n   * ```ts\r\n   * var splide = new Splide();\r\n   *\r\n   * // Listens to a single event:\r\n   * splide.on( 'move', function() {} );\r\n   *\r\n   * // Listens to multiple events:\r\n   * splide.on( 'move resize', function() {} );\r\n   *\r\n   * // Appends a namespace:\r\n   * splide.on( 'move.myNamespace resize.myNamespace', function() {} );\r\n   * ```\r\n   *\r\n   * @param events   - An event name or names separated by spaces. Use a dot(.) to append a namespace.\r\n   * @param callback - A callback function.\r\n   *\r\n   * @return `this`\r\n   */\r\n  on<K extends keyof EventMap>( events: K, callback: EventMap[ K ] ): this;\r\n  on( events: string | string[], callback: AnyFunction ): this;\r\n  on( events: string | string[], callback: AnyFunction ): this {\r\n    this.event.on( events, callback );\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Removes the registered all handlers for the specified event or events.\r\n   * If you want to only remove a particular handler, use namespace to identify it.\r\n   *\r\n   * @example\r\n   * ```ts\r\n   * var splide = new Splide();\r\n   *\r\n   * // Removes all handlers assigned to \"move\":\r\n   * splide.off( 'move' );\r\n   *\r\n   * // Only removes handlers that belong to the specified namespace:\r\n   * splide.off( 'move.myNamespace' );\r\n   * ```\r\n   *\r\n   * @param events - An event name or names separated by spaces. Use a dot(.) to append a namespace.\r\n   *\r\n   * @return `this`\r\n   */\r\n  off<K extends keyof EventMap>( events: K | K[] | string | string[] ): this {\r\n    this.event.off( events );\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Emits an event and triggers registered handlers.\r\n   *\r\n   * @param event - An event name to emit.\r\n   * @param args  - Optional. Any number of arguments to pass to handlers.\r\n   *\r\n   * @return `this`\r\n   */\r\n  emit<K extends keyof EventMap>( event: K, ...args: Parameters<EventMap[ K ]> ): this;\r\n  emit( event: string, ...args: any[] ): this;\r\n  emit( event: string ): this {\r\n    // eslint-disable-next-line prefer-rest-params, prefer-spread\r\n    this.event.emit( event, ...slice( arguments, 1 ) );\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Inserts a slide at the specified position.\r\n   *\r\n   * @example\r\n   * ```ts\r\n   * var splide = new Splide();\r\n   * splide.mount();\r\n   *\r\n   * // Adds the slide by the HTML:\r\n   * splide.add( '<li></li> );\r\n   *\r\n   * // or adds the element:\r\n   * splide.add( document.createElement( 'li' ) );\r\n   * ```\r\n   *\r\n   * @param slides - A slide element, an HTML string that represents a slide, or an array with them.\r\n   * @param index  - Optional. An index to insert a slide at.\r\n   *\r\n   * @return `this`\r\n   */\r\n  add( slides: string | HTMLElement | Array<string | HTMLElement>, index?: number ): this {\r\n    this._C.Slides.add( slides, index );\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Removes slides that match the matcher\r\n   * that can be an index, an array with indices, a selector, or an iteratee function.\r\n   *\r\n   * @param matcher - An index, an array with indices, a selector string, or an iteratee function.\r\n   */\r\n  remove( matcher: SlideMatcher ): this {\r\n    this._C.Slides.remove( matcher );\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Checks the slider type.\r\n   *\r\n   * @param type - A type to test.\r\n   *\r\n   * @return `true` if the type matches the current one, or otherwise `false`.\r\n   */\r\n  is( type: string ): boolean {\r\n    return this._o.type === type;\r\n  }\r\n\r\n  /**\r\n   * Refreshes the slider.\r\n   *\r\n   * @return `this`\r\n   */\r\n  refresh(): this {\r\n    this.emit( EVENT_REFRESH );\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Destroys the slider.\r\n   *\r\n   * @param completely - Optional. If `true`, Splide will not remount the slider by breakpoints.\r\n   *\r\n   * @return `this`\r\n   */\r\n  destroy( completely = true ): this {\r\n    const { event, state } = this;\r\n\r\n    if ( state.is( CREATED ) ) {\r\n      // Postpones destruction requested before the slider becomes ready.\r\n      EventInterface( this ).on( EVENT_READY, this.destroy.bind( this, completely ) );\r\n    } else {\r\n      forOwn( this._C, component => {\r\n        component.destroy && component.destroy( completely );\r\n      }, true );\r\n\r\n      event.emit( EVENT_DESTROY );\r\n      event.destroy();\r\n      completely && empty( this.splides );\r\n      state.set( DESTROYED );\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Returns options.\r\n   *\r\n   * @return An object with the latest options.\r\n   */\r\n  get options(): Options {\r\n    return this._o;\r\n  }\r\n\r\n  /**\r\n   * Merges options to the current options and emits `updated` event.\r\n   *\r\n   * @param options - An object with new options.\r\n   */\r\n  set options( options: Options ) {\r\n    this._C.Media.set( options, true, true );\r\n  }\r\n\r\n  /**\r\n   * Returns the number of slides without clones.\r\n   *\r\n   * @return The number of slides.\r\n   */\r\n  get length(): number {\r\n    return this._C.Slides.getLength( true );\r\n  }\r\n\r\n  /**\r\n   * Returns the active slide index.\r\n   *\r\n   * @return The active slide index.\r\n   */\r\n  get index(): number {\r\n    return this._C.Controller.getIndex();\r\n  }\r\n}\r\n"],"names":["n","t","r","i","length","enumerable","configurable","writable","Object","defineProperty","key","Jt","prototype","v","D","o","Array","slice","call","R","bind","apply","concat","arguments","on","p","setTimeout","h","requestAnimationFrame","u","un","e","isArray","x","C","en","m","ownerDocument","defaultView","window","HTMLElement","y","g","forEach","b","indexOf","k","push","A","classList","M","split","L","appendChild","O","parentNode","insertBefore","cn","msMatchesSelector","matches","S","children","filter","fn","firstElementChild","E","keys","w","reverse","an","d","sn","P","removeAttribute","I","c","setAttribute","String","j","document","createElement","_","getComputedStyle","style","ln","dn","setActive","focus","preventScroll","z","getAttribute","vn","contains","N","getBoundingClientRect","T","removeChild","hn","DOMParser","parseFromString","body","F","preventDefault","stopPropagation","stopImmediatePropagation","pn","querySelector","gn","querySelectorAll","X","mn","timeStamp","W","yn","f","bn","Error","Y","Math","min","wn","max","xn","floor","kn","ceil","U","abs","En","q","On","replace","An","_n","zn","removeEventListener","removeListener","addEventListener","addListener","unbind","dispatch","CustomEvent","bubbles","detail","createEvent","initCustomEvent","dispatchEvent","destroy","B","H","Dn","Mn","J","K","jn","Nn","Tn","V","a","Gn","Fn","Xn","Wn","Q","event","bus","createDocumentFragment","join","off","emit","qn","Date","now","s","l","cancelAnimationFrame","start","rewind","pause","cancel","set","isPaused","Bn","Hn","width","left","right","ArrowLeft","ArrowRight","Z","$","Kn","Vn","Qn","nn","Zn","$n","nt","tt","it","rt","ot","ut","ct","ft","at","st","lt","dt","vt","ht","pt","gt","mt","yt","bt","wt","tn","xt","kt","St","Et","Lt","Ot","At","_t","zt","Dt","Mt","Pt","It","Ct","jt","passive","capture","Nt","Spacebar","Right","Left","Up","Down","Tt","Gt","Ft","Xt","Wt","Yt","Ut","freeze","__proto__","Media","state","breakpoints","reducedMotion","matchMedia","is","direction","reduce","mount","refresh","getPrototypeOf","setup","mediaQuery","sort","Direction","resolve","toLowerCase","charAt","toUpperCase","orient","Elements","root","i18n","arrows","pagination","prev","next","bar","toggle","track","list","slides","id","role","tagName","carousel","label","labelledby","closest","nodeType","parentElement","type","drag","isNavigation","Slides","Rt","Components","options","updateOnMove","slideFocus","splides","map","splide","getAt","slide","slideX","index","focusableNodes","activeElement","cloneStatus","slideIndex","container","isClone","slideLabel","update","isWithin","register","get","getIn","Controller","toIndex","hasFocus","perPage","add","classes","remove","getLength","isEnough","Layout","height","gap","autoWidth","fixedWidth","fixedHeight","autoHeight","padding","heightRatio","parseFloat","resize","listSize","slideSize","sliderSize","totalSize","getPadding","isOverflow","Clones","cloneNode","clone","clones","Move","isBusy","Scroll","getEnd","trimSpace","Transition","move","jump","translate","shift","toPosition","getPosition","getLimit","exceededLimit","reposition","omitEnd","perMove","waitForTransition","go","match","scroll","getNext","getPrev","getAdjacent","setIndex","getIndex","toPage","toDest","Arrows","arrow","arrowPath","last","first","disabled","Autoplay","interval","autoplay","resetProgress","pauseOnHover","pauseOnFocus","play","Cover","src","cover","Ln","easingFunc","pow","Drag","target","noDrag","button","cancelable","dragMinThreshold","mouse","touch","flickPower","flickMaxPages","rewindByDrag","snap","changedTouches","TouchEvent","disable","isDragging","Keyboard","keyboard","LazyLoad","lazyLoad","srcset","spinner","preloadPages","check","Pagination","paginationDirection","items","select","class","page","pageX","paginationKeyboard","li","Sync","isParent","remount","Wheel","deltaY","wheelMinThreshold","wheelSleep","releaseWheel","wheel","Live","live","textContent","qt","speed","easing","rewindSpeed","Bt","Ht","useScroll","defaults","JSON","parse","create","sync","STATES","CREATED","MOUNTED","IDLE","MOVING","SCROLLING","DRAGGING","DESTROYED","exports","module","define","amd","globalThis","self","Splide","MEDIA_PREFERS_REDUCED_MOTION","empty","array","arrayLike","end","func","noop","nextTick","raf","typeOf","subject","isObject","isNull","isFunction","isString","isUndefined","isHTMLElement","toArray","value","values","iteratee","includes","toggleClass","elm","name","addClass","append","parent","before","nodes","ref","node","selector","child","ownKeys","forOwn","object","assign","source","merge","omit","elms","attrs","attr","tag","prop","display","hasClass","className","rect","parseHtml","html","prevent","query","queryAll","removeClass","timeOf","unit","PROJECT_CODE","DATA_ATTRIBUTE","assert","condition","message","approximatelyEqual","epsilon","between","number","exclusive","minimum","maximum","clamp","sign","format","string","replacements","replacement","pad","ids","EventBinder","listeners","forEachEvent","targets","events","eventNS","fragment","callback","namespace","isEventTarget","remover","listener","data","EVENT_MOUNTED","EVENT_MOVE","EVENT_MOVED","EVENT_CLICK","EVENT_ACTIVE","EVENT_INACTIVE","EVENT_VISIBLE","EVENT_HIDDEN","EVENT_REFRESH","EVENT_UPDATED","EVENT_RESIZE","EVENT_RESIZED","EVENT_SCROLL","EVENT_SCROLLED","EVENT_DESTROY","EVENT_NAVIGATION_MOUNTED","EVENT_AUTOPLAY_PLAY","EVENT_AUTOPLAY_PAUSE","EVENT_LAZYLOAD_LOADED","EVENT_SLIDE_KEYDOWN","EVENT_SHIFTED","EventInterface","binder","RequestInterval","onInterval","onUpdate","limit","startTime","rate","paused","count","resume","time","State","initialState","states","ARROW","ARROW_LEFT","ARROW_RIGHT","ARROW_UP","ARROW_DOWN","TTB","ORIENTATION_MAP","ROLE","TAB_INDEX","ARIA_PREFIX","ARIA_CONTROLS","ARIA_CURRENT","ARIA_SELECTED","ARIA_LABEL","ARIA_LABELLEDBY","ARIA_HIDDEN","ARIA_ORIENTATION","ARIA_ROLEDESCRIPTION","ARIA_LIVE","ARIA_BUSY","ARIA_ATOMIC","ALL_ATTRIBUTES","CLASS_PREFIX","CLASS_ROOT","CLASS_TRACK","CLASS_LIST","CLASS_SLIDE","CLASS_CLONE","CLASS_CONTAINER","CLASS_ARROWS","CLASS_ARROW","CLASS_ARROW_PREV","CLASS_ARROW_NEXT","CLASS_PAGINATION","CLASS_PAGINATION_PAGE","CLASS_PROGRESS_BAR","CLASS_TOGGLE","CLASS_SR","CLASS_ACTIVE","STATUS_CLASS_PREFIX","CLASS_PREV","CLASS_NEXT","CLASS_VISIBLE","CLASS_LOADING","CLASS_FOCUS_IN","CLASS_OVERFLOW","STATUS_CLASSES","POINTER_DOWN_EVENTS","POINTER_MOVE_EVENTS","POINTER_UP_EVENTS","SLIDE","LOOP","FADE","Slide","destroyed","styles","initNavigation","controls","onMove","curr","hidden","active","isActive","visible","trackRect","slideRect","useContainer","_style","from","distance","diff","INTERVAL_DATA_ATTRIBUTE","SCROLL_LISTENER_OPTIONS","NORMALIZATION_MAP","normalizeKey","KEYBOARD_EVENT","SRC_DATA_ATTRIBUTE","SRCSET_DATA_ATTRIBUTE","IMAGE_SELECTOR","TRIGGER_KEYS","queries","completely","queryList","merged","entry","opts","base","notify","isMin","enable","axisOnly","offset","isUsingKey","elements","rootClasses","trackClasses","find","prefix","getClasses","init","Slide1","Slide2","excludeClones","matcher","forEachItem","images","img","removeNode","vertical","rootRect","overflow","styleSlides","cssPadding","force","newRect","cssHeight","cssSlideSize","withoutGap","getGap","duration","cloneCount","observe","computeCloneCount","generate","isHead","fixedSize","position","preventLoop","destination","exceededMax","backwards","excess","size","minDistance","Infinity","trimming","dest","shifted","exceededMin","endIndex","slideCount","isLoop","isSlide","currIndex","prevIndex","onResized","computeDestIndex","loop","snapPage","control","allowSameIndex","indicator","_ref","created","wrapperClasses","placeholder","wrapper","enabled","createArrow","nextIndex","prevLabel","nextLabel","hovered","focused","stopped","stop","autoToggle","friction","onScrolled","noConstrain","noDistance","clear","onEnd","to","basePosition","baseEvent","prevBaseEvent","isFree","dragging","clickPrevented","exceeded","onPointerDown","isTouch","isTouchEvent","onPointerMove","onPointerUp","save","thresholds","isObj","diffCoord","expired","diffTime","hasExceeded","velocity","onClick","orthogonal","coordOf","getBaseEvent","onKeydown","_disabled","isSequential","entries","loadNext","load","onLoad","paginationClasses","dir","getDirection","nextPage","item","text","lastTime","onWheel","sleep","sr","DEFAULTS","Fade","done","endCallback","transition","this","_o","_E","_Splide","Extensions","_this","_C","_T","ComponentConstructors","Component","component","_this$event"],"version":3,"file":"medisapp.github.io.d5fc1d12.js.map"}